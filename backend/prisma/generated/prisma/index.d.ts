
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BaseCompetition
 * 
 */
export type BaseCompetition = $Result.DefaultSelection<Prisma.$BaseCompetitionPayload>
/**
 * Model BaseCountry
 * 
 */
export type BaseCountry = $Result.DefaultSelection<Prisma.$BaseCountryPayload>
/**
 * Model BaseField
 * 
 */
export type BaseField = $Result.DefaultSelection<Prisma.$BaseFieldPayload>
/**
 * Model BaseGroupLevel
 * 
 */
export type BaseGroupLevel = $Result.DefaultSelection<Prisma.$BaseGroupLevelPayload>
/**
 * Model BaseSport
 * 
 */
export type BaseSport = $Result.DefaultSelection<Prisma.$BaseSportPayload>
/**
 * Model GameEvent
 * 
 */
export type GameEvent = $Result.DefaultSelection<Prisma.$GameEventPayload>
/**
 * Model GameMatche
 * 
 */
export type GameMatche = $Result.DefaultSelection<Prisma.$GameMatchePayload>
/**
 * Model MatchEvent
 * 
 */
export type MatchEvent = $Result.DefaultSelection<Prisma.$MatchEventPayload>
/**
 * Model MatchLineup
 * 
 */
export type MatchLineup = $Result.DefaultSelection<Prisma.$MatchLineupPayload>
/**
 * Model MatchMedia
 * 
 */
export type MatchMedia = $Result.DefaultSelection<Prisma.$MatchMediaPayload>
/**
 * Model MatchRoster
 * 
 */
export type MatchRoster = $Result.DefaultSelection<Prisma.$MatchRosterPayload>
/**
 * Model MatchStatistic
 * 
 */
export type MatchStatistic = $Result.DefaultSelection<Prisma.$MatchStatisticPayload>
/**
 * Model MemberClubAdmin
 * 
 */
export type MemberClubAdmin = $Result.DefaultSelection<Prisma.$MemberClubAdminPayload>
/**
 * Model MemberCoache
 * 
 */
export type MemberCoache = $Result.DefaultSelection<Prisma.$MemberCoachePayload>
/**
 * Model MemberParent
 * 
 */
export type MemberParent = $Result.DefaultSelection<Prisma.$MemberParentPayload>
/**
 * Model MemberPerson
 * 
 */
export type MemberPerson = $Result.DefaultSelection<Prisma.$MemberPersonPayload>
/**
 * Model MemberPlayer
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type MemberPlayer = $Result.DefaultSelection<Prisma.$MemberPlayerPayload>
/**
 * Model MemberReferee
 * 
 */
export type MemberReferee = $Result.DefaultSelection<Prisma.$MemberRefereePayload>
/**
 * Model MemberSponsor
 * 
 */
export type MemberSponsor = $Result.DefaultSelection<Prisma.$MemberSponsorPayload>
/**
 * Model MemberTeamManager
 * 
 */
export type MemberTeamManager = $Result.DefaultSelection<Prisma.$MemberTeamManagerPayload>
/**
 * Model OrgClub
 * 
 */
export type OrgClub = $Result.DefaultSelection<Prisma.$OrgClubPayload>
/**
 * Model OrgLeague
 * 
 */
export type OrgLeague = $Result.DefaultSelection<Prisma.$OrgLeaguePayload>
/**
 * Model OrgTeam
 * 
 */
export type OrgTeam = $Result.DefaultSelection<Prisma.$OrgTeamPayload>
/**
 * Model PlanGame
 * 
 */
export type PlanGame = $Result.DefaultSelection<Prisma.$PlanGamePayload>
/**
 * Model PlanMeeting
 * 
 */
export type PlanMeeting = $Result.DefaultSelection<Prisma.$PlanMeetingPayload>
/**
 * Model PlanTraining
 * 
 */
export type PlanTraining = $Result.DefaultSelection<Prisma.$PlanTrainingPayload>
/**
 * Model RelClubClubAdmin
 * 
 */
export type RelClubClubAdmin = $Result.DefaultSelection<Prisma.$RelClubClubAdminPayload>
/**
 * Model RelCompetitionGroupLevel
 * 
 */
export type RelCompetitionGroupLevel = $Result.DefaultSelection<Prisma.$RelCompetitionGroupLevelPayload>
/**
 * Model RelFieldSport
 * 
 */
export type RelFieldSport = $Result.DefaultSelection<Prisma.$RelFieldSportPayload>
/**
 * Model RelMatchReferee
 * 
 */
export type RelMatchReferee = $Result.DefaultSelection<Prisma.$RelMatchRefereePayload>
/**
 * Model RelPlayerParent
 * 
 */
export type RelPlayerParent = $Result.DefaultSelection<Prisma.$RelPlayerParentPayload>
/**
 * Model RelSponsorClub
 * 
 */
export type RelSponsorClub = $Result.DefaultSelection<Prisma.$RelSponsorClubPayload>
/**
 * Model RelSponsorLeague
 * 
 */
export type RelSponsorLeague = $Result.DefaultSelection<Prisma.$RelSponsorLeaguePayload>
/**
 * Model RelSponsorTeam
 * 
 */
export type RelSponsorTeam = $Result.DefaultSelection<Prisma.$RelSponsorTeamPayload>
/**
 * Model RelTeamCoach
 * 
 */
export type RelTeamCoach = $Result.DefaultSelection<Prisma.$RelTeamCoachPayload>
/**
 * Model RelTeamPlayer
 * 
 */
export type RelTeamPlayer = $Result.DefaultSelection<Prisma.$RelTeamPlayerPayload>
/**
 * Model RelTeamTeamManager
 * 
 */
export type RelTeamTeamManager = $Result.DefaultSelection<Prisma.$RelTeamTeamManagerPayload>
/**
 * Model SportCoachType
 * 
 */
export type SportCoachType = $Result.DefaultSelection<Prisma.$SportCoachTypePayload>
/**
 * Model SportEventType
 * 
 */
export type SportEventType = $Result.DefaultSelection<Prisma.$SportEventTypePayload>
/**
 * Model SportGamePeriod
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type SportGamePeriod = $Result.DefaultSelection<Prisma.$SportGamePeriodPayload>
/**
 * Model SportManagerType
 * 
 */
export type SportManagerType = $Result.DefaultSelection<Prisma.$SportManagerTypePayload>
/**
 * Model SportPlayerPosition
 * 
 */
export type SportPlayerPosition = $Result.DefaultSelection<Prisma.$SportPlayerPositionPayload>
/**
 * Model SportRefereeType
 * 
 */
export type SportRefereeType = $Result.DefaultSelection<Prisma.$SportRefereeTypePayload>
/**
 * Model SubFeature
 * 
 */
export type SubFeature = $Result.DefaultSelection<Prisma.$SubFeaturePayload>
/**
 * Model SubForTeam
 * 
 */
export type SubForTeam = $Result.DefaultSelection<Prisma.$SubForTeamPayload>
/**
 * Model SubForUser
 * 
 */
export type SubForUser = $Result.DefaultSelection<Prisma.$SubForUserPayload>
/**
 * Model SubPlan
 * 
 */
export type SubPlan = $Result.DefaultSelection<Prisma.$SubPlanPayload>
/**
 * Model SubPlanFeature
 * 
 */
export type SubPlanFeature = $Result.DefaultSelection<Prisma.$SubPlanFeaturePayload>
/**
 * Model SysUser
 * 
 */
export type SysUser = $Result.DefaultSelection<Prisma.$SysUserPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BaseCompetitions
 * const baseCompetitions = await prisma.baseCompetition.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BaseCompetitions
   * const baseCompetitions = await prisma.baseCompetition.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  /**
   * Gives access to the client metrics in json or prometheus format.
   * 
   * @example
   * ```
   * const metrics = await prisma.$metrics.json()
   * // or
   * const metrics = await prisma.$metrics.prometheus()
   * ```
   */
  readonly $metrics: runtime.MetricsClient
  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.baseCompetition`: Exposes CRUD operations for the **BaseCompetition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseCompetitions
    * const baseCompetitions = await prisma.baseCompetition.findMany()
    * ```
    */
  get baseCompetition(): Prisma.BaseCompetitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baseCountry`: Exposes CRUD operations for the **BaseCountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseCountries
    * const baseCountries = await prisma.baseCountry.findMany()
    * ```
    */
  get baseCountry(): Prisma.BaseCountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baseField`: Exposes CRUD operations for the **BaseField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseFields
    * const baseFields = await prisma.baseField.findMany()
    * ```
    */
  get baseField(): Prisma.BaseFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baseGroupLevel`: Exposes CRUD operations for the **BaseGroupLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseGroupLevels
    * const baseGroupLevels = await prisma.baseGroupLevel.findMany()
    * ```
    */
  get baseGroupLevel(): Prisma.BaseGroupLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baseSport`: Exposes CRUD operations for the **BaseSport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseSports
    * const baseSports = await prisma.baseSport.findMany()
    * ```
    */
  get baseSport(): Prisma.BaseSportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameEvent`: Exposes CRUD operations for the **GameEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameEvents
    * const gameEvents = await prisma.gameEvent.findMany()
    * ```
    */
  get gameEvent(): Prisma.GameEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameMatche`: Exposes CRUD operations for the **GameMatche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameMatches
    * const gameMatches = await prisma.gameMatche.findMany()
    * ```
    */
  get gameMatche(): Prisma.GameMatcheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchEvent`: Exposes CRUD operations for the **MatchEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchEvents
    * const matchEvents = await prisma.matchEvent.findMany()
    * ```
    */
  get matchEvent(): Prisma.MatchEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchLineup`: Exposes CRUD operations for the **MatchLineup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchLineups
    * const matchLineups = await prisma.matchLineup.findMany()
    * ```
    */
  get matchLineup(): Prisma.MatchLineupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchMedia`: Exposes CRUD operations for the **MatchMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchMedias
    * const matchMedias = await prisma.matchMedia.findMany()
    * ```
    */
  get matchMedia(): Prisma.MatchMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchRoster`: Exposes CRUD operations for the **MatchRoster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchRosters
    * const matchRosters = await prisma.matchRoster.findMany()
    * ```
    */
  get matchRoster(): Prisma.MatchRosterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchStatistic`: Exposes CRUD operations for the **MatchStatistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchStatistics
    * const matchStatistics = await prisma.matchStatistic.findMany()
    * ```
    */
  get matchStatistic(): Prisma.MatchStatisticDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberClubAdmin`: Exposes CRUD operations for the **MemberClubAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberClubAdmins
    * const memberClubAdmins = await prisma.memberClubAdmin.findMany()
    * ```
    */
  get memberClubAdmin(): Prisma.MemberClubAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberCoache`: Exposes CRUD operations for the **MemberCoache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberCoaches
    * const memberCoaches = await prisma.memberCoache.findMany()
    * ```
    */
  get memberCoache(): Prisma.MemberCoacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberParent`: Exposes CRUD operations for the **MemberParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberParents
    * const memberParents = await prisma.memberParent.findMany()
    * ```
    */
  get memberParent(): Prisma.MemberParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberPerson`: Exposes CRUD operations for the **MemberPerson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberPeople
    * const memberPeople = await prisma.memberPerson.findMany()
    * ```
    */
  get memberPerson(): Prisma.MemberPersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberPlayer`: Exposes CRUD operations for the **MemberPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberPlayers
    * const memberPlayers = await prisma.memberPlayer.findMany()
    * ```
    */
  get memberPlayer(): Prisma.MemberPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberReferee`: Exposes CRUD operations for the **MemberReferee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberReferees
    * const memberReferees = await prisma.memberReferee.findMany()
    * ```
    */
  get memberReferee(): Prisma.MemberRefereeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberSponsor`: Exposes CRUD operations for the **MemberSponsor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberSponsors
    * const memberSponsors = await prisma.memberSponsor.findMany()
    * ```
    */
  get memberSponsor(): Prisma.MemberSponsorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.memberTeamManager`: Exposes CRUD operations for the **MemberTeamManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberTeamManagers
    * const memberTeamManagers = await prisma.memberTeamManager.findMany()
    * ```
    */
  get memberTeamManager(): Prisma.MemberTeamManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgClub`: Exposes CRUD operations for the **OrgClub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrgClubs
    * const orgClubs = await prisma.orgClub.findMany()
    * ```
    */
  get orgClub(): Prisma.OrgClubDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgLeague`: Exposes CRUD operations for the **OrgLeague** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrgLeagues
    * const orgLeagues = await prisma.orgLeague.findMany()
    * ```
    */
  get orgLeague(): Prisma.OrgLeagueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgTeam`: Exposes CRUD operations for the **OrgTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrgTeams
    * const orgTeams = await prisma.orgTeam.findMany()
    * ```
    */
  get orgTeam(): Prisma.OrgTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planGame`: Exposes CRUD operations for the **PlanGame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanGames
    * const planGames = await prisma.planGame.findMany()
    * ```
    */
  get planGame(): Prisma.PlanGameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planMeeting`: Exposes CRUD operations for the **PlanMeeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanMeetings
    * const planMeetings = await prisma.planMeeting.findMany()
    * ```
    */
  get planMeeting(): Prisma.PlanMeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planTraining`: Exposes CRUD operations for the **PlanTraining** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanTrainings
    * const planTrainings = await prisma.planTraining.findMany()
    * ```
    */
  get planTraining(): Prisma.PlanTrainingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relClubClubAdmin`: Exposes CRUD operations for the **RelClubClubAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelClubClubAdmins
    * const relClubClubAdmins = await prisma.relClubClubAdmin.findMany()
    * ```
    */
  get relClubClubAdmin(): Prisma.RelClubClubAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relCompetitionGroupLevel`: Exposes CRUD operations for the **RelCompetitionGroupLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelCompetitionGroupLevels
    * const relCompetitionGroupLevels = await prisma.relCompetitionGroupLevel.findMany()
    * ```
    */
  get relCompetitionGroupLevel(): Prisma.RelCompetitionGroupLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relFieldSport`: Exposes CRUD operations for the **RelFieldSport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelFieldSports
    * const relFieldSports = await prisma.relFieldSport.findMany()
    * ```
    */
  get relFieldSport(): Prisma.RelFieldSportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relMatchReferee`: Exposes CRUD operations for the **RelMatchReferee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelMatchReferees
    * const relMatchReferees = await prisma.relMatchReferee.findMany()
    * ```
    */
  get relMatchReferee(): Prisma.RelMatchRefereeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relPlayerParent`: Exposes CRUD operations for the **RelPlayerParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelPlayerParents
    * const relPlayerParents = await prisma.relPlayerParent.findMany()
    * ```
    */
  get relPlayerParent(): Prisma.RelPlayerParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relSponsorClub`: Exposes CRUD operations for the **RelSponsorClub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelSponsorClubs
    * const relSponsorClubs = await prisma.relSponsorClub.findMany()
    * ```
    */
  get relSponsorClub(): Prisma.RelSponsorClubDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relSponsorLeague`: Exposes CRUD operations for the **RelSponsorLeague** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelSponsorLeagues
    * const relSponsorLeagues = await prisma.relSponsorLeague.findMany()
    * ```
    */
  get relSponsorLeague(): Prisma.RelSponsorLeagueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relSponsorTeam`: Exposes CRUD operations for the **RelSponsorTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelSponsorTeams
    * const relSponsorTeams = await prisma.relSponsorTeam.findMany()
    * ```
    */
  get relSponsorTeam(): Prisma.RelSponsorTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relTeamCoach`: Exposes CRUD operations for the **RelTeamCoach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelTeamCoaches
    * const relTeamCoaches = await prisma.relTeamCoach.findMany()
    * ```
    */
  get relTeamCoach(): Prisma.RelTeamCoachDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relTeamPlayer`: Exposes CRUD operations for the **RelTeamPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelTeamPlayers
    * const relTeamPlayers = await prisma.relTeamPlayer.findMany()
    * ```
    */
  get relTeamPlayer(): Prisma.RelTeamPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relTeamTeamManager`: Exposes CRUD operations for the **RelTeamTeamManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelTeamTeamManagers
    * const relTeamTeamManagers = await prisma.relTeamTeamManager.findMany()
    * ```
    */
  get relTeamTeamManager(): Prisma.RelTeamTeamManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sportCoachType`: Exposes CRUD operations for the **SportCoachType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SportCoachTypes
    * const sportCoachTypes = await prisma.sportCoachType.findMany()
    * ```
    */
  get sportCoachType(): Prisma.SportCoachTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sportEventType`: Exposes CRUD operations for the **SportEventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SportEventTypes
    * const sportEventTypes = await prisma.sportEventType.findMany()
    * ```
    */
  get sportEventType(): Prisma.SportEventTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sportGamePeriod`: Exposes CRUD operations for the **SportGamePeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SportGamePeriods
    * const sportGamePeriods = await prisma.sportGamePeriod.findMany()
    * ```
    */
  get sportGamePeriod(): Prisma.SportGamePeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sportManagerType`: Exposes CRUD operations for the **SportManagerType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SportManagerTypes
    * const sportManagerTypes = await prisma.sportManagerType.findMany()
    * ```
    */
  get sportManagerType(): Prisma.SportManagerTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sportPlayerPosition`: Exposes CRUD operations for the **SportPlayerPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SportPlayerPositions
    * const sportPlayerPositions = await prisma.sportPlayerPosition.findMany()
    * ```
    */
  get sportPlayerPosition(): Prisma.SportPlayerPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sportRefereeType`: Exposes CRUD operations for the **SportRefereeType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SportRefereeTypes
    * const sportRefereeTypes = await prisma.sportRefereeType.findMany()
    * ```
    */
  get sportRefereeType(): Prisma.SportRefereeTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subFeature`: Exposes CRUD operations for the **SubFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubFeatures
    * const subFeatures = await prisma.subFeature.findMany()
    * ```
    */
  get subFeature(): Prisma.SubFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subForTeam`: Exposes CRUD operations for the **SubForTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubForTeams
    * const subForTeams = await prisma.subForTeam.findMany()
    * ```
    */
  get subForTeam(): Prisma.SubForTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subForUser`: Exposes CRUD operations for the **SubForUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubForUsers
    * const subForUsers = await prisma.subForUser.findMany()
    * ```
    */
  get subForUser(): Prisma.SubForUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subPlan`: Exposes CRUD operations for the **SubPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubPlans
    * const subPlans = await prisma.subPlan.findMany()
    * ```
    */
  get subPlan(): Prisma.SubPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subPlanFeature`: Exposes CRUD operations for the **SubPlanFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubPlanFeatures
    * const subPlanFeatures = await prisma.subPlanFeature.findMany()
    * ```
    */
  get subPlanFeature(): Prisma.SubPlanFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sysUser`: Exposes CRUD operations for the **SysUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SysUsers
    * const sysUsers = await prisma.sysUser.findMany()
    * ```
    */
  get sysUser(): Prisma.SysUserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BaseCompetition: 'BaseCompetition',
    BaseCountry: 'BaseCountry',
    BaseField: 'BaseField',
    BaseGroupLevel: 'BaseGroupLevel',
    BaseSport: 'BaseSport',
    GameEvent: 'GameEvent',
    GameMatche: 'GameMatche',
    MatchEvent: 'MatchEvent',
    MatchLineup: 'MatchLineup',
    MatchMedia: 'MatchMedia',
    MatchRoster: 'MatchRoster',
    MatchStatistic: 'MatchStatistic',
    MemberClubAdmin: 'MemberClubAdmin',
    MemberCoache: 'MemberCoache',
    MemberParent: 'MemberParent',
    MemberPerson: 'MemberPerson',
    MemberPlayer: 'MemberPlayer',
    MemberReferee: 'MemberReferee',
    MemberSponsor: 'MemberSponsor',
    MemberTeamManager: 'MemberTeamManager',
    OrgClub: 'OrgClub',
    OrgLeague: 'OrgLeague',
    OrgTeam: 'OrgTeam',
    PlanGame: 'PlanGame',
    PlanMeeting: 'PlanMeeting',
    PlanTraining: 'PlanTraining',
    RelClubClubAdmin: 'RelClubClubAdmin',
    RelCompetitionGroupLevel: 'RelCompetitionGroupLevel',
    RelFieldSport: 'RelFieldSport',
    RelMatchReferee: 'RelMatchReferee',
    RelPlayerParent: 'RelPlayerParent',
    RelSponsorClub: 'RelSponsorClub',
    RelSponsorLeague: 'RelSponsorLeague',
    RelSponsorTeam: 'RelSponsorTeam',
    RelTeamCoach: 'RelTeamCoach',
    RelTeamPlayer: 'RelTeamPlayer',
    RelTeamTeamManager: 'RelTeamTeamManager',
    SportCoachType: 'SportCoachType',
    SportEventType: 'SportEventType',
    SportGamePeriod: 'SportGamePeriod',
    SportManagerType: 'SportManagerType',
    SportPlayerPosition: 'SportPlayerPosition',
    SportRefereeType: 'SportRefereeType',
    SubFeature: 'SubFeature',
    SubForTeam: 'SubForTeam',
    SubForUser: 'SubForUser',
    SubPlan: 'SubPlan',
    SubPlanFeature: 'SubPlanFeature',
    SysUser: 'SysUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "baseCompetition" | "baseCountry" | "baseField" | "baseGroupLevel" | "baseSport" | "gameEvent" | "gameMatche" | "matchEvent" | "matchLineup" | "matchMedia" | "matchRoster" | "matchStatistic" | "memberClubAdmin" | "memberCoache" | "memberParent" | "memberPerson" | "memberPlayer" | "memberReferee" | "memberSponsor" | "memberTeamManager" | "orgClub" | "orgLeague" | "orgTeam" | "planGame" | "planMeeting" | "planTraining" | "relClubClubAdmin" | "relCompetitionGroupLevel" | "relFieldSport" | "relMatchReferee" | "relPlayerParent" | "relSponsorClub" | "relSponsorLeague" | "relSponsorTeam" | "relTeamCoach" | "relTeamPlayer" | "relTeamTeamManager" | "sportCoachType" | "sportEventType" | "sportGamePeriod" | "sportManagerType" | "sportPlayerPosition" | "sportRefereeType" | "subFeature" | "subForTeam" | "subForUser" | "subPlan" | "subPlanFeature" | "sysUser"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BaseCompetition: {
        payload: Prisma.$BaseCompetitionPayload<ExtArgs>
        fields: Prisma.BaseCompetitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaseCompetitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaseCompetitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>
          }
          findFirst: {
            args: Prisma.BaseCompetitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaseCompetitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>
          }
          findMany: {
            args: Prisma.BaseCompetitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>[]
          }
          create: {
            args: Prisma.BaseCompetitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>
          }
          createMany: {
            args: Prisma.BaseCompetitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BaseCompetitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>[]
          }
          delete: {
            args: Prisma.BaseCompetitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>
          }
          update: {
            args: Prisma.BaseCompetitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>
          }
          deleteMany: {
            args: Prisma.BaseCompetitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaseCompetitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BaseCompetitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>[]
          }
          upsert: {
            args: Prisma.BaseCompetitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCompetitionPayload>
          }
          aggregate: {
            args: Prisma.BaseCompetitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaseCompetition>
          }
          groupBy: {
            args: Prisma.BaseCompetitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaseCompetitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaseCompetitionCountArgs<ExtArgs>
            result: $Utils.Optional<BaseCompetitionCountAggregateOutputType> | number
          }
        }
      }
      BaseCountry: {
        payload: Prisma.$BaseCountryPayload<ExtArgs>
        fields: Prisma.BaseCountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaseCountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaseCountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>
          }
          findFirst: {
            args: Prisma.BaseCountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaseCountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>
          }
          findMany: {
            args: Prisma.BaseCountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>[]
          }
          create: {
            args: Prisma.BaseCountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>
          }
          createMany: {
            args: Prisma.BaseCountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BaseCountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>[]
          }
          delete: {
            args: Prisma.BaseCountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>
          }
          update: {
            args: Prisma.BaseCountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>
          }
          deleteMany: {
            args: Prisma.BaseCountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaseCountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BaseCountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>[]
          }
          upsert: {
            args: Prisma.BaseCountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseCountryPayload>
          }
          aggregate: {
            args: Prisma.BaseCountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaseCountry>
          }
          groupBy: {
            args: Prisma.BaseCountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaseCountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaseCountryCountArgs<ExtArgs>
            result: $Utils.Optional<BaseCountryCountAggregateOutputType> | number
          }
        }
      }
      BaseField: {
        payload: Prisma.$BaseFieldPayload<ExtArgs>
        fields: Prisma.BaseFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaseFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaseFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>
          }
          findFirst: {
            args: Prisma.BaseFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaseFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>
          }
          findMany: {
            args: Prisma.BaseFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>[]
          }
          create: {
            args: Prisma.BaseFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>
          }
          createMany: {
            args: Prisma.BaseFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BaseFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>[]
          }
          delete: {
            args: Prisma.BaseFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>
          }
          update: {
            args: Prisma.BaseFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>
          }
          deleteMany: {
            args: Prisma.BaseFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaseFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BaseFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>[]
          }
          upsert: {
            args: Prisma.BaseFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseFieldPayload>
          }
          aggregate: {
            args: Prisma.BaseFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaseField>
          }
          groupBy: {
            args: Prisma.BaseFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaseFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaseFieldCountArgs<ExtArgs>
            result: $Utils.Optional<BaseFieldCountAggregateOutputType> | number
          }
        }
      }
      BaseGroupLevel: {
        payload: Prisma.$BaseGroupLevelPayload<ExtArgs>
        fields: Prisma.BaseGroupLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaseGroupLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaseGroupLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>
          }
          findFirst: {
            args: Prisma.BaseGroupLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaseGroupLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>
          }
          findMany: {
            args: Prisma.BaseGroupLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>[]
          }
          create: {
            args: Prisma.BaseGroupLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>
          }
          createMany: {
            args: Prisma.BaseGroupLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BaseGroupLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>[]
          }
          delete: {
            args: Prisma.BaseGroupLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>
          }
          update: {
            args: Prisma.BaseGroupLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>
          }
          deleteMany: {
            args: Prisma.BaseGroupLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaseGroupLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BaseGroupLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>[]
          }
          upsert: {
            args: Prisma.BaseGroupLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseGroupLevelPayload>
          }
          aggregate: {
            args: Prisma.BaseGroupLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaseGroupLevel>
          }
          groupBy: {
            args: Prisma.BaseGroupLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaseGroupLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaseGroupLevelCountArgs<ExtArgs>
            result: $Utils.Optional<BaseGroupLevelCountAggregateOutputType> | number
          }
        }
      }
      BaseSport: {
        payload: Prisma.$BaseSportPayload<ExtArgs>
        fields: Prisma.BaseSportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaseSportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaseSportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>
          }
          findFirst: {
            args: Prisma.BaseSportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaseSportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>
          }
          findMany: {
            args: Prisma.BaseSportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>[]
          }
          create: {
            args: Prisma.BaseSportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>
          }
          createMany: {
            args: Prisma.BaseSportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BaseSportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>[]
          }
          delete: {
            args: Prisma.BaseSportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>
          }
          update: {
            args: Prisma.BaseSportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>
          }
          deleteMany: {
            args: Prisma.BaseSportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaseSportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BaseSportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>[]
          }
          upsert: {
            args: Prisma.BaseSportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaseSportPayload>
          }
          aggregate: {
            args: Prisma.BaseSportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaseSport>
          }
          groupBy: {
            args: Prisma.BaseSportGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaseSportGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaseSportCountArgs<ExtArgs>
            result: $Utils.Optional<BaseSportCountAggregateOutputType> | number
          }
        }
      }
      GameEvent: {
        payload: Prisma.$GameEventPayload<ExtArgs>
        fields: Prisma.GameEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findFirst: {
            args: Prisma.GameEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          findMany: {
            args: Prisma.GameEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          create: {
            args: Prisma.GameEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          createMany: {
            args: Prisma.GameEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          delete: {
            args: Prisma.GameEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          update: {
            args: Prisma.GameEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          deleteMany: {
            args: Prisma.GameEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>[]
          }
          upsert: {
            args: Prisma.GameEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameEventPayload>
          }
          aggregate: {
            args: Prisma.GameEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameEvent>
          }
          groupBy: {
            args: Prisma.GameEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameEventCountArgs<ExtArgs>
            result: $Utils.Optional<GameEventCountAggregateOutputType> | number
          }
        }
      }
      GameMatche: {
        payload: Prisma.$GameMatchePayload<ExtArgs>
        fields: Prisma.GameMatcheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameMatcheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameMatcheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>
          }
          findFirst: {
            args: Prisma.GameMatcheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameMatcheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>
          }
          findMany: {
            args: Prisma.GameMatcheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>[]
          }
          create: {
            args: Prisma.GameMatcheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>
          }
          createMany: {
            args: Prisma.GameMatcheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameMatcheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>[]
          }
          delete: {
            args: Prisma.GameMatcheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>
          }
          update: {
            args: Prisma.GameMatcheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>
          }
          deleteMany: {
            args: Prisma.GameMatcheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameMatcheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameMatcheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>[]
          }
          upsert: {
            args: Prisma.GameMatcheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameMatchePayload>
          }
          aggregate: {
            args: Prisma.GameMatcheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameMatche>
          }
          groupBy: {
            args: Prisma.GameMatcheGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameMatcheGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameMatcheCountArgs<ExtArgs>
            result: $Utils.Optional<GameMatcheCountAggregateOutputType> | number
          }
        }
      }
      MatchEvent: {
        payload: Prisma.$MatchEventPayload<ExtArgs>
        fields: Prisma.MatchEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          findFirst: {
            args: Prisma.MatchEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          findMany: {
            args: Prisma.MatchEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>[]
          }
          create: {
            args: Prisma.MatchEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          createMany: {
            args: Prisma.MatchEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>[]
          }
          delete: {
            args: Prisma.MatchEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          update: {
            args: Prisma.MatchEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          deleteMany: {
            args: Prisma.MatchEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>[]
          }
          upsert: {
            args: Prisma.MatchEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          aggregate: {
            args: Prisma.MatchEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchEvent>
          }
          groupBy: {
            args: Prisma.MatchEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchEventCountArgs<ExtArgs>
            result: $Utils.Optional<MatchEventCountAggregateOutputType> | number
          }
        }
      }
      MatchLineup: {
        payload: Prisma.$MatchLineupPayload<ExtArgs>
        fields: Prisma.MatchLineupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchLineupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchLineupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>
          }
          findFirst: {
            args: Prisma.MatchLineupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchLineupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>
          }
          findMany: {
            args: Prisma.MatchLineupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>[]
          }
          create: {
            args: Prisma.MatchLineupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>
          }
          createMany: {
            args: Prisma.MatchLineupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchLineupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>[]
          }
          delete: {
            args: Prisma.MatchLineupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>
          }
          update: {
            args: Prisma.MatchLineupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>
          }
          deleteMany: {
            args: Prisma.MatchLineupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchLineupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchLineupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>[]
          }
          upsert: {
            args: Prisma.MatchLineupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchLineupPayload>
          }
          aggregate: {
            args: Prisma.MatchLineupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchLineup>
          }
          groupBy: {
            args: Prisma.MatchLineupGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchLineupGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchLineupCountArgs<ExtArgs>
            result: $Utils.Optional<MatchLineupCountAggregateOutputType> | number
          }
        }
      }
      MatchMedia: {
        payload: Prisma.$MatchMediaPayload<ExtArgs>
        fields: Prisma.MatchMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>
          }
          findFirst: {
            args: Prisma.MatchMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>
          }
          findMany: {
            args: Prisma.MatchMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>[]
          }
          create: {
            args: Prisma.MatchMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>
          }
          createMany: {
            args: Prisma.MatchMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>[]
          }
          delete: {
            args: Prisma.MatchMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>
          }
          update: {
            args: Prisma.MatchMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>
          }
          deleteMany: {
            args: Prisma.MatchMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>[]
          }
          upsert: {
            args: Prisma.MatchMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMediaPayload>
          }
          aggregate: {
            args: Prisma.MatchMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchMedia>
          }
          groupBy: {
            args: Prisma.MatchMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchMediaCountArgs<ExtArgs>
            result: $Utils.Optional<MatchMediaCountAggregateOutputType> | number
          }
        }
      }
      MatchRoster: {
        payload: Prisma.$MatchRosterPayload<ExtArgs>
        fields: Prisma.MatchRosterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchRosterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchRosterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>
          }
          findFirst: {
            args: Prisma.MatchRosterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchRosterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>
          }
          findMany: {
            args: Prisma.MatchRosterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>[]
          }
          create: {
            args: Prisma.MatchRosterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>
          }
          createMany: {
            args: Prisma.MatchRosterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchRosterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>[]
          }
          delete: {
            args: Prisma.MatchRosterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>
          }
          update: {
            args: Prisma.MatchRosterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>
          }
          deleteMany: {
            args: Prisma.MatchRosterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchRosterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchRosterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>[]
          }
          upsert: {
            args: Prisma.MatchRosterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRosterPayload>
          }
          aggregate: {
            args: Prisma.MatchRosterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchRoster>
          }
          groupBy: {
            args: Prisma.MatchRosterGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchRosterGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchRosterCountArgs<ExtArgs>
            result: $Utils.Optional<MatchRosterCountAggregateOutputType> | number
          }
        }
      }
      MatchStatistic: {
        payload: Prisma.$MatchStatisticPayload<ExtArgs>
        fields: Prisma.MatchStatisticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchStatisticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchStatisticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>
          }
          findFirst: {
            args: Prisma.MatchStatisticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchStatisticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>
          }
          findMany: {
            args: Prisma.MatchStatisticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>[]
          }
          create: {
            args: Prisma.MatchStatisticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>
          }
          createMany: {
            args: Prisma.MatchStatisticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchStatisticCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>[]
          }
          delete: {
            args: Prisma.MatchStatisticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>
          }
          update: {
            args: Prisma.MatchStatisticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>
          }
          deleteMany: {
            args: Prisma.MatchStatisticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchStatisticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchStatisticUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>[]
          }
          upsert: {
            args: Prisma.MatchStatisticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchStatisticPayload>
          }
          aggregate: {
            args: Prisma.MatchStatisticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchStatistic>
          }
          groupBy: {
            args: Prisma.MatchStatisticGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchStatisticGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchStatisticCountArgs<ExtArgs>
            result: $Utils.Optional<MatchStatisticCountAggregateOutputType> | number
          }
        }
      }
      MemberClubAdmin: {
        payload: Prisma.$MemberClubAdminPayload<ExtArgs>
        fields: Prisma.MemberClubAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberClubAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberClubAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>
          }
          findFirst: {
            args: Prisma.MemberClubAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberClubAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>
          }
          findMany: {
            args: Prisma.MemberClubAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>[]
          }
          create: {
            args: Prisma.MemberClubAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>
          }
          createMany: {
            args: Prisma.MemberClubAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberClubAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>[]
          }
          delete: {
            args: Prisma.MemberClubAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>
          }
          update: {
            args: Prisma.MemberClubAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>
          }
          deleteMany: {
            args: Prisma.MemberClubAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberClubAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberClubAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>[]
          }
          upsert: {
            args: Prisma.MemberClubAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberClubAdminPayload>
          }
          aggregate: {
            args: Prisma.MemberClubAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberClubAdmin>
          }
          groupBy: {
            args: Prisma.MemberClubAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberClubAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberClubAdminCountArgs<ExtArgs>
            result: $Utils.Optional<MemberClubAdminCountAggregateOutputType> | number
          }
        }
      }
      MemberCoache: {
        payload: Prisma.$MemberCoachePayload<ExtArgs>
        fields: Prisma.MemberCoacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberCoacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberCoacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>
          }
          findFirst: {
            args: Prisma.MemberCoacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberCoacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>
          }
          findMany: {
            args: Prisma.MemberCoacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>[]
          }
          create: {
            args: Prisma.MemberCoacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>
          }
          createMany: {
            args: Prisma.MemberCoacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCoacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>[]
          }
          delete: {
            args: Prisma.MemberCoacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>
          }
          update: {
            args: Prisma.MemberCoacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>
          }
          deleteMany: {
            args: Prisma.MemberCoacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberCoacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberCoacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>[]
          }
          upsert: {
            args: Prisma.MemberCoacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberCoachePayload>
          }
          aggregate: {
            args: Prisma.MemberCoacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberCoache>
          }
          groupBy: {
            args: Prisma.MemberCoacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberCoacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCoacheCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCoacheCountAggregateOutputType> | number
          }
        }
      }
      MemberParent: {
        payload: Prisma.$MemberParentPayload<ExtArgs>
        fields: Prisma.MemberParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>
          }
          findFirst: {
            args: Prisma.MemberParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>
          }
          findMany: {
            args: Prisma.MemberParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>[]
          }
          create: {
            args: Prisma.MemberParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>
          }
          createMany: {
            args: Prisma.MemberParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>[]
          }
          delete: {
            args: Prisma.MemberParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>
          }
          update: {
            args: Prisma.MemberParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>
          }
          deleteMany: {
            args: Prisma.MemberParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>[]
          }
          upsert: {
            args: Prisma.MemberParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberParentPayload>
          }
          aggregate: {
            args: Prisma.MemberParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberParent>
          }
          groupBy: {
            args: Prisma.MemberParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberParentCountArgs<ExtArgs>
            result: $Utils.Optional<MemberParentCountAggregateOutputType> | number
          }
        }
      }
      MemberPerson: {
        payload: Prisma.$MemberPersonPayload<ExtArgs>
        fields: Prisma.MemberPersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberPersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberPersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>
          }
          findFirst: {
            args: Prisma.MemberPersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberPersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>
          }
          findMany: {
            args: Prisma.MemberPersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>[]
          }
          create: {
            args: Prisma.MemberPersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>
          }
          createMany: {
            args: Prisma.MemberPersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberPersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>[]
          }
          delete: {
            args: Prisma.MemberPersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>
          }
          update: {
            args: Prisma.MemberPersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>
          }
          deleteMany: {
            args: Prisma.MemberPersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberPersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberPersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>[]
          }
          upsert: {
            args: Prisma.MemberPersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPersonPayload>
          }
          aggregate: {
            args: Prisma.MemberPersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberPerson>
          }
          groupBy: {
            args: Prisma.MemberPersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberPersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberPersonCountArgs<ExtArgs>
            result: $Utils.Optional<MemberPersonCountAggregateOutputType> | number
          }
        }
      }
      MemberPlayer: {
        payload: Prisma.$MemberPlayerPayload<ExtArgs>
        fields: Prisma.MemberPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>
          }
          findFirst: {
            args: Prisma.MemberPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>
          }
          findMany: {
            args: Prisma.MemberPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>[]
          }
          create: {
            args: Prisma.MemberPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>
          }
          createMany: {
            args: Prisma.MemberPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>[]
          }
          delete: {
            args: Prisma.MemberPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>
          }
          update: {
            args: Prisma.MemberPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>
          }
          deleteMany: {
            args: Prisma.MemberPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>[]
          }
          upsert: {
            args: Prisma.MemberPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPlayerPayload>
          }
          aggregate: {
            args: Prisma.MemberPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberPlayer>
          }
          groupBy: {
            args: Prisma.MemberPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<MemberPlayerCountAggregateOutputType> | number
          }
        }
      }
      MemberReferee: {
        payload: Prisma.$MemberRefereePayload<ExtArgs>
        fields: Prisma.MemberRefereeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberRefereeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberRefereeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>
          }
          findFirst: {
            args: Prisma.MemberRefereeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberRefereeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>
          }
          findMany: {
            args: Prisma.MemberRefereeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>[]
          }
          create: {
            args: Prisma.MemberRefereeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>
          }
          createMany: {
            args: Prisma.MemberRefereeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberRefereeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>[]
          }
          delete: {
            args: Prisma.MemberRefereeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>
          }
          update: {
            args: Prisma.MemberRefereeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>
          }
          deleteMany: {
            args: Prisma.MemberRefereeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberRefereeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberRefereeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>[]
          }
          upsert: {
            args: Prisma.MemberRefereeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberRefereePayload>
          }
          aggregate: {
            args: Prisma.MemberRefereeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberReferee>
          }
          groupBy: {
            args: Prisma.MemberRefereeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberRefereeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberRefereeCountArgs<ExtArgs>
            result: $Utils.Optional<MemberRefereeCountAggregateOutputType> | number
          }
        }
      }
      MemberSponsor: {
        payload: Prisma.$MemberSponsorPayload<ExtArgs>
        fields: Prisma.MemberSponsorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberSponsorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberSponsorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>
          }
          findFirst: {
            args: Prisma.MemberSponsorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberSponsorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>
          }
          findMany: {
            args: Prisma.MemberSponsorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>[]
          }
          create: {
            args: Prisma.MemberSponsorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>
          }
          createMany: {
            args: Prisma.MemberSponsorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberSponsorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>[]
          }
          delete: {
            args: Prisma.MemberSponsorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>
          }
          update: {
            args: Prisma.MemberSponsorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>
          }
          deleteMany: {
            args: Prisma.MemberSponsorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberSponsorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberSponsorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>[]
          }
          upsert: {
            args: Prisma.MemberSponsorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberSponsorPayload>
          }
          aggregate: {
            args: Prisma.MemberSponsorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberSponsor>
          }
          groupBy: {
            args: Prisma.MemberSponsorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberSponsorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberSponsorCountArgs<ExtArgs>
            result: $Utils.Optional<MemberSponsorCountAggregateOutputType> | number
          }
        }
      }
      MemberTeamManager: {
        payload: Prisma.$MemberTeamManagerPayload<ExtArgs>
        fields: Prisma.MemberTeamManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberTeamManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberTeamManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>
          }
          findFirst: {
            args: Prisma.MemberTeamManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberTeamManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>
          }
          findMany: {
            args: Prisma.MemberTeamManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>[]
          }
          create: {
            args: Prisma.MemberTeamManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>
          }
          createMany: {
            args: Prisma.MemberTeamManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberTeamManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>[]
          }
          delete: {
            args: Prisma.MemberTeamManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>
          }
          update: {
            args: Prisma.MemberTeamManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>
          }
          deleteMany: {
            args: Prisma.MemberTeamManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberTeamManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberTeamManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>[]
          }
          upsert: {
            args: Prisma.MemberTeamManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberTeamManagerPayload>
          }
          aggregate: {
            args: Prisma.MemberTeamManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberTeamManager>
          }
          groupBy: {
            args: Prisma.MemberTeamManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberTeamManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberTeamManagerCountArgs<ExtArgs>
            result: $Utils.Optional<MemberTeamManagerCountAggregateOutputType> | number
          }
        }
      }
      OrgClub: {
        payload: Prisma.$OrgClubPayload<ExtArgs>
        fields: Prisma.OrgClubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgClubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgClubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>
          }
          findFirst: {
            args: Prisma.OrgClubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgClubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>
          }
          findMany: {
            args: Prisma.OrgClubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>[]
          }
          create: {
            args: Prisma.OrgClubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>
          }
          createMany: {
            args: Prisma.OrgClubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgClubCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>[]
          }
          delete: {
            args: Prisma.OrgClubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>
          }
          update: {
            args: Prisma.OrgClubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>
          }
          deleteMany: {
            args: Prisma.OrgClubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgClubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrgClubUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>[]
          }
          upsert: {
            args: Prisma.OrgClubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgClubPayload>
          }
          aggregate: {
            args: Prisma.OrgClubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrgClub>
          }
          groupBy: {
            args: Prisma.OrgClubGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgClubGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgClubCountArgs<ExtArgs>
            result: $Utils.Optional<OrgClubCountAggregateOutputType> | number
          }
        }
      }
      OrgLeague: {
        payload: Prisma.$OrgLeaguePayload<ExtArgs>
        fields: Prisma.OrgLeagueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgLeagueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgLeagueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>
          }
          findFirst: {
            args: Prisma.OrgLeagueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgLeagueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>
          }
          findMany: {
            args: Prisma.OrgLeagueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>[]
          }
          create: {
            args: Prisma.OrgLeagueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>
          }
          createMany: {
            args: Prisma.OrgLeagueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgLeagueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>[]
          }
          delete: {
            args: Prisma.OrgLeagueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>
          }
          update: {
            args: Prisma.OrgLeagueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>
          }
          deleteMany: {
            args: Prisma.OrgLeagueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgLeagueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrgLeagueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>[]
          }
          upsert: {
            args: Prisma.OrgLeagueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgLeaguePayload>
          }
          aggregate: {
            args: Prisma.OrgLeagueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrgLeague>
          }
          groupBy: {
            args: Prisma.OrgLeagueGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgLeagueGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgLeagueCountArgs<ExtArgs>
            result: $Utils.Optional<OrgLeagueCountAggregateOutputType> | number
          }
        }
      }
      OrgTeam: {
        payload: Prisma.$OrgTeamPayload<ExtArgs>
        fields: Prisma.OrgTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrgTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrgTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>
          }
          findFirst: {
            args: Prisma.OrgTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrgTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>
          }
          findMany: {
            args: Prisma.OrgTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>[]
          }
          create: {
            args: Prisma.OrgTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>
          }
          createMany: {
            args: Prisma.OrgTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrgTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>[]
          }
          delete: {
            args: Prisma.OrgTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>
          }
          update: {
            args: Prisma.OrgTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>
          }
          deleteMany: {
            args: Prisma.OrgTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrgTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrgTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>[]
          }
          upsert: {
            args: Prisma.OrgTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrgTeamPayload>
          }
          aggregate: {
            args: Prisma.OrgTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrgTeam>
          }
          groupBy: {
            args: Prisma.OrgTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrgTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrgTeamCountArgs<ExtArgs>
            result: $Utils.Optional<OrgTeamCountAggregateOutputType> | number
          }
        }
      }
      PlanGame: {
        payload: Prisma.$PlanGamePayload<ExtArgs>
        fields: Prisma.PlanGameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanGameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanGameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>
          }
          findFirst: {
            args: Prisma.PlanGameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanGameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>
          }
          findMany: {
            args: Prisma.PlanGameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>[]
          }
          create: {
            args: Prisma.PlanGameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>
          }
          createMany: {
            args: Prisma.PlanGameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanGameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>[]
          }
          delete: {
            args: Prisma.PlanGameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>
          }
          update: {
            args: Prisma.PlanGameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>
          }
          deleteMany: {
            args: Prisma.PlanGameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanGameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanGameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>[]
          }
          upsert: {
            args: Prisma.PlanGameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanGamePayload>
          }
          aggregate: {
            args: Prisma.PlanGameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanGame>
          }
          groupBy: {
            args: Prisma.PlanGameGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGameGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanGameCountArgs<ExtArgs>
            result: $Utils.Optional<PlanGameCountAggregateOutputType> | number
          }
        }
      }
      PlanMeeting: {
        payload: Prisma.$PlanMeetingPayload<ExtArgs>
        fields: Prisma.PlanMeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanMeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanMeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>
          }
          findFirst: {
            args: Prisma.PlanMeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanMeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>
          }
          findMany: {
            args: Prisma.PlanMeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>[]
          }
          create: {
            args: Prisma.PlanMeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>
          }
          createMany: {
            args: Prisma.PlanMeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanMeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>[]
          }
          delete: {
            args: Prisma.PlanMeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>
          }
          update: {
            args: Prisma.PlanMeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>
          }
          deleteMany: {
            args: Prisma.PlanMeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanMeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanMeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>[]
          }
          upsert: {
            args: Prisma.PlanMeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanMeetingPayload>
          }
          aggregate: {
            args: Prisma.PlanMeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanMeeting>
          }
          groupBy: {
            args: Prisma.PlanMeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanMeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanMeetingCountArgs<ExtArgs>
            result: $Utils.Optional<PlanMeetingCountAggregateOutputType> | number
          }
        }
      }
      PlanTraining: {
        payload: Prisma.$PlanTrainingPayload<ExtArgs>
        fields: Prisma.PlanTrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanTrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanTrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>
          }
          findFirst: {
            args: Prisma.PlanTrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanTrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>
          }
          findMany: {
            args: Prisma.PlanTrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>[]
          }
          create: {
            args: Prisma.PlanTrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>
          }
          createMany: {
            args: Prisma.PlanTrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanTrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>[]
          }
          delete: {
            args: Prisma.PlanTrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>
          }
          update: {
            args: Prisma.PlanTrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>
          }
          deleteMany: {
            args: Prisma.PlanTrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanTrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanTrainingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>[]
          }
          upsert: {
            args: Prisma.PlanTrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanTrainingPayload>
          }
          aggregate: {
            args: Prisma.PlanTrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanTraining>
          }
          groupBy: {
            args: Prisma.PlanTrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanTrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanTrainingCountArgs<ExtArgs>
            result: $Utils.Optional<PlanTrainingCountAggregateOutputType> | number
          }
        }
      }
      RelClubClubAdmin: {
        payload: Prisma.$RelClubClubAdminPayload<ExtArgs>
        fields: Prisma.RelClubClubAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelClubClubAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelClubClubAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>
          }
          findFirst: {
            args: Prisma.RelClubClubAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelClubClubAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>
          }
          findMany: {
            args: Prisma.RelClubClubAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>[]
          }
          create: {
            args: Prisma.RelClubClubAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>
          }
          createMany: {
            args: Prisma.RelClubClubAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelClubClubAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>[]
          }
          delete: {
            args: Prisma.RelClubClubAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>
          }
          update: {
            args: Prisma.RelClubClubAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>
          }
          deleteMany: {
            args: Prisma.RelClubClubAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelClubClubAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelClubClubAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>[]
          }
          upsert: {
            args: Prisma.RelClubClubAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelClubClubAdminPayload>
          }
          aggregate: {
            args: Prisma.RelClubClubAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelClubClubAdmin>
          }
          groupBy: {
            args: Prisma.RelClubClubAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelClubClubAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelClubClubAdminCountArgs<ExtArgs>
            result: $Utils.Optional<RelClubClubAdminCountAggregateOutputType> | number
          }
        }
      }
      RelCompetitionGroupLevel: {
        payload: Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>
        fields: Prisma.RelCompetitionGroupLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelCompetitionGroupLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelCompetitionGroupLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>
          }
          findFirst: {
            args: Prisma.RelCompetitionGroupLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelCompetitionGroupLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>
          }
          findMany: {
            args: Prisma.RelCompetitionGroupLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>[]
          }
          create: {
            args: Prisma.RelCompetitionGroupLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>
          }
          createMany: {
            args: Prisma.RelCompetitionGroupLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelCompetitionGroupLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>[]
          }
          delete: {
            args: Prisma.RelCompetitionGroupLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>
          }
          update: {
            args: Prisma.RelCompetitionGroupLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>
          }
          deleteMany: {
            args: Prisma.RelCompetitionGroupLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelCompetitionGroupLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelCompetitionGroupLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>[]
          }
          upsert: {
            args: Prisma.RelCompetitionGroupLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelCompetitionGroupLevelPayload>
          }
          aggregate: {
            args: Prisma.RelCompetitionGroupLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelCompetitionGroupLevel>
          }
          groupBy: {
            args: Prisma.RelCompetitionGroupLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelCompetitionGroupLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelCompetitionGroupLevelCountArgs<ExtArgs>
            result: $Utils.Optional<RelCompetitionGroupLevelCountAggregateOutputType> | number
          }
        }
      }
      RelFieldSport: {
        payload: Prisma.$RelFieldSportPayload<ExtArgs>
        fields: Prisma.RelFieldSportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelFieldSportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelFieldSportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>
          }
          findFirst: {
            args: Prisma.RelFieldSportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelFieldSportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>
          }
          findMany: {
            args: Prisma.RelFieldSportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>[]
          }
          create: {
            args: Prisma.RelFieldSportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>
          }
          createMany: {
            args: Prisma.RelFieldSportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelFieldSportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>[]
          }
          delete: {
            args: Prisma.RelFieldSportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>
          }
          update: {
            args: Prisma.RelFieldSportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>
          }
          deleteMany: {
            args: Prisma.RelFieldSportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelFieldSportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelFieldSportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>[]
          }
          upsert: {
            args: Prisma.RelFieldSportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelFieldSportPayload>
          }
          aggregate: {
            args: Prisma.RelFieldSportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelFieldSport>
          }
          groupBy: {
            args: Prisma.RelFieldSportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelFieldSportGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelFieldSportCountArgs<ExtArgs>
            result: $Utils.Optional<RelFieldSportCountAggregateOutputType> | number
          }
        }
      }
      RelMatchReferee: {
        payload: Prisma.$RelMatchRefereePayload<ExtArgs>
        fields: Prisma.RelMatchRefereeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelMatchRefereeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelMatchRefereeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>
          }
          findFirst: {
            args: Prisma.RelMatchRefereeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelMatchRefereeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>
          }
          findMany: {
            args: Prisma.RelMatchRefereeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>[]
          }
          create: {
            args: Prisma.RelMatchRefereeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>
          }
          createMany: {
            args: Prisma.RelMatchRefereeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelMatchRefereeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>[]
          }
          delete: {
            args: Prisma.RelMatchRefereeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>
          }
          update: {
            args: Prisma.RelMatchRefereeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>
          }
          deleteMany: {
            args: Prisma.RelMatchRefereeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelMatchRefereeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelMatchRefereeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>[]
          }
          upsert: {
            args: Prisma.RelMatchRefereeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelMatchRefereePayload>
          }
          aggregate: {
            args: Prisma.RelMatchRefereeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelMatchReferee>
          }
          groupBy: {
            args: Prisma.RelMatchRefereeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelMatchRefereeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelMatchRefereeCountArgs<ExtArgs>
            result: $Utils.Optional<RelMatchRefereeCountAggregateOutputType> | number
          }
        }
      }
      RelPlayerParent: {
        payload: Prisma.$RelPlayerParentPayload<ExtArgs>
        fields: Prisma.RelPlayerParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelPlayerParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelPlayerParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>
          }
          findFirst: {
            args: Prisma.RelPlayerParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelPlayerParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>
          }
          findMany: {
            args: Prisma.RelPlayerParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>[]
          }
          create: {
            args: Prisma.RelPlayerParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>
          }
          createMany: {
            args: Prisma.RelPlayerParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelPlayerParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>[]
          }
          delete: {
            args: Prisma.RelPlayerParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>
          }
          update: {
            args: Prisma.RelPlayerParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>
          }
          deleteMany: {
            args: Prisma.RelPlayerParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelPlayerParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelPlayerParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>[]
          }
          upsert: {
            args: Prisma.RelPlayerParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelPlayerParentPayload>
          }
          aggregate: {
            args: Prisma.RelPlayerParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelPlayerParent>
          }
          groupBy: {
            args: Prisma.RelPlayerParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelPlayerParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelPlayerParentCountArgs<ExtArgs>
            result: $Utils.Optional<RelPlayerParentCountAggregateOutputType> | number
          }
        }
      }
      RelSponsorClub: {
        payload: Prisma.$RelSponsorClubPayload<ExtArgs>
        fields: Prisma.RelSponsorClubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelSponsorClubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelSponsorClubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>
          }
          findFirst: {
            args: Prisma.RelSponsorClubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelSponsorClubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>
          }
          findMany: {
            args: Prisma.RelSponsorClubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>[]
          }
          create: {
            args: Prisma.RelSponsorClubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>
          }
          createMany: {
            args: Prisma.RelSponsorClubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelSponsorClubCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>[]
          }
          delete: {
            args: Prisma.RelSponsorClubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>
          }
          update: {
            args: Prisma.RelSponsorClubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>
          }
          deleteMany: {
            args: Prisma.RelSponsorClubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelSponsorClubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelSponsorClubUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>[]
          }
          upsert: {
            args: Prisma.RelSponsorClubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorClubPayload>
          }
          aggregate: {
            args: Prisma.RelSponsorClubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelSponsorClub>
          }
          groupBy: {
            args: Prisma.RelSponsorClubGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelSponsorClubGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelSponsorClubCountArgs<ExtArgs>
            result: $Utils.Optional<RelSponsorClubCountAggregateOutputType> | number
          }
        }
      }
      RelSponsorLeague: {
        payload: Prisma.$RelSponsorLeaguePayload<ExtArgs>
        fields: Prisma.RelSponsorLeagueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelSponsorLeagueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelSponsorLeagueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>
          }
          findFirst: {
            args: Prisma.RelSponsorLeagueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelSponsorLeagueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>
          }
          findMany: {
            args: Prisma.RelSponsorLeagueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>[]
          }
          create: {
            args: Prisma.RelSponsorLeagueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>
          }
          createMany: {
            args: Prisma.RelSponsorLeagueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelSponsorLeagueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>[]
          }
          delete: {
            args: Prisma.RelSponsorLeagueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>
          }
          update: {
            args: Prisma.RelSponsorLeagueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>
          }
          deleteMany: {
            args: Prisma.RelSponsorLeagueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelSponsorLeagueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelSponsorLeagueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>[]
          }
          upsert: {
            args: Prisma.RelSponsorLeagueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorLeaguePayload>
          }
          aggregate: {
            args: Prisma.RelSponsorLeagueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelSponsorLeague>
          }
          groupBy: {
            args: Prisma.RelSponsorLeagueGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelSponsorLeagueGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelSponsorLeagueCountArgs<ExtArgs>
            result: $Utils.Optional<RelSponsorLeagueCountAggregateOutputType> | number
          }
        }
      }
      RelSponsorTeam: {
        payload: Prisma.$RelSponsorTeamPayload<ExtArgs>
        fields: Prisma.RelSponsorTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelSponsorTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelSponsorTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>
          }
          findFirst: {
            args: Prisma.RelSponsorTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelSponsorTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>
          }
          findMany: {
            args: Prisma.RelSponsorTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>[]
          }
          create: {
            args: Prisma.RelSponsorTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>
          }
          createMany: {
            args: Prisma.RelSponsorTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelSponsorTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>[]
          }
          delete: {
            args: Prisma.RelSponsorTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>
          }
          update: {
            args: Prisma.RelSponsorTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>
          }
          deleteMany: {
            args: Prisma.RelSponsorTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelSponsorTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelSponsorTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>[]
          }
          upsert: {
            args: Prisma.RelSponsorTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelSponsorTeamPayload>
          }
          aggregate: {
            args: Prisma.RelSponsorTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelSponsorTeam>
          }
          groupBy: {
            args: Prisma.RelSponsorTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelSponsorTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelSponsorTeamCountArgs<ExtArgs>
            result: $Utils.Optional<RelSponsorTeamCountAggregateOutputType> | number
          }
        }
      }
      RelTeamCoach: {
        payload: Prisma.$RelTeamCoachPayload<ExtArgs>
        fields: Prisma.RelTeamCoachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelTeamCoachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelTeamCoachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>
          }
          findFirst: {
            args: Prisma.RelTeamCoachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelTeamCoachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>
          }
          findMany: {
            args: Prisma.RelTeamCoachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>[]
          }
          create: {
            args: Prisma.RelTeamCoachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>
          }
          createMany: {
            args: Prisma.RelTeamCoachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelTeamCoachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>[]
          }
          delete: {
            args: Prisma.RelTeamCoachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>
          }
          update: {
            args: Prisma.RelTeamCoachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>
          }
          deleteMany: {
            args: Prisma.RelTeamCoachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelTeamCoachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelTeamCoachUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>[]
          }
          upsert: {
            args: Prisma.RelTeamCoachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamCoachPayload>
          }
          aggregate: {
            args: Prisma.RelTeamCoachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelTeamCoach>
          }
          groupBy: {
            args: Prisma.RelTeamCoachGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelTeamCoachGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelTeamCoachCountArgs<ExtArgs>
            result: $Utils.Optional<RelTeamCoachCountAggregateOutputType> | number
          }
        }
      }
      RelTeamPlayer: {
        payload: Prisma.$RelTeamPlayerPayload<ExtArgs>
        fields: Prisma.RelTeamPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelTeamPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelTeamPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>
          }
          findFirst: {
            args: Prisma.RelTeamPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelTeamPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>
          }
          findMany: {
            args: Prisma.RelTeamPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>[]
          }
          create: {
            args: Prisma.RelTeamPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>
          }
          createMany: {
            args: Prisma.RelTeamPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelTeamPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>[]
          }
          delete: {
            args: Prisma.RelTeamPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>
          }
          update: {
            args: Prisma.RelTeamPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>
          }
          deleteMany: {
            args: Prisma.RelTeamPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelTeamPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelTeamPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>[]
          }
          upsert: {
            args: Prisma.RelTeamPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamPlayerPayload>
          }
          aggregate: {
            args: Prisma.RelTeamPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelTeamPlayer>
          }
          groupBy: {
            args: Prisma.RelTeamPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelTeamPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelTeamPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<RelTeamPlayerCountAggregateOutputType> | number
          }
        }
      }
      RelTeamTeamManager: {
        payload: Prisma.$RelTeamTeamManagerPayload<ExtArgs>
        fields: Prisma.RelTeamTeamManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelTeamTeamManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelTeamTeamManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>
          }
          findFirst: {
            args: Prisma.RelTeamTeamManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelTeamTeamManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>
          }
          findMany: {
            args: Prisma.RelTeamTeamManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>[]
          }
          create: {
            args: Prisma.RelTeamTeamManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>
          }
          createMany: {
            args: Prisma.RelTeamTeamManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelTeamTeamManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>[]
          }
          delete: {
            args: Prisma.RelTeamTeamManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>
          }
          update: {
            args: Prisma.RelTeamTeamManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>
          }
          deleteMany: {
            args: Prisma.RelTeamTeamManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelTeamTeamManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelTeamTeamManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>[]
          }
          upsert: {
            args: Prisma.RelTeamTeamManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelTeamTeamManagerPayload>
          }
          aggregate: {
            args: Prisma.RelTeamTeamManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelTeamTeamManager>
          }
          groupBy: {
            args: Prisma.RelTeamTeamManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelTeamTeamManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelTeamTeamManagerCountArgs<ExtArgs>
            result: $Utils.Optional<RelTeamTeamManagerCountAggregateOutputType> | number
          }
        }
      }
      SportCoachType: {
        payload: Prisma.$SportCoachTypePayload<ExtArgs>
        fields: Prisma.SportCoachTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportCoachTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportCoachTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>
          }
          findFirst: {
            args: Prisma.SportCoachTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportCoachTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>
          }
          findMany: {
            args: Prisma.SportCoachTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>[]
          }
          create: {
            args: Prisma.SportCoachTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>
          }
          createMany: {
            args: Prisma.SportCoachTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportCoachTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>[]
          }
          delete: {
            args: Prisma.SportCoachTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>
          }
          update: {
            args: Prisma.SportCoachTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>
          }
          deleteMany: {
            args: Prisma.SportCoachTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportCoachTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportCoachTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>[]
          }
          upsert: {
            args: Prisma.SportCoachTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportCoachTypePayload>
          }
          aggregate: {
            args: Prisma.SportCoachTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSportCoachType>
          }
          groupBy: {
            args: Prisma.SportCoachTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportCoachTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportCoachTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SportCoachTypeCountAggregateOutputType> | number
          }
        }
      }
      SportEventType: {
        payload: Prisma.$SportEventTypePayload<ExtArgs>
        fields: Prisma.SportEventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportEventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportEventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>
          }
          findFirst: {
            args: Prisma.SportEventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportEventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>
          }
          findMany: {
            args: Prisma.SportEventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>[]
          }
          create: {
            args: Prisma.SportEventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>
          }
          createMany: {
            args: Prisma.SportEventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportEventTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>[]
          }
          delete: {
            args: Prisma.SportEventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>
          }
          update: {
            args: Prisma.SportEventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>
          }
          deleteMany: {
            args: Prisma.SportEventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportEventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportEventTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>[]
          }
          upsert: {
            args: Prisma.SportEventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportEventTypePayload>
          }
          aggregate: {
            args: Prisma.SportEventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSportEventType>
          }
          groupBy: {
            args: Prisma.SportEventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportEventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportEventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SportEventTypeCountAggregateOutputType> | number
          }
        }
      }
      SportGamePeriod: {
        payload: Prisma.$SportGamePeriodPayload<ExtArgs>
        fields: Prisma.SportGamePeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportGamePeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportGamePeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>
          }
          findFirst: {
            args: Prisma.SportGamePeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportGamePeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>
          }
          findMany: {
            args: Prisma.SportGamePeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>[]
          }
          create: {
            args: Prisma.SportGamePeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>
          }
          createMany: {
            args: Prisma.SportGamePeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportGamePeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>[]
          }
          delete: {
            args: Prisma.SportGamePeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>
          }
          update: {
            args: Prisma.SportGamePeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>
          }
          deleteMany: {
            args: Prisma.SportGamePeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportGamePeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportGamePeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>[]
          }
          upsert: {
            args: Prisma.SportGamePeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportGamePeriodPayload>
          }
          aggregate: {
            args: Prisma.SportGamePeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSportGamePeriod>
          }
          groupBy: {
            args: Prisma.SportGamePeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportGamePeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportGamePeriodCountArgs<ExtArgs>
            result: $Utils.Optional<SportGamePeriodCountAggregateOutputType> | number
          }
        }
      }
      SportManagerType: {
        payload: Prisma.$SportManagerTypePayload<ExtArgs>
        fields: Prisma.SportManagerTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportManagerTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportManagerTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>
          }
          findFirst: {
            args: Prisma.SportManagerTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportManagerTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>
          }
          findMany: {
            args: Prisma.SportManagerTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>[]
          }
          create: {
            args: Prisma.SportManagerTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>
          }
          createMany: {
            args: Prisma.SportManagerTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportManagerTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>[]
          }
          delete: {
            args: Prisma.SportManagerTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>
          }
          update: {
            args: Prisma.SportManagerTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>
          }
          deleteMany: {
            args: Prisma.SportManagerTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportManagerTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportManagerTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>[]
          }
          upsert: {
            args: Prisma.SportManagerTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportManagerTypePayload>
          }
          aggregate: {
            args: Prisma.SportManagerTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSportManagerType>
          }
          groupBy: {
            args: Prisma.SportManagerTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportManagerTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportManagerTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SportManagerTypeCountAggregateOutputType> | number
          }
        }
      }
      SportPlayerPosition: {
        payload: Prisma.$SportPlayerPositionPayload<ExtArgs>
        fields: Prisma.SportPlayerPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportPlayerPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportPlayerPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>
          }
          findFirst: {
            args: Prisma.SportPlayerPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportPlayerPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>
          }
          findMany: {
            args: Prisma.SportPlayerPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>[]
          }
          create: {
            args: Prisma.SportPlayerPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>
          }
          createMany: {
            args: Prisma.SportPlayerPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportPlayerPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>[]
          }
          delete: {
            args: Prisma.SportPlayerPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>
          }
          update: {
            args: Prisma.SportPlayerPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>
          }
          deleteMany: {
            args: Prisma.SportPlayerPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportPlayerPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportPlayerPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>[]
          }
          upsert: {
            args: Prisma.SportPlayerPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPlayerPositionPayload>
          }
          aggregate: {
            args: Prisma.SportPlayerPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSportPlayerPosition>
          }
          groupBy: {
            args: Prisma.SportPlayerPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportPlayerPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportPlayerPositionCountArgs<ExtArgs>
            result: $Utils.Optional<SportPlayerPositionCountAggregateOutputType> | number
          }
        }
      }
      SportRefereeType: {
        payload: Prisma.$SportRefereeTypePayload<ExtArgs>
        fields: Prisma.SportRefereeTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportRefereeTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportRefereeTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>
          }
          findFirst: {
            args: Prisma.SportRefereeTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportRefereeTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>
          }
          findMany: {
            args: Prisma.SportRefereeTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>[]
          }
          create: {
            args: Prisma.SportRefereeTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>
          }
          createMany: {
            args: Prisma.SportRefereeTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportRefereeTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>[]
          }
          delete: {
            args: Prisma.SportRefereeTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>
          }
          update: {
            args: Prisma.SportRefereeTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>
          }
          deleteMany: {
            args: Prisma.SportRefereeTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportRefereeTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportRefereeTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>[]
          }
          upsert: {
            args: Prisma.SportRefereeTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportRefereeTypePayload>
          }
          aggregate: {
            args: Prisma.SportRefereeTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSportRefereeType>
          }
          groupBy: {
            args: Prisma.SportRefereeTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportRefereeTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportRefereeTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SportRefereeTypeCountAggregateOutputType> | number
          }
        }
      }
      SubFeature: {
        payload: Prisma.$SubFeaturePayload<ExtArgs>
        fields: Prisma.SubFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>
          }
          findFirst: {
            args: Prisma.SubFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>
          }
          findMany: {
            args: Prisma.SubFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>[]
          }
          create: {
            args: Prisma.SubFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>
          }
          createMany: {
            args: Prisma.SubFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>[]
          }
          delete: {
            args: Prisma.SubFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>
          }
          update: {
            args: Prisma.SubFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>
          }
          deleteMany: {
            args: Prisma.SubFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>[]
          }
          upsert: {
            args: Prisma.SubFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubFeaturePayload>
          }
          aggregate: {
            args: Prisma.SubFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubFeature>
          }
          groupBy: {
            args: Prisma.SubFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<SubFeatureCountAggregateOutputType> | number
          }
        }
      }
      SubForTeam: {
        payload: Prisma.$SubForTeamPayload<ExtArgs>
        fields: Prisma.SubForTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubForTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubForTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>
          }
          findFirst: {
            args: Prisma.SubForTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubForTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>
          }
          findMany: {
            args: Prisma.SubForTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>[]
          }
          create: {
            args: Prisma.SubForTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>
          }
          createMany: {
            args: Prisma.SubForTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubForTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>[]
          }
          delete: {
            args: Prisma.SubForTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>
          }
          update: {
            args: Prisma.SubForTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>
          }
          deleteMany: {
            args: Prisma.SubForTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubForTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubForTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>[]
          }
          upsert: {
            args: Prisma.SubForTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForTeamPayload>
          }
          aggregate: {
            args: Prisma.SubForTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubForTeam>
          }
          groupBy: {
            args: Prisma.SubForTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubForTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubForTeamCountArgs<ExtArgs>
            result: $Utils.Optional<SubForTeamCountAggregateOutputType> | number
          }
        }
      }
      SubForUser: {
        payload: Prisma.$SubForUserPayload<ExtArgs>
        fields: Prisma.SubForUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubForUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubForUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>
          }
          findFirst: {
            args: Prisma.SubForUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubForUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>
          }
          findMany: {
            args: Prisma.SubForUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>[]
          }
          create: {
            args: Prisma.SubForUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>
          }
          createMany: {
            args: Prisma.SubForUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubForUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>[]
          }
          delete: {
            args: Prisma.SubForUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>
          }
          update: {
            args: Prisma.SubForUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>
          }
          deleteMany: {
            args: Prisma.SubForUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubForUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubForUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>[]
          }
          upsert: {
            args: Prisma.SubForUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubForUserPayload>
          }
          aggregate: {
            args: Prisma.SubForUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubForUser>
          }
          groupBy: {
            args: Prisma.SubForUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubForUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubForUserCountArgs<ExtArgs>
            result: $Utils.Optional<SubForUserCountAggregateOutputType> | number
          }
        }
      }
      SubPlan: {
        payload: Prisma.$SubPlanPayload<ExtArgs>
        fields: Prisma.SubPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>
          }
          findFirst: {
            args: Prisma.SubPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>
          }
          findMany: {
            args: Prisma.SubPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>[]
          }
          create: {
            args: Prisma.SubPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>
          }
          createMany: {
            args: Prisma.SubPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>[]
          }
          delete: {
            args: Prisma.SubPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>
          }
          update: {
            args: Prisma.SubPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>
          }
          deleteMany: {
            args: Prisma.SubPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>[]
          }
          upsert: {
            args: Prisma.SubPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanPayload>
          }
          aggregate: {
            args: Prisma.SubPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubPlan>
          }
          groupBy: {
            args: Prisma.SubPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SubPlanCountAggregateOutputType> | number
          }
        }
      }
      SubPlanFeature: {
        payload: Prisma.$SubPlanFeaturePayload<ExtArgs>
        fields: Prisma.SubPlanFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubPlanFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubPlanFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>
          }
          findFirst: {
            args: Prisma.SubPlanFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubPlanFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>
          }
          findMany: {
            args: Prisma.SubPlanFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>[]
          }
          create: {
            args: Prisma.SubPlanFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>
          }
          createMany: {
            args: Prisma.SubPlanFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubPlanFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>[]
          }
          delete: {
            args: Prisma.SubPlanFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>
          }
          update: {
            args: Prisma.SubPlanFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>
          }
          deleteMany: {
            args: Prisma.SubPlanFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubPlanFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubPlanFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>[]
          }
          upsert: {
            args: Prisma.SubPlanFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubPlanFeaturePayload>
          }
          aggregate: {
            args: Prisma.SubPlanFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubPlanFeature>
          }
          groupBy: {
            args: Prisma.SubPlanFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubPlanFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubPlanFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<SubPlanFeatureCountAggregateOutputType> | number
          }
        }
      }
      SysUser: {
        payload: Prisma.$SysUserPayload<ExtArgs>
        fields: Prisma.SysUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SysUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SysUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>
          }
          findFirst: {
            args: Prisma.SysUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SysUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>
          }
          findMany: {
            args: Prisma.SysUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>[]
          }
          create: {
            args: Prisma.SysUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>
          }
          createMany: {
            args: Prisma.SysUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SysUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>[]
          }
          delete: {
            args: Prisma.SysUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>
          }
          update: {
            args: Prisma.SysUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>
          }
          deleteMany: {
            args: Prisma.SysUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SysUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SysUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>[]
          }
          upsert: {
            args: Prisma.SysUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SysUserPayload>
          }
          aggregate: {
            args: Prisma.SysUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysUser>
          }
          groupBy: {
            args: Prisma.SysUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.SysUserCountArgs<ExtArgs>
            result: $Utils.Optional<SysUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    baseCompetition?: BaseCompetitionOmit
    baseCountry?: BaseCountryOmit
    baseField?: BaseFieldOmit
    baseGroupLevel?: BaseGroupLevelOmit
    baseSport?: BaseSportOmit
    gameEvent?: GameEventOmit
    gameMatche?: GameMatcheOmit
    matchEvent?: MatchEventOmit
    matchLineup?: MatchLineupOmit
    matchMedia?: MatchMediaOmit
    matchRoster?: MatchRosterOmit
    matchStatistic?: MatchStatisticOmit
    memberClubAdmin?: MemberClubAdminOmit
    memberCoache?: MemberCoacheOmit
    memberParent?: MemberParentOmit
    memberPerson?: MemberPersonOmit
    memberPlayer?: MemberPlayerOmit
    memberReferee?: MemberRefereeOmit
    memberSponsor?: MemberSponsorOmit
    memberTeamManager?: MemberTeamManagerOmit
    orgClub?: OrgClubOmit
    orgLeague?: OrgLeagueOmit
    orgTeam?: OrgTeamOmit
    planGame?: PlanGameOmit
    planMeeting?: PlanMeetingOmit
    planTraining?: PlanTrainingOmit
    relClubClubAdmin?: RelClubClubAdminOmit
    relCompetitionGroupLevel?: RelCompetitionGroupLevelOmit
    relFieldSport?: RelFieldSportOmit
    relMatchReferee?: RelMatchRefereeOmit
    relPlayerParent?: RelPlayerParentOmit
    relSponsorClub?: RelSponsorClubOmit
    relSponsorLeague?: RelSponsorLeagueOmit
    relSponsorTeam?: RelSponsorTeamOmit
    relTeamCoach?: RelTeamCoachOmit
    relTeamPlayer?: RelTeamPlayerOmit
    relTeamTeamManager?: RelTeamTeamManagerOmit
    sportCoachType?: SportCoachTypeOmit
    sportEventType?: SportEventTypeOmit
    sportGamePeriod?: SportGamePeriodOmit
    sportManagerType?: SportManagerTypeOmit
    sportPlayerPosition?: SportPlayerPositionOmit
    sportRefereeType?: SportRefereeTypeOmit
    subFeature?: SubFeatureOmit
    subForTeam?: SubForTeamOmit
    subForUser?: SubForUserOmit
    subPlan?: SubPlanOmit
    subPlanFeature?: SubPlanFeatureOmit
    sysUser?: SysUserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model BaseCompetition
   */

  export type AggregateBaseCompetition = {
    _count: BaseCompetitionCountAggregateOutputType | null
    _avg: BaseCompetitionAvgAggregateOutputType | null
    _sum: BaseCompetitionSumAggregateOutputType | null
    _min: BaseCompetitionMinAggregateOutputType | null
    _max: BaseCompetitionMaxAggregateOutputType | null
  }

  export type BaseCompetitionAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    ord: number | null
  }

  export type BaseCompetitionSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    ord: number | null
  }

  export type BaseCompetitionMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    sportId: Decimal | null
    description: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseCompetitionMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    sportId: Decimal | null
    description: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseCompetitionCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    sportId: number
    description: number
    status: number
    startDate: number
    endDate: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BaseCompetitionAvgAggregateInputType = {
    id?: true
    sportId?: true
    ord?: true
  }

  export type BaseCompetitionSumAggregateInputType = {
    id?: true
    sportId?: true
    ord?: true
  }

  export type BaseCompetitionMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    sportId?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseCompetitionMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    sportId?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseCompetitionCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    sportId?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BaseCompetitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseCompetition to aggregate.
     */
    where?: BaseCompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCompetitions to fetch.
     */
    orderBy?: BaseCompetitionOrderByWithRelationInput | BaseCompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaseCompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCompetitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCompetitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaseCompetitions
    **/
    _count?: true | BaseCompetitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseCompetitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseCompetitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseCompetitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseCompetitionMaxAggregateInputType
  }

  export type GetBaseCompetitionAggregateType<T extends BaseCompetitionAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseCompetition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseCompetition[P]>
      : GetScalarType<T[P], AggregateBaseCompetition[P]>
  }




  export type BaseCompetitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseCompetitionWhereInput
    orderBy?: BaseCompetitionOrderByWithAggregationInput | BaseCompetitionOrderByWithAggregationInput[]
    by: BaseCompetitionScalarFieldEnum[] | BaseCompetitionScalarFieldEnum
    having?: BaseCompetitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseCompetitionCountAggregateInputType | true
    _avg?: BaseCompetitionAvgAggregateInputType
    _sum?: BaseCompetitionSumAggregateInputType
    _min?: BaseCompetitionMinAggregateInputType
    _max?: BaseCompetitionMaxAggregateInputType
  }

  export type BaseCompetitionGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string | null
    sportId: Decimal | null
    description: string | null
    status: string
    startDate: Date | null
    endDate: Date | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BaseCompetitionCountAggregateOutputType | null
    _avg: BaseCompetitionAvgAggregateOutputType | null
    _sum: BaseCompetitionSumAggregateOutputType | null
    _min: BaseCompetitionMinAggregateOutputType | null
    _max: BaseCompetitionMaxAggregateOutputType | null
  }

  type GetBaseCompetitionGroupByPayload<T extends BaseCompetitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaseCompetitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseCompetitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseCompetitionGroupByOutputType[P]>
            : GetScalarType<T[P], BaseCompetitionGroupByOutputType[P]>
        }
      >
    >


  export type BaseCompetitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    sportId?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseCompetition"]>

  export type BaseCompetitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    sportId?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseCompetition"]>

  export type BaseCompetitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    sportId?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseCompetition"]>

  export type BaseCompetitionSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    sportId?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BaseCompetitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "sportId" | "description" | "status" | "startDate" | "endDate" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["baseCompetition"]>

  export type $BaseCompetitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaseCompetition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string | null
      sportId: Prisma.Decimal | null
      description: string | null
      status: string
      startDate: Date | null
      endDate: Date | null
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["baseCompetition"]>
    composites: {}
  }

  type BaseCompetitionGetPayload<S extends boolean | null | undefined | BaseCompetitionDefaultArgs> = $Result.GetResult<Prisma.$BaseCompetitionPayload, S>

  type BaseCompetitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BaseCompetitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BaseCompetitionCountAggregateInputType | true
    }

  export interface BaseCompetitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaseCompetition'], meta: { name: 'BaseCompetition' } }
    /**
     * Find zero or one BaseCompetition that matches the filter.
     * @param {BaseCompetitionFindUniqueArgs} args - Arguments to find a BaseCompetition
     * @example
     * // Get one BaseCompetition
     * const baseCompetition = await prisma.baseCompetition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaseCompetitionFindUniqueArgs>(args: SelectSubset<T, BaseCompetitionFindUniqueArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BaseCompetition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BaseCompetitionFindUniqueOrThrowArgs} args - Arguments to find a BaseCompetition
     * @example
     * // Get one BaseCompetition
     * const baseCompetition = await prisma.baseCompetition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaseCompetitionFindUniqueOrThrowArgs>(args: SelectSubset<T, BaseCompetitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseCompetition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionFindFirstArgs} args - Arguments to find a BaseCompetition
     * @example
     * // Get one BaseCompetition
     * const baseCompetition = await prisma.baseCompetition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaseCompetitionFindFirstArgs>(args?: SelectSubset<T, BaseCompetitionFindFirstArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseCompetition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionFindFirstOrThrowArgs} args - Arguments to find a BaseCompetition
     * @example
     * // Get one BaseCompetition
     * const baseCompetition = await prisma.baseCompetition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaseCompetitionFindFirstOrThrowArgs>(args?: SelectSubset<T, BaseCompetitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BaseCompetitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseCompetitions
     * const baseCompetitions = await prisma.baseCompetition.findMany()
     * 
     * // Get first 10 BaseCompetitions
     * const baseCompetitions = await prisma.baseCompetition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseCompetitionWithIdOnly = await prisma.baseCompetition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaseCompetitionFindManyArgs>(args?: SelectSubset<T, BaseCompetitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BaseCompetition.
     * @param {BaseCompetitionCreateArgs} args - Arguments to create a BaseCompetition.
     * @example
     * // Create one BaseCompetition
     * const BaseCompetition = await prisma.baseCompetition.create({
     *   data: {
     *     // ... data to create a BaseCompetition
     *   }
     * })
     * 
     */
    create<T extends BaseCompetitionCreateArgs>(args: SelectSubset<T, BaseCompetitionCreateArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BaseCompetitions.
     * @param {BaseCompetitionCreateManyArgs} args - Arguments to create many BaseCompetitions.
     * @example
     * // Create many BaseCompetitions
     * const baseCompetition = await prisma.baseCompetition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaseCompetitionCreateManyArgs>(args?: SelectSubset<T, BaseCompetitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BaseCompetitions and returns the data saved in the database.
     * @param {BaseCompetitionCreateManyAndReturnArgs} args - Arguments to create many BaseCompetitions.
     * @example
     * // Create many BaseCompetitions
     * const baseCompetition = await prisma.baseCompetition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BaseCompetitions and only return the `id`
     * const baseCompetitionWithIdOnly = await prisma.baseCompetition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BaseCompetitionCreateManyAndReturnArgs>(args?: SelectSubset<T, BaseCompetitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BaseCompetition.
     * @param {BaseCompetitionDeleteArgs} args - Arguments to delete one BaseCompetition.
     * @example
     * // Delete one BaseCompetition
     * const BaseCompetition = await prisma.baseCompetition.delete({
     *   where: {
     *     // ... filter to delete one BaseCompetition
     *   }
     * })
     * 
     */
    delete<T extends BaseCompetitionDeleteArgs>(args: SelectSubset<T, BaseCompetitionDeleteArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BaseCompetition.
     * @param {BaseCompetitionUpdateArgs} args - Arguments to update one BaseCompetition.
     * @example
     * // Update one BaseCompetition
     * const baseCompetition = await prisma.baseCompetition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaseCompetitionUpdateArgs>(args: SelectSubset<T, BaseCompetitionUpdateArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BaseCompetitions.
     * @param {BaseCompetitionDeleteManyArgs} args - Arguments to filter BaseCompetitions to delete.
     * @example
     * // Delete a few BaseCompetitions
     * const { count } = await prisma.baseCompetition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaseCompetitionDeleteManyArgs>(args?: SelectSubset<T, BaseCompetitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseCompetitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseCompetitions
     * const baseCompetition = await prisma.baseCompetition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaseCompetitionUpdateManyArgs>(args: SelectSubset<T, BaseCompetitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseCompetitions and returns the data updated in the database.
     * @param {BaseCompetitionUpdateManyAndReturnArgs} args - Arguments to update many BaseCompetitions.
     * @example
     * // Update many BaseCompetitions
     * const baseCompetition = await prisma.baseCompetition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BaseCompetitions and only return the `id`
     * const baseCompetitionWithIdOnly = await prisma.baseCompetition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BaseCompetitionUpdateManyAndReturnArgs>(args: SelectSubset<T, BaseCompetitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BaseCompetition.
     * @param {BaseCompetitionUpsertArgs} args - Arguments to update or create a BaseCompetition.
     * @example
     * // Update or create a BaseCompetition
     * const baseCompetition = await prisma.baseCompetition.upsert({
     *   create: {
     *     // ... data to create a BaseCompetition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseCompetition we want to update
     *   }
     * })
     */
    upsert<T extends BaseCompetitionUpsertArgs>(args: SelectSubset<T, BaseCompetitionUpsertArgs<ExtArgs>>): Prisma__BaseCompetitionClient<$Result.GetResult<Prisma.$BaseCompetitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BaseCompetitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionCountArgs} args - Arguments to filter BaseCompetitions to count.
     * @example
     * // Count the number of BaseCompetitions
     * const count = await prisma.baseCompetition.count({
     *   where: {
     *     // ... the filter for the BaseCompetitions we want to count
     *   }
     * })
    **/
    count<T extends BaseCompetitionCountArgs>(
      args?: Subset<T, BaseCompetitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseCompetitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseCompetition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseCompetitionAggregateArgs>(args: Subset<T, BaseCompetitionAggregateArgs>): Prisma.PrismaPromise<GetBaseCompetitionAggregateType<T>>

    /**
     * Group by BaseCompetition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCompetitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseCompetitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseCompetitionGroupByArgs['orderBy'] }
        : { orderBy?: BaseCompetitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseCompetitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseCompetitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaseCompetition model
   */
  readonly fields: BaseCompetitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaseCompetition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaseCompetitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaseCompetition model
   */
  interface BaseCompetitionFieldRefs {
    readonly id: FieldRef<"BaseCompetition", 'Decimal'>
    readonly name: FieldRef<"BaseCompetition", 'String'>
    readonly abbr: FieldRef<"BaseCompetition", 'String'>
    readonly sportId: FieldRef<"BaseCompetition", 'Decimal'>
    readonly description: FieldRef<"BaseCompetition", 'String'>
    readonly status: FieldRef<"BaseCompetition", 'String'>
    readonly startDate: FieldRef<"BaseCompetition", 'DateTime'>
    readonly endDate: FieldRef<"BaseCompetition", 'DateTime'>
    readonly ord: FieldRef<"BaseCompetition", 'Int'>
    readonly createdAt: FieldRef<"BaseCompetition", 'DateTime'>
    readonly updatedAt: FieldRef<"BaseCompetition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BaseCompetition findUnique
   */
  export type BaseCompetitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * Filter, which BaseCompetition to fetch.
     */
    where: BaseCompetitionWhereUniqueInput
  }

  /**
   * BaseCompetition findUniqueOrThrow
   */
  export type BaseCompetitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * Filter, which BaseCompetition to fetch.
     */
    where: BaseCompetitionWhereUniqueInput
  }

  /**
   * BaseCompetition findFirst
   */
  export type BaseCompetitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * Filter, which BaseCompetition to fetch.
     */
    where?: BaseCompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCompetitions to fetch.
     */
    orderBy?: BaseCompetitionOrderByWithRelationInput | BaseCompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseCompetitions.
     */
    cursor?: BaseCompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCompetitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCompetitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseCompetitions.
     */
    distinct?: BaseCompetitionScalarFieldEnum | BaseCompetitionScalarFieldEnum[]
  }

  /**
   * BaseCompetition findFirstOrThrow
   */
  export type BaseCompetitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * Filter, which BaseCompetition to fetch.
     */
    where?: BaseCompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCompetitions to fetch.
     */
    orderBy?: BaseCompetitionOrderByWithRelationInput | BaseCompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseCompetitions.
     */
    cursor?: BaseCompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCompetitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCompetitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseCompetitions.
     */
    distinct?: BaseCompetitionScalarFieldEnum | BaseCompetitionScalarFieldEnum[]
  }

  /**
   * BaseCompetition findMany
   */
  export type BaseCompetitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * Filter, which BaseCompetitions to fetch.
     */
    where?: BaseCompetitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCompetitions to fetch.
     */
    orderBy?: BaseCompetitionOrderByWithRelationInput | BaseCompetitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaseCompetitions.
     */
    cursor?: BaseCompetitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCompetitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCompetitions.
     */
    skip?: number
    distinct?: BaseCompetitionScalarFieldEnum | BaseCompetitionScalarFieldEnum[]
  }

  /**
   * BaseCompetition create
   */
  export type BaseCompetitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * The data needed to create a BaseCompetition.
     */
    data: XOR<BaseCompetitionCreateInput, BaseCompetitionUncheckedCreateInput>
  }

  /**
   * BaseCompetition createMany
   */
  export type BaseCompetitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaseCompetitions.
     */
    data: BaseCompetitionCreateManyInput | BaseCompetitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseCompetition createManyAndReturn
   */
  export type BaseCompetitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * The data used to create many BaseCompetitions.
     */
    data: BaseCompetitionCreateManyInput | BaseCompetitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseCompetition update
   */
  export type BaseCompetitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * The data needed to update a BaseCompetition.
     */
    data: XOR<BaseCompetitionUpdateInput, BaseCompetitionUncheckedUpdateInput>
    /**
     * Choose, which BaseCompetition to update.
     */
    where: BaseCompetitionWhereUniqueInput
  }

  /**
   * BaseCompetition updateMany
   */
  export type BaseCompetitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaseCompetitions.
     */
    data: XOR<BaseCompetitionUpdateManyMutationInput, BaseCompetitionUncheckedUpdateManyInput>
    /**
     * Filter which BaseCompetitions to update
     */
    where?: BaseCompetitionWhereInput
    /**
     * Limit how many BaseCompetitions to update.
     */
    limit?: number
  }

  /**
   * BaseCompetition updateManyAndReturn
   */
  export type BaseCompetitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * The data used to update BaseCompetitions.
     */
    data: XOR<BaseCompetitionUpdateManyMutationInput, BaseCompetitionUncheckedUpdateManyInput>
    /**
     * Filter which BaseCompetitions to update
     */
    where?: BaseCompetitionWhereInput
    /**
     * Limit how many BaseCompetitions to update.
     */
    limit?: number
  }

  /**
   * BaseCompetition upsert
   */
  export type BaseCompetitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * The filter to search for the BaseCompetition to update in case it exists.
     */
    where: BaseCompetitionWhereUniqueInput
    /**
     * In case the BaseCompetition found by the `where` argument doesn't exist, create a new BaseCompetition with this data.
     */
    create: XOR<BaseCompetitionCreateInput, BaseCompetitionUncheckedCreateInput>
    /**
     * In case the BaseCompetition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaseCompetitionUpdateInput, BaseCompetitionUncheckedUpdateInput>
  }

  /**
   * BaseCompetition delete
   */
  export type BaseCompetitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
    /**
     * Filter which BaseCompetition to delete.
     */
    where: BaseCompetitionWhereUniqueInput
  }

  /**
   * BaseCompetition deleteMany
   */
  export type BaseCompetitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseCompetitions to delete
     */
    where?: BaseCompetitionWhereInput
    /**
     * Limit how many BaseCompetitions to delete.
     */
    limit?: number
  }

  /**
   * BaseCompetition without action
   */
  export type BaseCompetitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCompetition
     */
    select?: BaseCompetitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCompetition
     */
    omit?: BaseCompetitionOmit<ExtArgs> | null
  }


  /**
   * Model BaseCountry
   */

  export type AggregateBaseCountry = {
    _count: BaseCountryCountAggregateOutputType | null
    _avg: BaseCountryAvgAggregateOutputType | null
    _sum: BaseCountrySumAggregateOutputType | null
    _min: BaseCountryMinAggregateOutputType | null
    _max: BaseCountryMaxAggregateOutputType | null
  }

  export type BaseCountryAvgAggregateOutputType = {
    id: number | null
    ord: number | null
  }

  export type BaseCountrySumAggregateOutputType = {
    id: number | null
    ord: number | null
  }

  export type BaseCountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbr: string | null
    code: string | null
    note: string | null
    isActive: boolean | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseCountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbr: string | null
    code: string | null
    note: string | null
    isActive: boolean | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseCountryCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    code: number
    note: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BaseCountryAvgAggregateInputType = {
    id?: true
    ord?: true
  }

  export type BaseCountrySumAggregateInputType = {
    id?: true
    ord?: true
  }

  export type BaseCountryMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    code?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseCountryMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    code?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseCountryCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    code?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BaseCountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseCountry to aggregate.
     */
    where?: BaseCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCountries to fetch.
     */
    orderBy?: BaseCountryOrderByWithRelationInput | BaseCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaseCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaseCountries
    **/
    _count?: true | BaseCountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseCountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseCountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseCountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseCountryMaxAggregateInputType
  }

  export type GetBaseCountryAggregateType<T extends BaseCountryAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseCountry[P]>
      : GetScalarType<T[P], AggregateBaseCountry[P]>
  }




  export type BaseCountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseCountryWhereInput
    orderBy?: BaseCountryOrderByWithAggregationInput | BaseCountryOrderByWithAggregationInput[]
    by: BaseCountryScalarFieldEnum[] | BaseCountryScalarFieldEnum
    having?: BaseCountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseCountryCountAggregateInputType | true
    _avg?: BaseCountryAvgAggregateInputType
    _sum?: BaseCountrySumAggregateInputType
    _min?: BaseCountryMinAggregateInputType
    _max?: BaseCountryMaxAggregateInputType
  }

  export type BaseCountryGroupByOutputType = {
    id: number
    name: string
    abbr: string | null
    code: string | null
    note: string | null
    isActive: boolean
    ord: number
    createdAt: Date
    updatedAt: Date
    _count: BaseCountryCountAggregateOutputType | null
    _avg: BaseCountryAvgAggregateOutputType | null
    _sum: BaseCountrySumAggregateOutputType | null
    _min: BaseCountryMinAggregateOutputType | null
    _max: BaseCountryMaxAggregateOutputType | null
  }

  type GetBaseCountryGroupByPayload<T extends BaseCountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaseCountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseCountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseCountryGroupByOutputType[P]>
            : GetScalarType<T[P], BaseCountryGroupByOutputType[P]>
        }
      >
    >


  export type BaseCountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    code?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseCountry"]>

  export type BaseCountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    code?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseCountry"]>

  export type BaseCountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    code?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseCountry"]>

  export type BaseCountrySelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    code?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BaseCountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "code" | "note" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["baseCountry"]>

  export type $BaseCountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaseCountry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abbr: string | null
      code: string | null
      note: string | null
      isActive: boolean
      ord: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["baseCountry"]>
    composites: {}
  }

  type BaseCountryGetPayload<S extends boolean | null | undefined | BaseCountryDefaultArgs> = $Result.GetResult<Prisma.$BaseCountryPayload, S>

  type BaseCountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BaseCountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BaseCountryCountAggregateInputType | true
    }

  export interface BaseCountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaseCountry'], meta: { name: 'BaseCountry' } }
    /**
     * Find zero or one BaseCountry that matches the filter.
     * @param {BaseCountryFindUniqueArgs} args - Arguments to find a BaseCountry
     * @example
     * // Get one BaseCountry
     * const baseCountry = await prisma.baseCountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaseCountryFindUniqueArgs>(args: SelectSubset<T, BaseCountryFindUniqueArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BaseCountry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BaseCountryFindUniqueOrThrowArgs} args - Arguments to find a BaseCountry
     * @example
     * // Get one BaseCountry
     * const baseCountry = await prisma.baseCountry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaseCountryFindUniqueOrThrowArgs>(args: SelectSubset<T, BaseCountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseCountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryFindFirstArgs} args - Arguments to find a BaseCountry
     * @example
     * // Get one BaseCountry
     * const baseCountry = await prisma.baseCountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaseCountryFindFirstArgs>(args?: SelectSubset<T, BaseCountryFindFirstArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseCountry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryFindFirstOrThrowArgs} args - Arguments to find a BaseCountry
     * @example
     * // Get one BaseCountry
     * const baseCountry = await prisma.baseCountry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaseCountryFindFirstOrThrowArgs>(args?: SelectSubset<T, BaseCountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BaseCountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseCountries
     * const baseCountries = await prisma.baseCountry.findMany()
     * 
     * // Get first 10 BaseCountries
     * const baseCountries = await prisma.baseCountry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseCountryWithIdOnly = await prisma.baseCountry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaseCountryFindManyArgs>(args?: SelectSubset<T, BaseCountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BaseCountry.
     * @param {BaseCountryCreateArgs} args - Arguments to create a BaseCountry.
     * @example
     * // Create one BaseCountry
     * const BaseCountry = await prisma.baseCountry.create({
     *   data: {
     *     // ... data to create a BaseCountry
     *   }
     * })
     * 
     */
    create<T extends BaseCountryCreateArgs>(args: SelectSubset<T, BaseCountryCreateArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BaseCountries.
     * @param {BaseCountryCreateManyArgs} args - Arguments to create many BaseCountries.
     * @example
     * // Create many BaseCountries
     * const baseCountry = await prisma.baseCountry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaseCountryCreateManyArgs>(args?: SelectSubset<T, BaseCountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BaseCountries and returns the data saved in the database.
     * @param {BaseCountryCreateManyAndReturnArgs} args - Arguments to create many BaseCountries.
     * @example
     * // Create many BaseCountries
     * const baseCountry = await prisma.baseCountry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BaseCountries and only return the `id`
     * const baseCountryWithIdOnly = await prisma.baseCountry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BaseCountryCreateManyAndReturnArgs>(args?: SelectSubset<T, BaseCountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BaseCountry.
     * @param {BaseCountryDeleteArgs} args - Arguments to delete one BaseCountry.
     * @example
     * // Delete one BaseCountry
     * const BaseCountry = await prisma.baseCountry.delete({
     *   where: {
     *     // ... filter to delete one BaseCountry
     *   }
     * })
     * 
     */
    delete<T extends BaseCountryDeleteArgs>(args: SelectSubset<T, BaseCountryDeleteArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BaseCountry.
     * @param {BaseCountryUpdateArgs} args - Arguments to update one BaseCountry.
     * @example
     * // Update one BaseCountry
     * const baseCountry = await prisma.baseCountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaseCountryUpdateArgs>(args: SelectSubset<T, BaseCountryUpdateArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BaseCountries.
     * @param {BaseCountryDeleteManyArgs} args - Arguments to filter BaseCountries to delete.
     * @example
     * // Delete a few BaseCountries
     * const { count } = await prisma.baseCountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaseCountryDeleteManyArgs>(args?: SelectSubset<T, BaseCountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseCountries
     * const baseCountry = await prisma.baseCountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaseCountryUpdateManyArgs>(args: SelectSubset<T, BaseCountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseCountries and returns the data updated in the database.
     * @param {BaseCountryUpdateManyAndReturnArgs} args - Arguments to update many BaseCountries.
     * @example
     * // Update many BaseCountries
     * const baseCountry = await prisma.baseCountry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BaseCountries and only return the `id`
     * const baseCountryWithIdOnly = await prisma.baseCountry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BaseCountryUpdateManyAndReturnArgs>(args: SelectSubset<T, BaseCountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BaseCountry.
     * @param {BaseCountryUpsertArgs} args - Arguments to update or create a BaseCountry.
     * @example
     * // Update or create a BaseCountry
     * const baseCountry = await prisma.baseCountry.upsert({
     *   create: {
     *     // ... data to create a BaseCountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseCountry we want to update
     *   }
     * })
     */
    upsert<T extends BaseCountryUpsertArgs>(args: SelectSubset<T, BaseCountryUpsertArgs<ExtArgs>>): Prisma__BaseCountryClient<$Result.GetResult<Prisma.$BaseCountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BaseCountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryCountArgs} args - Arguments to filter BaseCountries to count.
     * @example
     * // Count the number of BaseCountries
     * const count = await prisma.baseCountry.count({
     *   where: {
     *     // ... the filter for the BaseCountries we want to count
     *   }
     * })
    **/
    count<T extends BaseCountryCountArgs>(
      args?: Subset<T, BaseCountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseCountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseCountryAggregateArgs>(args: Subset<T, BaseCountryAggregateArgs>): Prisma.PrismaPromise<GetBaseCountryAggregateType<T>>

    /**
     * Group by BaseCountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseCountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseCountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseCountryGroupByArgs['orderBy'] }
        : { orderBy?: BaseCountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseCountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaseCountry model
   */
  readonly fields: BaseCountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaseCountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaseCountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaseCountry model
   */
  interface BaseCountryFieldRefs {
    readonly id: FieldRef<"BaseCountry", 'Int'>
    readonly name: FieldRef<"BaseCountry", 'String'>
    readonly abbr: FieldRef<"BaseCountry", 'String'>
    readonly code: FieldRef<"BaseCountry", 'String'>
    readonly note: FieldRef<"BaseCountry", 'String'>
    readonly isActive: FieldRef<"BaseCountry", 'Boolean'>
    readonly ord: FieldRef<"BaseCountry", 'Int'>
    readonly createdAt: FieldRef<"BaseCountry", 'DateTime'>
    readonly updatedAt: FieldRef<"BaseCountry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BaseCountry findUnique
   */
  export type BaseCountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * Filter, which BaseCountry to fetch.
     */
    where: BaseCountryWhereUniqueInput
  }

  /**
   * BaseCountry findUniqueOrThrow
   */
  export type BaseCountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * Filter, which BaseCountry to fetch.
     */
    where: BaseCountryWhereUniqueInput
  }

  /**
   * BaseCountry findFirst
   */
  export type BaseCountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * Filter, which BaseCountry to fetch.
     */
    where?: BaseCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCountries to fetch.
     */
    orderBy?: BaseCountryOrderByWithRelationInput | BaseCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseCountries.
     */
    cursor?: BaseCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseCountries.
     */
    distinct?: BaseCountryScalarFieldEnum | BaseCountryScalarFieldEnum[]
  }

  /**
   * BaseCountry findFirstOrThrow
   */
  export type BaseCountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * Filter, which BaseCountry to fetch.
     */
    where?: BaseCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCountries to fetch.
     */
    orderBy?: BaseCountryOrderByWithRelationInput | BaseCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseCountries.
     */
    cursor?: BaseCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseCountries.
     */
    distinct?: BaseCountryScalarFieldEnum | BaseCountryScalarFieldEnum[]
  }

  /**
   * BaseCountry findMany
   */
  export type BaseCountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * Filter, which BaseCountries to fetch.
     */
    where?: BaseCountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseCountries to fetch.
     */
    orderBy?: BaseCountryOrderByWithRelationInput | BaseCountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaseCountries.
     */
    cursor?: BaseCountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseCountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseCountries.
     */
    skip?: number
    distinct?: BaseCountryScalarFieldEnum | BaseCountryScalarFieldEnum[]
  }

  /**
   * BaseCountry create
   */
  export type BaseCountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * The data needed to create a BaseCountry.
     */
    data: XOR<BaseCountryCreateInput, BaseCountryUncheckedCreateInput>
  }

  /**
   * BaseCountry createMany
   */
  export type BaseCountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaseCountries.
     */
    data: BaseCountryCreateManyInput | BaseCountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseCountry createManyAndReturn
   */
  export type BaseCountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * The data used to create many BaseCountries.
     */
    data: BaseCountryCreateManyInput | BaseCountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseCountry update
   */
  export type BaseCountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * The data needed to update a BaseCountry.
     */
    data: XOR<BaseCountryUpdateInput, BaseCountryUncheckedUpdateInput>
    /**
     * Choose, which BaseCountry to update.
     */
    where: BaseCountryWhereUniqueInput
  }

  /**
   * BaseCountry updateMany
   */
  export type BaseCountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaseCountries.
     */
    data: XOR<BaseCountryUpdateManyMutationInput, BaseCountryUncheckedUpdateManyInput>
    /**
     * Filter which BaseCountries to update
     */
    where?: BaseCountryWhereInput
    /**
     * Limit how many BaseCountries to update.
     */
    limit?: number
  }

  /**
   * BaseCountry updateManyAndReturn
   */
  export type BaseCountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * The data used to update BaseCountries.
     */
    data: XOR<BaseCountryUpdateManyMutationInput, BaseCountryUncheckedUpdateManyInput>
    /**
     * Filter which BaseCountries to update
     */
    where?: BaseCountryWhereInput
    /**
     * Limit how many BaseCountries to update.
     */
    limit?: number
  }

  /**
   * BaseCountry upsert
   */
  export type BaseCountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * The filter to search for the BaseCountry to update in case it exists.
     */
    where: BaseCountryWhereUniqueInput
    /**
     * In case the BaseCountry found by the `where` argument doesn't exist, create a new BaseCountry with this data.
     */
    create: XOR<BaseCountryCreateInput, BaseCountryUncheckedCreateInput>
    /**
     * In case the BaseCountry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaseCountryUpdateInput, BaseCountryUncheckedUpdateInput>
  }

  /**
   * BaseCountry delete
   */
  export type BaseCountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
    /**
     * Filter which BaseCountry to delete.
     */
    where: BaseCountryWhereUniqueInput
  }

  /**
   * BaseCountry deleteMany
   */
  export type BaseCountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseCountries to delete
     */
    where?: BaseCountryWhereInput
    /**
     * Limit how many BaseCountries to delete.
     */
    limit?: number
  }

  /**
   * BaseCountry without action
   */
  export type BaseCountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseCountry
     */
    select?: BaseCountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseCountry
     */
    omit?: BaseCountryOmit<ExtArgs> | null
  }


  /**
   * Model BaseField
   */

  export type AggregateBaseField = {
    _count: BaseFieldCountAggregateOutputType | null
    _avg: BaseFieldAvgAggregateOutputType | null
    _sum: BaseFieldSumAggregateOutputType | null
    _min: BaseFieldMinAggregateOutputType | null
    _max: BaseFieldMaxAggregateOutputType | null
  }

  export type BaseFieldAvgAggregateOutputType = {
    id: number | null
    sportIds: number | null
    countryId: number | null
    ord: number | null
  }

  export type BaseFieldSumAggregateOutputType = {
    id: number | null
    sportIds: number[]
    countryId: number | null
    ord: number | null
  }

  export type BaseFieldMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbr: string | null
    note: string | null
    isActive: boolean | null
    countryId: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseFieldMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbr: string | null
    note: string | null
    isActive: boolean | null
    countryId: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseFieldCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    note: number
    isActive: number
    sportIds: number
    countryId: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BaseFieldAvgAggregateInputType = {
    id?: true
    sportIds?: true
    countryId?: true
    ord?: true
  }

  export type BaseFieldSumAggregateInputType = {
    id?: true
    sportIds?: true
    countryId?: true
    ord?: true
  }

  export type BaseFieldMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    isActive?: true
    countryId?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseFieldMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    isActive?: true
    countryId?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseFieldCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    isActive?: true
    sportIds?: true
    countryId?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BaseFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseField to aggregate.
     */
    where?: BaseFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseFields to fetch.
     */
    orderBy?: BaseFieldOrderByWithRelationInput | BaseFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaseFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaseFields
    **/
    _count?: true | BaseFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseFieldMaxAggregateInputType
  }

  export type GetBaseFieldAggregateType<T extends BaseFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseField[P]>
      : GetScalarType<T[P], AggregateBaseField[P]>
  }




  export type BaseFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseFieldWhereInput
    orderBy?: BaseFieldOrderByWithAggregationInput | BaseFieldOrderByWithAggregationInput[]
    by: BaseFieldScalarFieldEnum[] | BaseFieldScalarFieldEnum
    having?: BaseFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseFieldCountAggregateInputType | true
    _avg?: BaseFieldAvgAggregateInputType
    _sum?: BaseFieldSumAggregateInputType
    _min?: BaseFieldMinAggregateInputType
    _max?: BaseFieldMaxAggregateInputType
  }

  export type BaseFieldGroupByOutputType = {
    id: number
    name: string
    abbr: string | null
    note: string | null
    isActive: boolean
    sportIds: number[]
    countryId: number | null
    ord: number
    createdAt: Date
    updatedAt: Date
    _count: BaseFieldCountAggregateOutputType | null
    _avg: BaseFieldAvgAggregateOutputType | null
    _sum: BaseFieldSumAggregateOutputType | null
    _min: BaseFieldMinAggregateOutputType | null
    _max: BaseFieldMaxAggregateOutputType | null
  }

  type GetBaseFieldGroupByPayload<T extends BaseFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaseFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseFieldGroupByOutputType[P]>
            : GetScalarType<T[P], BaseFieldGroupByOutputType[P]>
        }
      >
    >


  export type BaseFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    sportIds?: boolean
    countryId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseField"]>

  export type BaseFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    sportIds?: boolean
    countryId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseField"]>

  export type BaseFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    sportIds?: boolean
    countryId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseField"]>

  export type BaseFieldSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    sportIds?: boolean
    countryId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BaseFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "note" | "isActive" | "sportIds" | "countryId" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["baseField"]>

  export type $BaseFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaseField"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abbr: string | null
      note: string | null
      isActive: boolean
      sportIds: number[]
      countryId: number | null
      ord: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["baseField"]>
    composites: {}
  }

  type BaseFieldGetPayload<S extends boolean | null | undefined | BaseFieldDefaultArgs> = $Result.GetResult<Prisma.$BaseFieldPayload, S>

  type BaseFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BaseFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BaseFieldCountAggregateInputType | true
    }

  export interface BaseFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaseField'], meta: { name: 'BaseField' } }
    /**
     * Find zero or one BaseField that matches the filter.
     * @param {BaseFieldFindUniqueArgs} args - Arguments to find a BaseField
     * @example
     * // Get one BaseField
     * const baseField = await prisma.baseField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaseFieldFindUniqueArgs>(args: SelectSubset<T, BaseFieldFindUniqueArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BaseField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BaseFieldFindUniqueOrThrowArgs} args - Arguments to find a BaseField
     * @example
     * // Get one BaseField
     * const baseField = await prisma.baseField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaseFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, BaseFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldFindFirstArgs} args - Arguments to find a BaseField
     * @example
     * // Get one BaseField
     * const baseField = await prisma.baseField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaseFieldFindFirstArgs>(args?: SelectSubset<T, BaseFieldFindFirstArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldFindFirstOrThrowArgs} args - Arguments to find a BaseField
     * @example
     * // Get one BaseField
     * const baseField = await prisma.baseField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaseFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, BaseFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BaseFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseFields
     * const baseFields = await prisma.baseField.findMany()
     * 
     * // Get first 10 BaseFields
     * const baseFields = await prisma.baseField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseFieldWithIdOnly = await prisma.baseField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaseFieldFindManyArgs>(args?: SelectSubset<T, BaseFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BaseField.
     * @param {BaseFieldCreateArgs} args - Arguments to create a BaseField.
     * @example
     * // Create one BaseField
     * const BaseField = await prisma.baseField.create({
     *   data: {
     *     // ... data to create a BaseField
     *   }
     * })
     * 
     */
    create<T extends BaseFieldCreateArgs>(args: SelectSubset<T, BaseFieldCreateArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BaseFields.
     * @param {BaseFieldCreateManyArgs} args - Arguments to create many BaseFields.
     * @example
     * // Create many BaseFields
     * const baseField = await prisma.baseField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaseFieldCreateManyArgs>(args?: SelectSubset<T, BaseFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BaseFields and returns the data saved in the database.
     * @param {BaseFieldCreateManyAndReturnArgs} args - Arguments to create many BaseFields.
     * @example
     * // Create many BaseFields
     * const baseField = await prisma.baseField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BaseFields and only return the `id`
     * const baseFieldWithIdOnly = await prisma.baseField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BaseFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, BaseFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BaseField.
     * @param {BaseFieldDeleteArgs} args - Arguments to delete one BaseField.
     * @example
     * // Delete one BaseField
     * const BaseField = await prisma.baseField.delete({
     *   where: {
     *     // ... filter to delete one BaseField
     *   }
     * })
     * 
     */
    delete<T extends BaseFieldDeleteArgs>(args: SelectSubset<T, BaseFieldDeleteArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BaseField.
     * @param {BaseFieldUpdateArgs} args - Arguments to update one BaseField.
     * @example
     * // Update one BaseField
     * const baseField = await prisma.baseField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaseFieldUpdateArgs>(args: SelectSubset<T, BaseFieldUpdateArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BaseFields.
     * @param {BaseFieldDeleteManyArgs} args - Arguments to filter BaseFields to delete.
     * @example
     * // Delete a few BaseFields
     * const { count } = await prisma.baseField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaseFieldDeleteManyArgs>(args?: SelectSubset<T, BaseFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseFields
     * const baseField = await prisma.baseField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaseFieldUpdateManyArgs>(args: SelectSubset<T, BaseFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseFields and returns the data updated in the database.
     * @param {BaseFieldUpdateManyAndReturnArgs} args - Arguments to update many BaseFields.
     * @example
     * // Update many BaseFields
     * const baseField = await prisma.baseField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BaseFields and only return the `id`
     * const baseFieldWithIdOnly = await prisma.baseField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BaseFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, BaseFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BaseField.
     * @param {BaseFieldUpsertArgs} args - Arguments to update or create a BaseField.
     * @example
     * // Update or create a BaseField
     * const baseField = await prisma.baseField.upsert({
     *   create: {
     *     // ... data to create a BaseField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseField we want to update
     *   }
     * })
     */
    upsert<T extends BaseFieldUpsertArgs>(args: SelectSubset<T, BaseFieldUpsertArgs<ExtArgs>>): Prisma__BaseFieldClient<$Result.GetResult<Prisma.$BaseFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BaseFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldCountArgs} args - Arguments to filter BaseFields to count.
     * @example
     * // Count the number of BaseFields
     * const count = await prisma.baseField.count({
     *   where: {
     *     // ... the filter for the BaseFields we want to count
     *   }
     * })
    **/
    count<T extends BaseFieldCountArgs>(
      args?: Subset<T, BaseFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseFieldAggregateArgs>(args: Subset<T, BaseFieldAggregateArgs>): Prisma.PrismaPromise<GetBaseFieldAggregateType<T>>

    /**
     * Group by BaseField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseFieldGroupByArgs['orderBy'] }
        : { orderBy?: BaseFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaseField model
   */
  readonly fields: BaseFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaseField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaseFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaseField model
   */
  interface BaseFieldFieldRefs {
    readonly id: FieldRef<"BaseField", 'Int'>
    readonly name: FieldRef<"BaseField", 'String'>
    readonly abbr: FieldRef<"BaseField", 'String'>
    readonly note: FieldRef<"BaseField", 'String'>
    readonly isActive: FieldRef<"BaseField", 'Boolean'>
    readonly sportIds: FieldRef<"BaseField", 'Int[]'>
    readonly countryId: FieldRef<"BaseField", 'Int'>
    readonly ord: FieldRef<"BaseField", 'Int'>
    readonly createdAt: FieldRef<"BaseField", 'DateTime'>
    readonly updatedAt: FieldRef<"BaseField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BaseField findUnique
   */
  export type BaseFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * Filter, which BaseField to fetch.
     */
    where: BaseFieldWhereUniqueInput
  }

  /**
   * BaseField findUniqueOrThrow
   */
  export type BaseFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * Filter, which BaseField to fetch.
     */
    where: BaseFieldWhereUniqueInput
  }

  /**
   * BaseField findFirst
   */
  export type BaseFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * Filter, which BaseField to fetch.
     */
    where?: BaseFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseFields to fetch.
     */
    orderBy?: BaseFieldOrderByWithRelationInput | BaseFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseFields.
     */
    cursor?: BaseFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseFields.
     */
    distinct?: BaseFieldScalarFieldEnum | BaseFieldScalarFieldEnum[]
  }

  /**
   * BaseField findFirstOrThrow
   */
  export type BaseFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * Filter, which BaseField to fetch.
     */
    where?: BaseFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseFields to fetch.
     */
    orderBy?: BaseFieldOrderByWithRelationInput | BaseFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseFields.
     */
    cursor?: BaseFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseFields.
     */
    distinct?: BaseFieldScalarFieldEnum | BaseFieldScalarFieldEnum[]
  }

  /**
   * BaseField findMany
   */
  export type BaseFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * Filter, which BaseFields to fetch.
     */
    where?: BaseFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseFields to fetch.
     */
    orderBy?: BaseFieldOrderByWithRelationInput | BaseFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaseFields.
     */
    cursor?: BaseFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseFields.
     */
    skip?: number
    distinct?: BaseFieldScalarFieldEnum | BaseFieldScalarFieldEnum[]
  }

  /**
   * BaseField create
   */
  export type BaseFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * The data needed to create a BaseField.
     */
    data: XOR<BaseFieldCreateInput, BaseFieldUncheckedCreateInput>
  }

  /**
   * BaseField createMany
   */
  export type BaseFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaseFields.
     */
    data: BaseFieldCreateManyInput | BaseFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseField createManyAndReturn
   */
  export type BaseFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * The data used to create many BaseFields.
     */
    data: BaseFieldCreateManyInput | BaseFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseField update
   */
  export type BaseFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * The data needed to update a BaseField.
     */
    data: XOR<BaseFieldUpdateInput, BaseFieldUncheckedUpdateInput>
    /**
     * Choose, which BaseField to update.
     */
    where: BaseFieldWhereUniqueInput
  }

  /**
   * BaseField updateMany
   */
  export type BaseFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaseFields.
     */
    data: XOR<BaseFieldUpdateManyMutationInput, BaseFieldUncheckedUpdateManyInput>
    /**
     * Filter which BaseFields to update
     */
    where?: BaseFieldWhereInput
    /**
     * Limit how many BaseFields to update.
     */
    limit?: number
  }

  /**
   * BaseField updateManyAndReturn
   */
  export type BaseFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * The data used to update BaseFields.
     */
    data: XOR<BaseFieldUpdateManyMutationInput, BaseFieldUncheckedUpdateManyInput>
    /**
     * Filter which BaseFields to update
     */
    where?: BaseFieldWhereInput
    /**
     * Limit how many BaseFields to update.
     */
    limit?: number
  }

  /**
   * BaseField upsert
   */
  export type BaseFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * The filter to search for the BaseField to update in case it exists.
     */
    where: BaseFieldWhereUniqueInput
    /**
     * In case the BaseField found by the `where` argument doesn't exist, create a new BaseField with this data.
     */
    create: XOR<BaseFieldCreateInput, BaseFieldUncheckedCreateInput>
    /**
     * In case the BaseField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaseFieldUpdateInput, BaseFieldUncheckedUpdateInput>
  }

  /**
   * BaseField delete
   */
  export type BaseFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
    /**
     * Filter which BaseField to delete.
     */
    where: BaseFieldWhereUniqueInput
  }

  /**
   * BaseField deleteMany
   */
  export type BaseFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseFields to delete
     */
    where?: BaseFieldWhereInput
    /**
     * Limit how many BaseFields to delete.
     */
    limit?: number
  }

  /**
   * BaseField without action
   */
  export type BaseFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseField
     */
    select?: BaseFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseField
     */
    omit?: BaseFieldOmit<ExtArgs> | null
  }


  /**
   * Model BaseGroupLevel
   */

  export type AggregateBaseGroupLevel = {
    _count: BaseGroupLevelCountAggregateOutputType | null
    _avg: BaseGroupLevelAvgAggregateOutputType | null
    _sum: BaseGroupLevelSumAggregateOutputType | null
    _min: BaseGroupLevelMinAggregateOutputType | null
    _max: BaseGroupLevelMaxAggregateOutputType | null
  }

  export type BaseGroupLevelAvgAggregateOutputType = {
    id: Decimal | null
    minAge: number | null
    maxAge: number | null
    ord: number | null
  }

  export type BaseGroupLevelSumAggregateOutputType = {
    id: Decimal | null
    minAge: number | null
    maxAge: number | null
    ord: number | null
  }

  export type BaseGroupLevelMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    note: string | null
    minAge: number | null
    maxAge: number | null
    skillLevel: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseGroupLevelMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    note: string | null
    minAge: number | null
    maxAge: number | null
    skillLevel: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseGroupLevelCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    note: number
    minAge: number
    maxAge: number
    skillLevel: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BaseGroupLevelAvgAggregateInputType = {
    id?: true
    minAge?: true
    maxAge?: true
    ord?: true
  }

  export type BaseGroupLevelSumAggregateInputType = {
    id?: true
    minAge?: true
    maxAge?: true
    ord?: true
  }

  export type BaseGroupLevelMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    minAge?: true
    maxAge?: true
    skillLevel?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseGroupLevelMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    minAge?: true
    maxAge?: true
    skillLevel?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseGroupLevelCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    minAge?: true
    maxAge?: true
    skillLevel?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BaseGroupLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseGroupLevel to aggregate.
     */
    where?: BaseGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseGroupLevels to fetch.
     */
    orderBy?: BaseGroupLevelOrderByWithRelationInput | BaseGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaseGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseGroupLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaseGroupLevels
    **/
    _count?: true | BaseGroupLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseGroupLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseGroupLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseGroupLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseGroupLevelMaxAggregateInputType
  }

  export type GetBaseGroupLevelAggregateType<T extends BaseGroupLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseGroupLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseGroupLevel[P]>
      : GetScalarType<T[P], AggregateBaseGroupLevel[P]>
  }




  export type BaseGroupLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseGroupLevelWhereInput
    orderBy?: BaseGroupLevelOrderByWithAggregationInput | BaseGroupLevelOrderByWithAggregationInput[]
    by: BaseGroupLevelScalarFieldEnum[] | BaseGroupLevelScalarFieldEnum
    having?: BaseGroupLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseGroupLevelCountAggregateInputType | true
    _avg?: BaseGroupLevelAvgAggregateInputType
    _sum?: BaseGroupLevelSumAggregateInputType
    _min?: BaseGroupLevelMinAggregateInputType
    _max?: BaseGroupLevelMaxAggregateInputType
  }

  export type BaseGroupLevelGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string | null
    note: string | null
    minAge: number | null
    maxAge: number | null
    skillLevel: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BaseGroupLevelCountAggregateOutputType | null
    _avg: BaseGroupLevelAvgAggregateOutputType | null
    _sum: BaseGroupLevelSumAggregateOutputType | null
    _min: BaseGroupLevelMinAggregateOutputType | null
    _max: BaseGroupLevelMaxAggregateOutputType | null
  }

  type GetBaseGroupLevelGroupByPayload<T extends BaseGroupLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaseGroupLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseGroupLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseGroupLevelGroupByOutputType[P]>
            : GetScalarType<T[P], BaseGroupLevelGroupByOutputType[P]>
        }
      >
    >


  export type BaseGroupLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    minAge?: boolean
    maxAge?: boolean
    skillLevel?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseGroupLevel"]>

  export type BaseGroupLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    minAge?: boolean
    maxAge?: boolean
    skillLevel?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseGroupLevel"]>

  export type BaseGroupLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    minAge?: boolean
    maxAge?: boolean
    skillLevel?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseGroupLevel"]>

  export type BaseGroupLevelSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    minAge?: boolean
    maxAge?: boolean
    skillLevel?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BaseGroupLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "note" | "minAge" | "maxAge" | "skillLevel" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["baseGroupLevel"]>

  export type $BaseGroupLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaseGroupLevel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string | null
      note: string | null
      minAge: number | null
      maxAge: number | null
      skillLevel: string | null
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["baseGroupLevel"]>
    composites: {}
  }

  type BaseGroupLevelGetPayload<S extends boolean | null | undefined | BaseGroupLevelDefaultArgs> = $Result.GetResult<Prisma.$BaseGroupLevelPayload, S>

  type BaseGroupLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BaseGroupLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BaseGroupLevelCountAggregateInputType | true
    }

  export interface BaseGroupLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaseGroupLevel'], meta: { name: 'BaseGroupLevel' } }
    /**
     * Find zero or one BaseGroupLevel that matches the filter.
     * @param {BaseGroupLevelFindUniqueArgs} args - Arguments to find a BaseGroupLevel
     * @example
     * // Get one BaseGroupLevel
     * const baseGroupLevel = await prisma.baseGroupLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaseGroupLevelFindUniqueArgs>(args: SelectSubset<T, BaseGroupLevelFindUniqueArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BaseGroupLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BaseGroupLevelFindUniqueOrThrowArgs} args - Arguments to find a BaseGroupLevel
     * @example
     * // Get one BaseGroupLevel
     * const baseGroupLevel = await prisma.baseGroupLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaseGroupLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, BaseGroupLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseGroupLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelFindFirstArgs} args - Arguments to find a BaseGroupLevel
     * @example
     * // Get one BaseGroupLevel
     * const baseGroupLevel = await prisma.baseGroupLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaseGroupLevelFindFirstArgs>(args?: SelectSubset<T, BaseGroupLevelFindFirstArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseGroupLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelFindFirstOrThrowArgs} args - Arguments to find a BaseGroupLevel
     * @example
     * // Get one BaseGroupLevel
     * const baseGroupLevel = await prisma.baseGroupLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaseGroupLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, BaseGroupLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BaseGroupLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseGroupLevels
     * const baseGroupLevels = await prisma.baseGroupLevel.findMany()
     * 
     * // Get first 10 BaseGroupLevels
     * const baseGroupLevels = await prisma.baseGroupLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseGroupLevelWithIdOnly = await prisma.baseGroupLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaseGroupLevelFindManyArgs>(args?: SelectSubset<T, BaseGroupLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BaseGroupLevel.
     * @param {BaseGroupLevelCreateArgs} args - Arguments to create a BaseGroupLevel.
     * @example
     * // Create one BaseGroupLevel
     * const BaseGroupLevel = await prisma.baseGroupLevel.create({
     *   data: {
     *     // ... data to create a BaseGroupLevel
     *   }
     * })
     * 
     */
    create<T extends BaseGroupLevelCreateArgs>(args: SelectSubset<T, BaseGroupLevelCreateArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BaseGroupLevels.
     * @param {BaseGroupLevelCreateManyArgs} args - Arguments to create many BaseGroupLevels.
     * @example
     * // Create many BaseGroupLevels
     * const baseGroupLevel = await prisma.baseGroupLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaseGroupLevelCreateManyArgs>(args?: SelectSubset<T, BaseGroupLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BaseGroupLevels and returns the data saved in the database.
     * @param {BaseGroupLevelCreateManyAndReturnArgs} args - Arguments to create many BaseGroupLevels.
     * @example
     * // Create many BaseGroupLevels
     * const baseGroupLevel = await prisma.baseGroupLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BaseGroupLevels and only return the `id`
     * const baseGroupLevelWithIdOnly = await prisma.baseGroupLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BaseGroupLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, BaseGroupLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BaseGroupLevel.
     * @param {BaseGroupLevelDeleteArgs} args - Arguments to delete one BaseGroupLevel.
     * @example
     * // Delete one BaseGroupLevel
     * const BaseGroupLevel = await prisma.baseGroupLevel.delete({
     *   where: {
     *     // ... filter to delete one BaseGroupLevel
     *   }
     * })
     * 
     */
    delete<T extends BaseGroupLevelDeleteArgs>(args: SelectSubset<T, BaseGroupLevelDeleteArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BaseGroupLevel.
     * @param {BaseGroupLevelUpdateArgs} args - Arguments to update one BaseGroupLevel.
     * @example
     * // Update one BaseGroupLevel
     * const baseGroupLevel = await prisma.baseGroupLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaseGroupLevelUpdateArgs>(args: SelectSubset<T, BaseGroupLevelUpdateArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BaseGroupLevels.
     * @param {BaseGroupLevelDeleteManyArgs} args - Arguments to filter BaseGroupLevels to delete.
     * @example
     * // Delete a few BaseGroupLevels
     * const { count } = await prisma.baseGroupLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaseGroupLevelDeleteManyArgs>(args?: SelectSubset<T, BaseGroupLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseGroupLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseGroupLevels
     * const baseGroupLevel = await prisma.baseGroupLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaseGroupLevelUpdateManyArgs>(args: SelectSubset<T, BaseGroupLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseGroupLevels and returns the data updated in the database.
     * @param {BaseGroupLevelUpdateManyAndReturnArgs} args - Arguments to update many BaseGroupLevels.
     * @example
     * // Update many BaseGroupLevels
     * const baseGroupLevel = await prisma.baseGroupLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BaseGroupLevels and only return the `id`
     * const baseGroupLevelWithIdOnly = await prisma.baseGroupLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BaseGroupLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, BaseGroupLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BaseGroupLevel.
     * @param {BaseGroupLevelUpsertArgs} args - Arguments to update or create a BaseGroupLevel.
     * @example
     * // Update or create a BaseGroupLevel
     * const baseGroupLevel = await prisma.baseGroupLevel.upsert({
     *   create: {
     *     // ... data to create a BaseGroupLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseGroupLevel we want to update
     *   }
     * })
     */
    upsert<T extends BaseGroupLevelUpsertArgs>(args: SelectSubset<T, BaseGroupLevelUpsertArgs<ExtArgs>>): Prisma__BaseGroupLevelClient<$Result.GetResult<Prisma.$BaseGroupLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BaseGroupLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelCountArgs} args - Arguments to filter BaseGroupLevels to count.
     * @example
     * // Count the number of BaseGroupLevels
     * const count = await prisma.baseGroupLevel.count({
     *   where: {
     *     // ... the filter for the BaseGroupLevels we want to count
     *   }
     * })
    **/
    count<T extends BaseGroupLevelCountArgs>(
      args?: Subset<T, BaseGroupLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseGroupLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseGroupLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseGroupLevelAggregateArgs>(args: Subset<T, BaseGroupLevelAggregateArgs>): Prisma.PrismaPromise<GetBaseGroupLevelAggregateType<T>>

    /**
     * Group by BaseGroupLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseGroupLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseGroupLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseGroupLevelGroupByArgs['orderBy'] }
        : { orderBy?: BaseGroupLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseGroupLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseGroupLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaseGroupLevel model
   */
  readonly fields: BaseGroupLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaseGroupLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaseGroupLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaseGroupLevel model
   */
  interface BaseGroupLevelFieldRefs {
    readonly id: FieldRef<"BaseGroupLevel", 'Decimal'>
    readonly name: FieldRef<"BaseGroupLevel", 'String'>
    readonly abbr: FieldRef<"BaseGroupLevel", 'String'>
    readonly note: FieldRef<"BaseGroupLevel", 'String'>
    readonly minAge: FieldRef<"BaseGroupLevel", 'Int'>
    readonly maxAge: FieldRef<"BaseGroupLevel", 'Int'>
    readonly skillLevel: FieldRef<"BaseGroupLevel", 'String'>
    readonly ord: FieldRef<"BaseGroupLevel", 'Int'>
    readonly createdAt: FieldRef<"BaseGroupLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"BaseGroupLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BaseGroupLevel findUnique
   */
  export type BaseGroupLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which BaseGroupLevel to fetch.
     */
    where: BaseGroupLevelWhereUniqueInput
  }

  /**
   * BaseGroupLevel findUniqueOrThrow
   */
  export type BaseGroupLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which BaseGroupLevel to fetch.
     */
    where: BaseGroupLevelWhereUniqueInput
  }

  /**
   * BaseGroupLevel findFirst
   */
  export type BaseGroupLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which BaseGroupLevel to fetch.
     */
    where?: BaseGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseGroupLevels to fetch.
     */
    orderBy?: BaseGroupLevelOrderByWithRelationInput | BaseGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseGroupLevels.
     */
    cursor?: BaseGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseGroupLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseGroupLevels.
     */
    distinct?: BaseGroupLevelScalarFieldEnum | BaseGroupLevelScalarFieldEnum[]
  }

  /**
   * BaseGroupLevel findFirstOrThrow
   */
  export type BaseGroupLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which BaseGroupLevel to fetch.
     */
    where?: BaseGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseGroupLevels to fetch.
     */
    orderBy?: BaseGroupLevelOrderByWithRelationInput | BaseGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseGroupLevels.
     */
    cursor?: BaseGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseGroupLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseGroupLevels.
     */
    distinct?: BaseGroupLevelScalarFieldEnum | BaseGroupLevelScalarFieldEnum[]
  }

  /**
   * BaseGroupLevel findMany
   */
  export type BaseGroupLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which BaseGroupLevels to fetch.
     */
    where?: BaseGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseGroupLevels to fetch.
     */
    orderBy?: BaseGroupLevelOrderByWithRelationInput | BaseGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaseGroupLevels.
     */
    cursor?: BaseGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseGroupLevels.
     */
    skip?: number
    distinct?: BaseGroupLevelScalarFieldEnum | BaseGroupLevelScalarFieldEnum[]
  }

  /**
   * BaseGroupLevel create
   */
  export type BaseGroupLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * The data needed to create a BaseGroupLevel.
     */
    data: XOR<BaseGroupLevelCreateInput, BaseGroupLevelUncheckedCreateInput>
  }

  /**
   * BaseGroupLevel createMany
   */
  export type BaseGroupLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaseGroupLevels.
     */
    data: BaseGroupLevelCreateManyInput | BaseGroupLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseGroupLevel createManyAndReturn
   */
  export type BaseGroupLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * The data used to create many BaseGroupLevels.
     */
    data: BaseGroupLevelCreateManyInput | BaseGroupLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseGroupLevel update
   */
  export type BaseGroupLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * The data needed to update a BaseGroupLevel.
     */
    data: XOR<BaseGroupLevelUpdateInput, BaseGroupLevelUncheckedUpdateInput>
    /**
     * Choose, which BaseGroupLevel to update.
     */
    where: BaseGroupLevelWhereUniqueInput
  }

  /**
   * BaseGroupLevel updateMany
   */
  export type BaseGroupLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaseGroupLevels.
     */
    data: XOR<BaseGroupLevelUpdateManyMutationInput, BaseGroupLevelUncheckedUpdateManyInput>
    /**
     * Filter which BaseGroupLevels to update
     */
    where?: BaseGroupLevelWhereInput
    /**
     * Limit how many BaseGroupLevels to update.
     */
    limit?: number
  }

  /**
   * BaseGroupLevel updateManyAndReturn
   */
  export type BaseGroupLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * The data used to update BaseGroupLevels.
     */
    data: XOR<BaseGroupLevelUpdateManyMutationInput, BaseGroupLevelUncheckedUpdateManyInput>
    /**
     * Filter which BaseGroupLevels to update
     */
    where?: BaseGroupLevelWhereInput
    /**
     * Limit how many BaseGroupLevels to update.
     */
    limit?: number
  }

  /**
   * BaseGroupLevel upsert
   */
  export type BaseGroupLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * The filter to search for the BaseGroupLevel to update in case it exists.
     */
    where: BaseGroupLevelWhereUniqueInput
    /**
     * In case the BaseGroupLevel found by the `where` argument doesn't exist, create a new BaseGroupLevel with this data.
     */
    create: XOR<BaseGroupLevelCreateInput, BaseGroupLevelUncheckedCreateInput>
    /**
     * In case the BaseGroupLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaseGroupLevelUpdateInput, BaseGroupLevelUncheckedUpdateInput>
  }

  /**
   * BaseGroupLevel delete
   */
  export type BaseGroupLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
    /**
     * Filter which BaseGroupLevel to delete.
     */
    where: BaseGroupLevelWhereUniqueInput
  }

  /**
   * BaseGroupLevel deleteMany
   */
  export type BaseGroupLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseGroupLevels to delete
     */
    where?: BaseGroupLevelWhereInput
    /**
     * Limit how many BaseGroupLevels to delete.
     */
    limit?: number
  }

  /**
   * BaseGroupLevel without action
   */
  export type BaseGroupLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseGroupLevel
     */
    select?: BaseGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseGroupLevel
     */
    omit?: BaseGroupLevelOmit<ExtArgs> | null
  }


  /**
   * Model BaseSport
   */

  export type AggregateBaseSport = {
    _count: BaseSportCountAggregateOutputType | null
    _avg: BaseSportAvgAggregateOutputType | null
    _sum: BaseSportSumAggregateOutputType | null
    _min: BaseSportMinAggregateOutputType | null
    _max: BaseSportMaxAggregateOutputType | null
  }

  export type BaseSportAvgAggregateOutputType = {
    id: number | null
    ord: number | null
  }

  export type BaseSportSumAggregateOutputType = {
    id: number | null
    ord: number | null
  }

  export type BaseSportMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbr: string | null
    note: string | null
    isActive: boolean | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseSportMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbr: string | null
    note: string | null
    isActive: boolean | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseSportCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    note: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BaseSportAvgAggregateInputType = {
    id?: true
    ord?: true
  }

  export type BaseSportSumAggregateInputType = {
    id?: true
    ord?: true
  }

  export type BaseSportMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseSportMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseSportCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BaseSportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseSport to aggregate.
     */
    where?: BaseSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseSports to fetch.
     */
    orderBy?: BaseSportOrderByWithRelationInput | BaseSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaseSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaseSports
    **/
    _count?: true | BaseSportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseSportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseSportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseSportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseSportMaxAggregateInputType
  }

  export type GetBaseSportAggregateType<T extends BaseSportAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseSport[P]>
      : GetScalarType<T[P], AggregateBaseSport[P]>
  }




  export type BaseSportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaseSportWhereInput
    orderBy?: BaseSportOrderByWithAggregationInput | BaseSportOrderByWithAggregationInput[]
    by: BaseSportScalarFieldEnum[] | BaseSportScalarFieldEnum
    having?: BaseSportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseSportCountAggregateInputType | true
    _avg?: BaseSportAvgAggregateInputType
    _sum?: BaseSportSumAggregateInputType
    _min?: BaseSportMinAggregateInputType
    _max?: BaseSportMaxAggregateInputType
  }

  export type BaseSportGroupByOutputType = {
    id: number
    name: string
    abbr: string | null
    note: string | null
    isActive: boolean
    ord: number
    createdAt: Date
    updatedAt: Date
    _count: BaseSportCountAggregateOutputType | null
    _avg: BaseSportAvgAggregateOutputType | null
    _sum: BaseSportSumAggregateOutputType | null
    _min: BaseSportMinAggregateOutputType | null
    _max: BaseSportMaxAggregateOutputType | null
  }

  type GetBaseSportGroupByPayload<T extends BaseSportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaseSportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseSportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseSportGroupByOutputType[P]>
            : GetScalarType<T[P], BaseSportGroupByOutputType[P]>
        }
      >
    >


  export type BaseSportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseSport"]>

  export type BaseSportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseSport"]>

  export type BaseSportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["baseSport"]>

  export type BaseSportSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BaseSportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "note" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["baseSport"]>

  export type $BaseSportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaseSport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      abbr: string | null
      note: string | null
      isActive: boolean
      ord: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["baseSport"]>
    composites: {}
  }

  type BaseSportGetPayload<S extends boolean | null | undefined | BaseSportDefaultArgs> = $Result.GetResult<Prisma.$BaseSportPayload, S>

  type BaseSportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BaseSportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BaseSportCountAggregateInputType | true
    }

  export interface BaseSportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaseSport'], meta: { name: 'BaseSport' } }
    /**
     * Find zero or one BaseSport that matches the filter.
     * @param {BaseSportFindUniqueArgs} args - Arguments to find a BaseSport
     * @example
     * // Get one BaseSport
     * const baseSport = await prisma.baseSport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaseSportFindUniqueArgs>(args: SelectSubset<T, BaseSportFindUniqueArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BaseSport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BaseSportFindUniqueOrThrowArgs} args - Arguments to find a BaseSport
     * @example
     * // Get one BaseSport
     * const baseSport = await prisma.baseSport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaseSportFindUniqueOrThrowArgs>(args: SelectSubset<T, BaseSportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseSport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportFindFirstArgs} args - Arguments to find a BaseSport
     * @example
     * // Get one BaseSport
     * const baseSport = await prisma.baseSport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaseSportFindFirstArgs>(args?: SelectSubset<T, BaseSportFindFirstArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BaseSport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportFindFirstOrThrowArgs} args - Arguments to find a BaseSport
     * @example
     * // Get one BaseSport
     * const baseSport = await prisma.baseSport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaseSportFindFirstOrThrowArgs>(args?: SelectSubset<T, BaseSportFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BaseSports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseSports
     * const baseSports = await prisma.baseSport.findMany()
     * 
     * // Get first 10 BaseSports
     * const baseSports = await prisma.baseSport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseSportWithIdOnly = await prisma.baseSport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaseSportFindManyArgs>(args?: SelectSubset<T, BaseSportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BaseSport.
     * @param {BaseSportCreateArgs} args - Arguments to create a BaseSport.
     * @example
     * // Create one BaseSport
     * const BaseSport = await prisma.baseSport.create({
     *   data: {
     *     // ... data to create a BaseSport
     *   }
     * })
     * 
     */
    create<T extends BaseSportCreateArgs>(args: SelectSubset<T, BaseSportCreateArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BaseSports.
     * @param {BaseSportCreateManyArgs} args - Arguments to create many BaseSports.
     * @example
     * // Create many BaseSports
     * const baseSport = await prisma.baseSport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaseSportCreateManyArgs>(args?: SelectSubset<T, BaseSportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BaseSports and returns the data saved in the database.
     * @param {BaseSportCreateManyAndReturnArgs} args - Arguments to create many BaseSports.
     * @example
     * // Create many BaseSports
     * const baseSport = await prisma.baseSport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BaseSports and only return the `id`
     * const baseSportWithIdOnly = await prisma.baseSport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BaseSportCreateManyAndReturnArgs>(args?: SelectSubset<T, BaseSportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BaseSport.
     * @param {BaseSportDeleteArgs} args - Arguments to delete one BaseSport.
     * @example
     * // Delete one BaseSport
     * const BaseSport = await prisma.baseSport.delete({
     *   where: {
     *     // ... filter to delete one BaseSport
     *   }
     * })
     * 
     */
    delete<T extends BaseSportDeleteArgs>(args: SelectSubset<T, BaseSportDeleteArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BaseSport.
     * @param {BaseSportUpdateArgs} args - Arguments to update one BaseSport.
     * @example
     * // Update one BaseSport
     * const baseSport = await prisma.baseSport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaseSportUpdateArgs>(args: SelectSubset<T, BaseSportUpdateArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BaseSports.
     * @param {BaseSportDeleteManyArgs} args - Arguments to filter BaseSports to delete.
     * @example
     * // Delete a few BaseSports
     * const { count } = await prisma.baseSport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaseSportDeleteManyArgs>(args?: SelectSubset<T, BaseSportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseSports
     * const baseSport = await prisma.baseSport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaseSportUpdateManyArgs>(args: SelectSubset<T, BaseSportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseSports and returns the data updated in the database.
     * @param {BaseSportUpdateManyAndReturnArgs} args - Arguments to update many BaseSports.
     * @example
     * // Update many BaseSports
     * const baseSport = await prisma.baseSport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BaseSports and only return the `id`
     * const baseSportWithIdOnly = await prisma.baseSport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BaseSportUpdateManyAndReturnArgs>(args: SelectSubset<T, BaseSportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BaseSport.
     * @param {BaseSportUpsertArgs} args - Arguments to update or create a BaseSport.
     * @example
     * // Update or create a BaseSport
     * const baseSport = await prisma.baseSport.upsert({
     *   create: {
     *     // ... data to create a BaseSport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseSport we want to update
     *   }
     * })
     */
    upsert<T extends BaseSportUpsertArgs>(args: SelectSubset<T, BaseSportUpsertArgs<ExtArgs>>): Prisma__BaseSportClient<$Result.GetResult<Prisma.$BaseSportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BaseSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportCountArgs} args - Arguments to filter BaseSports to count.
     * @example
     * // Count the number of BaseSports
     * const count = await prisma.baseSport.count({
     *   where: {
     *     // ... the filter for the BaseSports we want to count
     *   }
     * })
    **/
    count<T extends BaseSportCountArgs>(
      args?: Subset<T, BaseSportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseSportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseSportAggregateArgs>(args: Subset<T, BaseSportAggregateArgs>): Prisma.PrismaPromise<GetBaseSportAggregateType<T>>

    /**
     * Group by BaseSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseSportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseSportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseSportGroupByArgs['orderBy'] }
        : { orderBy?: BaseSportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseSportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaseSport model
   */
  readonly fields: BaseSportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaseSport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaseSportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaseSport model
   */
  interface BaseSportFieldRefs {
    readonly id: FieldRef<"BaseSport", 'Int'>
    readonly name: FieldRef<"BaseSport", 'String'>
    readonly abbr: FieldRef<"BaseSport", 'String'>
    readonly note: FieldRef<"BaseSport", 'String'>
    readonly isActive: FieldRef<"BaseSport", 'Boolean'>
    readonly ord: FieldRef<"BaseSport", 'Int'>
    readonly createdAt: FieldRef<"BaseSport", 'DateTime'>
    readonly updatedAt: FieldRef<"BaseSport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BaseSport findUnique
   */
  export type BaseSportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * Filter, which BaseSport to fetch.
     */
    where: BaseSportWhereUniqueInput
  }

  /**
   * BaseSport findUniqueOrThrow
   */
  export type BaseSportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * Filter, which BaseSport to fetch.
     */
    where: BaseSportWhereUniqueInput
  }

  /**
   * BaseSport findFirst
   */
  export type BaseSportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * Filter, which BaseSport to fetch.
     */
    where?: BaseSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseSports to fetch.
     */
    orderBy?: BaseSportOrderByWithRelationInput | BaseSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseSports.
     */
    cursor?: BaseSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseSports.
     */
    distinct?: BaseSportScalarFieldEnum | BaseSportScalarFieldEnum[]
  }

  /**
   * BaseSport findFirstOrThrow
   */
  export type BaseSportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * Filter, which BaseSport to fetch.
     */
    where?: BaseSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseSports to fetch.
     */
    orderBy?: BaseSportOrderByWithRelationInput | BaseSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaseSports.
     */
    cursor?: BaseSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaseSports.
     */
    distinct?: BaseSportScalarFieldEnum | BaseSportScalarFieldEnum[]
  }

  /**
   * BaseSport findMany
   */
  export type BaseSportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * Filter, which BaseSports to fetch.
     */
    where?: BaseSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaseSports to fetch.
     */
    orderBy?: BaseSportOrderByWithRelationInput | BaseSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaseSports.
     */
    cursor?: BaseSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaseSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaseSports.
     */
    skip?: number
    distinct?: BaseSportScalarFieldEnum | BaseSportScalarFieldEnum[]
  }

  /**
   * BaseSport create
   */
  export type BaseSportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * The data needed to create a BaseSport.
     */
    data: XOR<BaseSportCreateInput, BaseSportUncheckedCreateInput>
  }

  /**
   * BaseSport createMany
   */
  export type BaseSportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaseSports.
     */
    data: BaseSportCreateManyInput | BaseSportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseSport createManyAndReturn
   */
  export type BaseSportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * The data used to create many BaseSports.
     */
    data: BaseSportCreateManyInput | BaseSportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaseSport update
   */
  export type BaseSportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * The data needed to update a BaseSport.
     */
    data: XOR<BaseSportUpdateInput, BaseSportUncheckedUpdateInput>
    /**
     * Choose, which BaseSport to update.
     */
    where: BaseSportWhereUniqueInput
  }

  /**
   * BaseSport updateMany
   */
  export type BaseSportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaseSports.
     */
    data: XOR<BaseSportUpdateManyMutationInput, BaseSportUncheckedUpdateManyInput>
    /**
     * Filter which BaseSports to update
     */
    where?: BaseSportWhereInput
    /**
     * Limit how many BaseSports to update.
     */
    limit?: number
  }

  /**
   * BaseSport updateManyAndReturn
   */
  export type BaseSportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * The data used to update BaseSports.
     */
    data: XOR<BaseSportUpdateManyMutationInput, BaseSportUncheckedUpdateManyInput>
    /**
     * Filter which BaseSports to update
     */
    where?: BaseSportWhereInput
    /**
     * Limit how many BaseSports to update.
     */
    limit?: number
  }

  /**
   * BaseSport upsert
   */
  export type BaseSportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * The filter to search for the BaseSport to update in case it exists.
     */
    where: BaseSportWhereUniqueInput
    /**
     * In case the BaseSport found by the `where` argument doesn't exist, create a new BaseSport with this data.
     */
    create: XOR<BaseSportCreateInput, BaseSportUncheckedCreateInput>
    /**
     * In case the BaseSport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaseSportUpdateInput, BaseSportUncheckedUpdateInput>
  }

  /**
   * BaseSport delete
   */
  export type BaseSportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
    /**
     * Filter which BaseSport to delete.
     */
    where: BaseSportWhereUniqueInput
  }

  /**
   * BaseSport deleteMany
   */
  export type BaseSportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaseSports to delete
     */
    where?: BaseSportWhereInput
    /**
     * Limit how many BaseSports to delete.
     */
    limit?: number
  }

  /**
   * BaseSport without action
   */
  export type BaseSportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaseSport
     */
    select?: BaseSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BaseSport
     */
    omit?: BaseSportOmit<ExtArgs> | null
  }


  /**
   * Model GameEvent
   */

  export type AggregateGameEvent = {
    _count: GameEventCountAggregateOutputType | null
    _avg: GameEventAvgAggregateOutputType | null
    _sum: GameEventSumAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  export type GameEventAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    competitionId: Decimal | null
  }

  export type GameEventSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    competitionId: Decimal | null
  }

  export type GameEventMinAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    competitionId: Decimal | null
    eventDate: Date | null
    venue: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameEventMaxAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    competitionId: Decimal | null
    eventDate: Date | null
    venue: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameEventCountAggregateOutputType = {
    id: number
    sportId: number
    competitionId: number
    eventDate: number
    venue: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameEventAvgAggregateInputType = {
    id?: true
    sportId?: true
    competitionId?: true
  }

  export type GameEventSumAggregateInputType = {
    id?: true
    sportId?: true
    competitionId?: true
  }

  export type GameEventMinAggregateInputType = {
    id?: true
    sportId?: true
    competitionId?: true
    eventDate?: true
    venue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameEventMaxAggregateInputType = {
    id?: true
    sportId?: true
    competitionId?: true
    eventDate?: true
    venue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameEventCountAggregateInputType = {
    id?: true
    sportId?: true
    competitionId?: true
    eventDate?: true
    venue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvent to aggregate.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameEvents
    **/
    _count?: true | GameEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameEventMaxAggregateInputType
  }

  export type GetGameEventAggregateType<T extends GameEventAggregateArgs> = {
        [P in keyof T & keyof AggregateGameEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameEvent[P]>
      : GetScalarType<T[P], AggregateGameEvent[P]>
  }




  export type GameEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameEventWhereInput
    orderBy?: GameEventOrderByWithAggregationInput | GameEventOrderByWithAggregationInput[]
    by: GameEventScalarFieldEnum[] | GameEventScalarFieldEnum
    having?: GameEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameEventCountAggregateInputType | true
    _avg?: GameEventAvgAggregateInputType
    _sum?: GameEventSumAggregateInputType
    _min?: GameEventMinAggregateInputType
    _max?: GameEventMaxAggregateInputType
  }

  export type GameEventGroupByOutputType = {
    id: Decimal
    sportId: Decimal
    competitionId: Decimal | null
    eventDate: Date
    venue: string | null
    status: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: GameEventCountAggregateOutputType | null
    _avg: GameEventAvgAggregateOutputType | null
    _sum: GameEventSumAggregateOutputType | null
    _min: GameEventMinAggregateOutputType | null
    _max: GameEventMaxAggregateOutputType | null
  }

  type GetGameEventGroupByPayload<T extends GameEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameEventGroupByOutputType[P]>
            : GetScalarType<T[P], GameEventGroupByOutputType[P]>
        }
      >
    >


  export type GameEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    competitionId?: boolean
    eventDate?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    competitionId?: boolean
    eventDate?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    competitionId?: boolean
    eventDate?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameEvent"]>

  export type GameEventSelectScalar = {
    id?: boolean
    sportId?: boolean
    competitionId?: boolean
    eventDate?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "competitionId" | "eventDate" | "venue" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["gameEvent"]>

  export type $GameEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sportId: Prisma.Decimal
      competitionId: Prisma.Decimal | null
      eventDate: Date
      venue: string | null
      status: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["gameEvent"]>
    composites: {}
  }

  type GameEventGetPayload<S extends boolean | null | undefined | GameEventDefaultArgs> = $Result.GetResult<Prisma.$GameEventPayload, S>

  type GameEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameEventCountAggregateInputType | true
    }

  export interface GameEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameEvent'], meta: { name: 'GameEvent' } }
    /**
     * Find zero or one GameEvent that matches the filter.
     * @param {GameEventFindUniqueArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameEventFindUniqueArgs>(args: SelectSubset<T, GameEventFindUniqueArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameEventFindUniqueOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameEventFindUniqueOrThrowArgs>(args: SelectSubset<T, GameEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameEventFindFirstArgs>(args?: SelectSubset<T, GameEventFindFirstArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindFirstOrThrowArgs} args - Arguments to find a GameEvent
     * @example
     * // Get one GameEvent
     * const gameEvent = await prisma.gameEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameEventFindFirstOrThrowArgs>(args?: SelectSubset<T, GameEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameEvents
     * const gameEvents = await prisma.gameEvent.findMany()
     * 
     * // Get first 10 GameEvents
     * const gameEvents = await prisma.gameEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameEventFindManyArgs>(args?: SelectSubset<T, GameEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameEvent.
     * @param {GameEventCreateArgs} args - Arguments to create a GameEvent.
     * @example
     * // Create one GameEvent
     * const GameEvent = await prisma.gameEvent.create({
     *   data: {
     *     // ... data to create a GameEvent
     *   }
     * })
     * 
     */
    create<T extends GameEventCreateArgs>(args: SelectSubset<T, GameEventCreateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameEvents.
     * @param {GameEventCreateManyArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameEventCreateManyArgs>(args?: SelectSubset<T, GameEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameEvents and returns the data saved in the database.
     * @param {GameEventCreateManyAndReturnArgs} args - Arguments to create many GameEvents.
     * @example
     * // Create many GameEvents
     * const gameEvent = await prisma.gameEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameEventCreateManyAndReturnArgs>(args?: SelectSubset<T, GameEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameEvent.
     * @param {GameEventDeleteArgs} args - Arguments to delete one GameEvent.
     * @example
     * // Delete one GameEvent
     * const GameEvent = await prisma.gameEvent.delete({
     *   where: {
     *     // ... filter to delete one GameEvent
     *   }
     * })
     * 
     */
    delete<T extends GameEventDeleteArgs>(args: SelectSubset<T, GameEventDeleteArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameEvent.
     * @param {GameEventUpdateArgs} args - Arguments to update one GameEvent.
     * @example
     * // Update one GameEvent
     * const gameEvent = await prisma.gameEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameEventUpdateArgs>(args: SelectSubset<T, GameEventUpdateArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameEvents.
     * @param {GameEventDeleteManyArgs} args - Arguments to filter GameEvents to delete.
     * @example
     * // Delete a few GameEvents
     * const { count } = await prisma.gameEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameEventDeleteManyArgs>(args?: SelectSubset<T, GameEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameEventUpdateManyArgs>(args: SelectSubset<T, GameEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameEvents and returns the data updated in the database.
     * @param {GameEventUpdateManyAndReturnArgs} args - Arguments to update many GameEvents.
     * @example
     * // Update many GameEvents
     * const gameEvent = await prisma.gameEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameEvents and only return the `id`
     * const gameEventWithIdOnly = await prisma.gameEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameEventUpdateManyAndReturnArgs>(args: SelectSubset<T, GameEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameEvent.
     * @param {GameEventUpsertArgs} args - Arguments to update or create a GameEvent.
     * @example
     * // Update or create a GameEvent
     * const gameEvent = await prisma.gameEvent.upsert({
     *   create: {
     *     // ... data to create a GameEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameEvent we want to update
     *   }
     * })
     */
    upsert<T extends GameEventUpsertArgs>(args: SelectSubset<T, GameEventUpsertArgs<ExtArgs>>): Prisma__GameEventClient<$Result.GetResult<Prisma.$GameEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventCountArgs} args - Arguments to filter GameEvents to count.
     * @example
     * // Count the number of GameEvents
     * const count = await prisma.gameEvent.count({
     *   where: {
     *     // ... the filter for the GameEvents we want to count
     *   }
     * })
    **/
    count<T extends GameEventCountArgs>(
      args?: Subset<T, GameEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameEventAggregateArgs>(args: Subset<T, GameEventAggregateArgs>): Prisma.PrismaPromise<GetGameEventAggregateType<T>>

    /**
     * Group by GameEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameEventGroupByArgs['orderBy'] }
        : { orderBy?: GameEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameEvent model
   */
  readonly fields: GameEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameEvent model
   */
  interface GameEventFieldRefs {
    readonly id: FieldRef<"GameEvent", 'Decimal'>
    readonly sportId: FieldRef<"GameEvent", 'Decimal'>
    readonly competitionId: FieldRef<"GameEvent", 'Decimal'>
    readonly eventDate: FieldRef<"GameEvent", 'DateTime'>
    readonly venue: FieldRef<"GameEvent", 'String'>
    readonly status: FieldRef<"GameEvent", 'String'>
    readonly createdAt: FieldRef<"GameEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"GameEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameEvent findUnique
   */
  export type GameEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findUniqueOrThrow
   */
  export type GameEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent findFirst
   */
  export type GameEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findFirstOrThrow
   */
  export type GameEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Filter, which GameEvent to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameEvents.
     */
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent findMany
   */
  export type GameEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Filter, which GameEvents to fetch.
     */
    where?: GameEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameEvents to fetch.
     */
    orderBy?: GameEventOrderByWithRelationInput | GameEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameEvents.
     */
    cursor?: GameEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameEvents.
     */
    skip?: number
    distinct?: GameEventScalarFieldEnum | GameEventScalarFieldEnum[]
  }

  /**
   * GameEvent create
   */
  export type GameEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data needed to create a GameEvent.
     */
    data: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
  }

  /**
   * GameEvent createMany
   */
  export type GameEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameEvent createManyAndReturn
   */
  export type GameEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data used to create many GameEvents.
     */
    data: GameEventCreateManyInput | GameEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameEvent update
   */
  export type GameEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data needed to update a GameEvent.
     */
    data: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
    /**
     * Choose, which GameEvent to update.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent updateMany
   */
  export type GameEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
    /**
     * Limit how many GameEvents to update.
     */
    limit?: number
  }

  /**
   * GameEvent updateManyAndReturn
   */
  export type GameEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The data used to update GameEvents.
     */
    data: XOR<GameEventUpdateManyMutationInput, GameEventUncheckedUpdateManyInput>
    /**
     * Filter which GameEvents to update
     */
    where?: GameEventWhereInput
    /**
     * Limit how many GameEvents to update.
     */
    limit?: number
  }

  /**
   * GameEvent upsert
   */
  export type GameEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * The filter to search for the GameEvent to update in case it exists.
     */
    where: GameEventWhereUniqueInput
    /**
     * In case the GameEvent found by the `where` argument doesn't exist, create a new GameEvent with this data.
     */
    create: XOR<GameEventCreateInput, GameEventUncheckedCreateInput>
    /**
     * In case the GameEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameEventUpdateInput, GameEventUncheckedUpdateInput>
  }

  /**
   * GameEvent delete
   */
  export type GameEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
    /**
     * Filter which GameEvent to delete.
     */
    where: GameEventWhereUniqueInput
  }

  /**
   * GameEvent deleteMany
   */
  export type GameEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameEvents to delete
     */
    where?: GameEventWhereInput
    /**
     * Limit how many GameEvents to delete.
     */
    limit?: number
  }

  /**
   * GameEvent without action
   */
  export type GameEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameEvent
     */
    select?: GameEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameEvent
     */
    omit?: GameEventOmit<ExtArgs> | null
  }


  /**
   * Model GameMatche
   */

  export type AggregateGameMatche = {
    _count: GameMatcheCountAggregateOutputType | null
    _avg: GameMatcheAvgAggregateOutputType | null
    _sum: GameMatcheSumAggregateOutputType | null
    _min: GameMatcheMinAggregateOutputType | null
    _max: GameMatcheMaxAggregateOutputType | null
  }

  export type GameMatcheAvgAggregateOutputType = {
    id: Decimal | null
    eventId: Decimal | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    homeTeamScore: number | null
    awayTeamScore: number | null
  }

  export type GameMatcheSumAggregateOutputType = {
    id: Decimal | null
    eventId: Decimal | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    homeTeamScore: number | null
    awayTeamScore: number | null
  }

  export type GameMatcheMinAggregateOutputType = {
    id: Decimal | null
    eventId: Decimal | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    homeTeamScore: number | null
    awayTeamScore: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMatcheMaxAggregateOutputType = {
    id: Decimal | null
    eventId: Decimal | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    homeTeamScore: number | null
    awayTeamScore: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMatcheCountAggregateOutputType = {
    id: number
    eventId: number
    homeTeamId: number
    awayTeamId: number
    homeTeamScore: number
    awayTeamScore: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameMatcheAvgAggregateInputType = {
    id?: true
    eventId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeTeamScore?: true
    awayTeamScore?: true
  }

  export type GameMatcheSumAggregateInputType = {
    id?: true
    eventId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeTeamScore?: true
    awayTeamScore?: true
  }

  export type GameMatcheMinAggregateInputType = {
    id?: true
    eventId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeTeamScore?: true
    awayTeamScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMatcheMaxAggregateInputType = {
    id?: true
    eventId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeTeamScore?: true
    awayTeamScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMatcheCountAggregateInputType = {
    id?: true
    eventId?: true
    homeTeamId?: true
    awayTeamId?: true
    homeTeamScore?: true
    awayTeamScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameMatcheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameMatche to aggregate.
     */
    where?: GameMatcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameMatches to fetch.
     */
    orderBy?: GameMatcheOrderByWithRelationInput | GameMatcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameMatcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameMatches
    **/
    _count?: true | GameMatcheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameMatcheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameMatcheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMatcheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMatcheMaxAggregateInputType
  }

  export type GetGameMatcheAggregateType<T extends GameMatcheAggregateArgs> = {
        [P in keyof T & keyof AggregateGameMatche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameMatche[P]>
      : GetScalarType<T[P], AggregateGameMatche[P]>
  }




  export type GameMatcheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameMatcheWhereInput
    orderBy?: GameMatcheOrderByWithAggregationInput | GameMatcheOrderByWithAggregationInput[]
    by: GameMatcheScalarFieldEnum[] | GameMatcheScalarFieldEnum
    having?: GameMatcheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameMatcheCountAggregateInputType | true
    _avg?: GameMatcheAvgAggregateInputType
    _sum?: GameMatcheSumAggregateInputType
    _min?: GameMatcheMinAggregateInputType
    _max?: GameMatcheMaxAggregateInputType
  }

  export type GameMatcheGroupByOutputType = {
    id: Decimal
    eventId: Decimal
    homeTeamId: Decimal
    awayTeamId: Decimal
    homeTeamScore: number | null
    awayTeamScore: number | null
    status: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: GameMatcheCountAggregateOutputType | null
    _avg: GameMatcheAvgAggregateOutputType | null
    _sum: GameMatcheSumAggregateOutputType | null
    _min: GameMatcheMinAggregateOutputType | null
    _max: GameMatcheMaxAggregateOutputType | null
  }

  type GetGameMatcheGroupByPayload<T extends GameMatcheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameMatcheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameMatcheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameMatcheGroupByOutputType[P]>
            : GetScalarType<T[P], GameMatcheGroupByOutputType[P]>
        }
      >
    >


  export type GameMatcheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeTeamScore?: boolean
    awayTeamScore?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameMatche"]>

  export type GameMatcheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeTeamScore?: boolean
    awayTeamScore?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameMatche"]>

  export type GameMatcheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeTeamScore?: boolean
    awayTeamScore?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gameMatche"]>

  export type GameMatcheSelectScalar = {
    id?: boolean
    eventId?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    homeTeamScore?: boolean
    awayTeamScore?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameMatcheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "homeTeamId" | "awayTeamId" | "homeTeamScore" | "awayTeamScore" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["gameMatche"]>

  export type $GameMatchePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameMatche"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      eventId: Prisma.Decimal
      homeTeamId: Prisma.Decimal
      awayTeamId: Prisma.Decimal
      homeTeamScore: number | null
      awayTeamScore: number | null
      status: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["gameMatche"]>
    composites: {}
  }

  type GameMatcheGetPayload<S extends boolean | null | undefined | GameMatcheDefaultArgs> = $Result.GetResult<Prisma.$GameMatchePayload, S>

  type GameMatcheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameMatcheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameMatcheCountAggregateInputType | true
    }

  export interface GameMatcheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameMatche'], meta: { name: 'GameMatche' } }
    /**
     * Find zero or one GameMatche that matches the filter.
     * @param {GameMatcheFindUniqueArgs} args - Arguments to find a GameMatche
     * @example
     * // Get one GameMatche
     * const gameMatche = await prisma.gameMatche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameMatcheFindUniqueArgs>(args: SelectSubset<T, GameMatcheFindUniqueArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameMatche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameMatcheFindUniqueOrThrowArgs} args - Arguments to find a GameMatche
     * @example
     * // Get one GameMatche
     * const gameMatche = await prisma.gameMatche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameMatcheFindUniqueOrThrowArgs>(args: SelectSubset<T, GameMatcheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameMatche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheFindFirstArgs} args - Arguments to find a GameMatche
     * @example
     * // Get one GameMatche
     * const gameMatche = await prisma.gameMatche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameMatcheFindFirstArgs>(args?: SelectSubset<T, GameMatcheFindFirstArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameMatche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheFindFirstOrThrowArgs} args - Arguments to find a GameMatche
     * @example
     * // Get one GameMatche
     * const gameMatche = await prisma.gameMatche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameMatcheFindFirstOrThrowArgs>(args?: SelectSubset<T, GameMatcheFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameMatches
     * const gameMatches = await prisma.gameMatche.findMany()
     * 
     * // Get first 10 GameMatches
     * const gameMatches = await prisma.gameMatche.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameMatcheWithIdOnly = await prisma.gameMatche.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameMatcheFindManyArgs>(args?: SelectSubset<T, GameMatcheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameMatche.
     * @param {GameMatcheCreateArgs} args - Arguments to create a GameMatche.
     * @example
     * // Create one GameMatche
     * const GameMatche = await prisma.gameMatche.create({
     *   data: {
     *     // ... data to create a GameMatche
     *   }
     * })
     * 
     */
    create<T extends GameMatcheCreateArgs>(args: SelectSubset<T, GameMatcheCreateArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameMatches.
     * @param {GameMatcheCreateManyArgs} args - Arguments to create many GameMatches.
     * @example
     * // Create many GameMatches
     * const gameMatche = await prisma.gameMatche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameMatcheCreateManyArgs>(args?: SelectSubset<T, GameMatcheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameMatches and returns the data saved in the database.
     * @param {GameMatcheCreateManyAndReturnArgs} args - Arguments to create many GameMatches.
     * @example
     * // Create many GameMatches
     * const gameMatche = await prisma.gameMatche.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameMatches and only return the `id`
     * const gameMatcheWithIdOnly = await prisma.gameMatche.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameMatcheCreateManyAndReturnArgs>(args?: SelectSubset<T, GameMatcheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameMatche.
     * @param {GameMatcheDeleteArgs} args - Arguments to delete one GameMatche.
     * @example
     * // Delete one GameMatche
     * const GameMatche = await prisma.gameMatche.delete({
     *   where: {
     *     // ... filter to delete one GameMatche
     *   }
     * })
     * 
     */
    delete<T extends GameMatcheDeleteArgs>(args: SelectSubset<T, GameMatcheDeleteArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameMatche.
     * @param {GameMatcheUpdateArgs} args - Arguments to update one GameMatche.
     * @example
     * // Update one GameMatche
     * const gameMatche = await prisma.gameMatche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameMatcheUpdateArgs>(args: SelectSubset<T, GameMatcheUpdateArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameMatches.
     * @param {GameMatcheDeleteManyArgs} args - Arguments to filter GameMatches to delete.
     * @example
     * // Delete a few GameMatches
     * const { count } = await prisma.gameMatche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameMatcheDeleteManyArgs>(args?: SelectSubset<T, GameMatcheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameMatches
     * const gameMatche = await prisma.gameMatche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameMatcheUpdateManyArgs>(args: SelectSubset<T, GameMatcheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameMatches and returns the data updated in the database.
     * @param {GameMatcheUpdateManyAndReturnArgs} args - Arguments to update many GameMatches.
     * @example
     * // Update many GameMatches
     * const gameMatche = await prisma.gameMatche.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameMatches and only return the `id`
     * const gameMatcheWithIdOnly = await prisma.gameMatche.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameMatcheUpdateManyAndReturnArgs>(args: SelectSubset<T, GameMatcheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameMatche.
     * @param {GameMatcheUpsertArgs} args - Arguments to update or create a GameMatche.
     * @example
     * // Update or create a GameMatche
     * const gameMatche = await prisma.gameMatche.upsert({
     *   create: {
     *     // ... data to create a GameMatche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameMatche we want to update
     *   }
     * })
     */
    upsert<T extends GameMatcheUpsertArgs>(args: SelectSubset<T, GameMatcheUpsertArgs<ExtArgs>>): Prisma__GameMatcheClient<$Result.GetResult<Prisma.$GameMatchePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheCountArgs} args - Arguments to filter GameMatches to count.
     * @example
     * // Count the number of GameMatches
     * const count = await prisma.gameMatche.count({
     *   where: {
     *     // ... the filter for the GameMatches we want to count
     *   }
     * })
    **/
    count<T extends GameMatcheCountArgs>(
      args?: Subset<T, GameMatcheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameMatcheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameMatche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameMatcheAggregateArgs>(args: Subset<T, GameMatcheAggregateArgs>): Prisma.PrismaPromise<GetGameMatcheAggregateType<T>>

    /**
     * Group by GameMatche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameMatcheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameMatcheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameMatcheGroupByArgs['orderBy'] }
        : { orderBy?: GameMatcheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameMatcheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameMatcheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameMatche model
   */
  readonly fields: GameMatcheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameMatche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameMatcheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameMatche model
   */
  interface GameMatcheFieldRefs {
    readonly id: FieldRef<"GameMatche", 'Decimal'>
    readonly eventId: FieldRef<"GameMatche", 'Decimal'>
    readonly homeTeamId: FieldRef<"GameMatche", 'Decimal'>
    readonly awayTeamId: FieldRef<"GameMatche", 'Decimal'>
    readonly homeTeamScore: FieldRef<"GameMatche", 'Int'>
    readonly awayTeamScore: FieldRef<"GameMatche", 'Int'>
    readonly status: FieldRef<"GameMatche", 'String'>
    readonly createdAt: FieldRef<"GameMatche", 'DateTime'>
    readonly updatedAt: FieldRef<"GameMatche", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameMatche findUnique
   */
  export type GameMatcheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * Filter, which GameMatche to fetch.
     */
    where: GameMatcheWhereUniqueInput
  }

  /**
   * GameMatche findUniqueOrThrow
   */
  export type GameMatcheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * Filter, which GameMatche to fetch.
     */
    where: GameMatcheWhereUniqueInput
  }

  /**
   * GameMatche findFirst
   */
  export type GameMatcheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * Filter, which GameMatche to fetch.
     */
    where?: GameMatcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameMatches to fetch.
     */
    orderBy?: GameMatcheOrderByWithRelationInput | GameMatcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameMatches.
     */
    cursor?: GameMatcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameMatches.
     */
    distinct?: GameMatcheScalarFieldEnum | GameMatcheScalarFieldEnum[]
  }

  /**
   * GameMatche findFirstOrThrow
   */
  export type GameMatcheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * Filter, which GameMatche to fetch.
     */
    where?: GameMatcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameMatches to fetch.
     */
    orderBy?: GameMatcheOrderByWithRelationInput | GameMatcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameMatches.
     */
    cursor?: GameMatcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameMatches.
     */
    distinct?: GameMatcheScalarFieldEnum | GameMatcheScalarFieldEnum[]
  }

  /**
   * GameMatche findMany
   */
  export type GameMatcheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * Filter, which GameMatches to fetch.
     */
    where?: GameMatcheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameMatches to fetch.
     */
    orderBy?: GameMatcheOrderByWithRelationInput | GameMatcheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameMatches.
     */
    cursor?: GameMatcheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameMatches.
     */
    skip?: number
    distinct?: GameMatcheScalarFieldEnum | GameMatcheScalarFieldEnum[]
  }

  /**
   * GameMatche create
   */
  export type GameMatcheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * The data needed to create a GameMatche.
     */
    data: XOR<GameMatcheCreateInput, GameMatcheUncheckedCreateInput>
  }

  /**
   * GameMatche createMany
   */
  export type GameMatcheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameMatches.
     */
    data: GameMatcheCreateManyInput | GameMatcheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameMatche createManyAndReturn
   */
  export type GameMatcheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * The data used to create many GameMatches.
     */
    data: GameMatcheCreateManyInput | GameMatcheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameMatche update
   */
  export type GameMatcheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * The data needed to update a GameMatche.
     */
    data: XOR<GameMatcheUpdateInput, GameMatcheUncheckedUpdateInput>
    /**
     * Choose, which GameMatche to update.
     */
    where: GameMatcheWhereUniqueInput
  }

  /**
   * GameMatche updateMany
   */
  export type GameMatcheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameMatches.
     */
    data: XOR<GameMatcheUpdateManyMutationInput, GameMatcheUncheckedUpdateManyInput>
    /**
     * Filter which GameMatches to update
     */
    where?: GameMatcheWhereInput
    /**
     * Limit how many GameMatches to update.
     */
    limit?: number
  }

  /**
   * GameMatche updateManyAndReturn
   */
  export type GameMatcheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * The data used to update GameMatches.
     */
    data: XOR<GameMatcheUpdateManyMutationInput, GameMatcheUncheckedUpdateManyInput>
    /**
     * Filter which GameMatches to update
     */
    where?: GameMatcheWhereInput
    /**
     * Limit how many GameMatches to update.
     */
    limit?: number
  }

  /**
   * GameMatche upsert
   */
  export type GameMatcheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * The filter to search for the GameMatche to update in case it exists.
     */
    where: GameMatcheWhereUniqueInput
    /**
     * In case the GameMatche found by the `where` argument doesn't exist, create a new GameMatche with this data.
     */
    create: XOR<GameMatcheCreateInput, GameMatcheUncheckedCreateInput>
    /**
     * In case the GameMatche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameMatcheUpdateInput, GameMatcheUncheckedUpdateInput>
  }

  /**
   * GameMatche delete
   */
  export type GameMatcheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
    /**
     * Filter which GameMatche to delete.
     */
    where: GameMatcheWhereUniqueInput
  }

  /**
   * GameMatche deleteMany
   */
  export type GameMatcheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameMatches to delete
     */
    where?: GameMatcheWhereInput
    /**
     * Limit how many GameMatches to delete.
     */
    limit?: number
  }

  /**
   * GameMatche without action
   */
  export type GameMatcheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameMatche
     */
    select?: GameMatcheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameMatche
     */
    omit?: GameMatcheOmit<ExtArgs> | null
  }


  /**
   * Model MatchEvent
   */

  export type AggregateMatchEvent = {
    _count: MatchEventCountAggregateOutputType | null
    _avg: MatchEventAvgAggregateOutputType | null
    _sum: MatchEventSumAggregateOutputType | null
    _min: MatchEventMinAggregateOutputType | null
    _max: MatchEventMaxAggregateOutputType | null
  }

  export type MatchEventAvgAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    minute: number | null
    second: number | null
    fieldX: Decimal | null
    fieldY: Decimal | null
    isConfirmed: number | null
    createdBy: Decimal | null
    ord: number | null
  }

  export type MatchEventSumAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    minute: number | null
    second: number | null
    fieldX: Decimal | null
    fieldY: Decimal | null
    isConfirmed: number | null
    createdBy: Decimal | null
    ord: number | null
  }

  export type MatchEventMinAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    eventType: string | null
    minute: number | null
    second: number | null
    description: string | null
    eventData: string | null
    fieldX: Decimal | null
    fieldY: Decimal | null
    isConfirmed: number | null
    createdBy: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchEventMaxAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    eventType: string | null
    minute: number | null
    second: number | null
    description: string | null
    eventData: string | null
    fieldX: Decimal | null
    fieldY: Decimal | null
    isConfirmed: number | null
    createdBy: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchEventCountAggregateOutputType = {
    id: number
    matchId: number
    playerId: number
    teamId: number
    eventType: number
    minute: number
    second: number
    description: number
    eventData: number
    fieldX: number
    fieldY: number
    isConfirmed: number
    createdBy: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchEventAvgAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minute?: true
    second?: true
    fieldX?: true
    fieldY?: true
    isConfirmed?: true
    createdBy?: true
    ord?: true
  }

  export type MatchEventSumAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minute?: true
    second?: true
    fieldX?: true
    fieldY?: true
    isConfirmed?: true
    createdBy?: true
    ord?: true
  }

  export type MatchEventMinAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    eventType?: true
    minute?: true
    second?: true
    description?: true
    eventData?: true
    fieldX?: true
    fieldY?: true
    isConfirmed?: true
    createdBy?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchEventMaxAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    eventType?: true
    minute?: true
    second?: true
    description?: true
    eventData?: true
    fieldX?: true
    fieldY?: true
    isConfirmed?: true
    createdBy?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchEventCountAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    eventType?: true
    minute?: true
    second?: true
    description?: true
    eventData?: true
    fieldX?: true
    fieldY?: true
    isConfirmed?: true
    createdBy?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchEvent to aggregate.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchEvents
    **/
    _count?: true | MatchEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchEventMaxAggregateInputType
  }

  export type GetMatchEventAggregateType<T extends MatchEventAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchEvent[P]>
      : GetScalarType<T[P], AggregateMatchEvent[P]>
  }




  export type MatchEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchEventWhereInput
    orderBy?: MatchEventOrderByWithAggregationInput | MatchEventOrderByWithAggregationInput[]
    by: MatchEventScalarFieldEnum[] | MatchEventScalarFieldEnum
    having?: MatchEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchEventCountAggregateInputType | true
    _avg?: MatchEventAvgAggregateInputType
    _sum?: MatchEventSumAggregateInputType
    _min?: MatchEventMinAggregateInputType
    _max?: MatchEventMaxAggregateInputType
  }

  export type MatchEventGroupByOutputType = {
    id: Decimal
    matchId: Decimal
    playerId: Decimal | null
    teamId: Decimal | null
    eventType: string
    minute: number
    second: number
    description: string | null
    eventData: string | null
    fieldX: Decimal | null
    fieldY: Decimal | null
    isConfirmed: number
    createdBy: Decimal | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MatchEventCountAggregateOutputType | null
    _avg: MatchEventAvgAggregateOutputType | null
    _sum: MatchEventSumAggregateOutputType | null
    _min: MatchEventMinAggregateOutputType | null
    _max: MatchEventMaxAggregateOutputType | null
  }

  type GetMatchEventGroupByPayload<T extends MatchEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchEventGroupByOutputType[P]>
            : GetScalarType<T[P], MatchEventGroupByOutputType[P]>
        }
      >
    >


  export type MatchEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    eventType?: boolean
    minute?: boolean
    second?: boolean
    description?: boolean
    eventData?: boolean
    fieldX?: boolean
    fieldY?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchEvent"]>

  export type MatchEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    eventType?: boolean
    minute?: boolean
    second?: boolean
    description?: boolean
    eventData?: boolean
    fieldX?: boolean
    fieldY?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchEvent"]>

  export type MatchEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    eventType?: boolean
    minute?: boolean
    second?: boolean
    description?: boolean
    eventData?: boolean
    fieldX?: boolean
    fieldY?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchEvent"]>

  export type MatchEventSelectScalar = {
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    eventType?: boolean
    minute?: boolean
    second?: boolean
    description?: boolean
    eventData?: boolean
    fieldX?: boolean
    fieldY?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "playerId" | "teamId" | "eventType" | "minute" | "second" | "description" | "eventData" | "fieldX" | "fieldY" | "isConfirmed" | "createdBy" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["matchEvent"]>

  export type $MatchEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      matchId: Prisma.Decimal
      playerId: Prisma.Decimal | null
      teamId: Prisma.Decimal | null
      eventType: string
      minute: number
      second: number
      description: string | null
      eventData: string | null
      fieldX: Prisma.Decimal | null
      fieldY: Prisma.Decimal | null
      isConfirmed: number
      createdBy: Prisma.Decimal | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["matchEvent"]>
    composites: {}
  }

  type MatchEventGetPayload<S extends boolean | null | undefined | MatchEventDefaultArgs> = $Result.GetResult<Prisma.$MatchEventPayload, S>

  type MatchEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchEventCountAggregateInputType | true
    }

  export interface MatchEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchEvent'], meta: { name: 'MatchEvent' } }
    /**
     * Find zero or one MatchEvent that matches the filter.
     * @param {MatchEventFindUniqueArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchEventFindUniqueArgs>(args: SelectSubset<T, MatchEventFindUniqueArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchEventFindUniqueOrThrowArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchEventFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventFindFirstArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchEventFindFirstArgs>(args?: SelectSubset<T, MatchEventFindFirstArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventFindFirstOrThrowArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchEventFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchEvents
     * const matchEvents = await prisma.matchEvent.findMany()
     * 
     * // Get first 10 MatchEvents
     * const matchEvents = await prisma.matchEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchEventWithIdOnly = await prisma.matchEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchEventFindManyArgs>(args?: SelectSubset<T, MatchEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchEvent.
     * @param {MatchEventCreateArgs} args - Arguments to create a MatchEvent.
     * @example
     * // Create one MatchEvent
     * const MatchEvent = await prisma.matchEvent.create({
     *   data: {
     *     // ... data to create a MatchEvent
     *   }
     * })
     * 
     */
    create<T extends MatchEventCreateArgs>(args: SelectSubset<T, MatchEventCreateArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchEvents.
     * @param {MatchEventCreateManyArgs} args - Arguments to create many MatchEvents.
     * @example
     * // Create many MatchEvents
     * const matchEvent = await prisma.matchEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchEventCreateManyArgs>(args?: SelectSubset<T, MatchEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchEvents and returns the data saved in the database.
     * @param {MatchEventCreateManyAndReturnArgs} args - Arguments to create many MatchEvents.
     * @example
     * // Create many MatchEvents
     * const matchEvent = await prisma.matchEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchEvents and only return the `id`
     * const matchEventWithIdOnly = await prisma.matchEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchEventCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchEvent.
     * @param {MatchEventDeleteArgs} args - Arguments to delete one MatchEvent.
     * @example
     * // Delete one MatchEvent
     * const MatchEvent = await prisma.matchEvent.delete({
     *   where: {
     *     // ... filter to delete one MatchEvent
     *   }
     * })
     * 
     */
    delete<T extends MatchEventDeleteArgs>(args: SelectSubset<T, MatchEventDeleteArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchEvent.
     * @param {MatchEventUpdateArgs} args - Arguments to update one MatchEvent.
     * @example
     * // Update one MatchEvent
     * const matchEvent = await prisma.matchEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchEventUpdateArgs>(args: SelectSubset<T, MatchEventUpdateArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchEvents.
     * @param {MatchEventDeleteManyArgs} args - Arguments to filter MatchEvents to delete.
     * @example
     * // Delete a few MatchEvents
     * const { count } = await prisma.matchEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchEventDeleteManyArgs>(args?: SelectSubset<T, MatchEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchEvents
     * const matchEvent = await prisma.matchEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchEventUpdateManyArgs>(args: SelectSubset<T, MatchEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchEvents and returns the data updated in the database.
     * @param {MatchEventUpdateManyAndReturnArgs} args - Arguments to update many MatchEvents.
     * @example
     * // Update many MatchEvents
     * const matchEvent = await prisma.matchEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchEvents and only return the `id`
     * const matchEventWithIdOnly = await prisma.matchEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchEventUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchEvent.
     * @param {MatchEventUpsertArgs} args - Arguments to update or create a MatchEvent.
     * @example
     * // Update or create a MatchEvent
     * const matchEvent = await prisma.matchEvent.upsert({
     *   create: {
     *     // ... data to create a MatchEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchEvent we want to update
     *   }
     * })
     */
    upsert<T extends MatchEventUpsertArgs>(args: SelectSubset<T, MatchEventUpsertArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventCountArgs} args - Arguments to filter MatchEvents to count.
     * @example
     * // Count the number of MatchEvents
     * const count = await prisma.matchEvent.count({
     *   where: {
     *     // ... the filter for the MatchEvents we want to count
     *   }
     * })
    **/
    count<T extends MatchEventCountArgs>(
      args?: Subset<T, MatchEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchEventAggregateArgs>(args: Subset<T, MatchEventAggregateArgs>): Prisma.PrismaPromise<GetMatchEventAggregateType<T>>

    /**
     * Group by MatchEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchEventGroupByArgs['orderBy'] }
        : { orderBy?: MatchEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchEvent model
   */
  readonly fields: MatchEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchEvent model
   */
  interface MatchEventFieldRefs {
    readonly id: FieldRef<"MatchEvent", 'Decimal'>
    readonly matchId: FieldRef<"MatchEvent", 'Decimal'>
    readonly playerId: FieldRef<"MatchEvent", 'Decimal'>
    readonly teamId: FieldRef<"MatchEvent", 'Decimal'>
    readonly eventType: FieldRef<"MatchEvent", 'String'>
    readonly minute: FieldRef<"MatchEvent", 'Int'>
    readonly second: FieldRef<"MatchEvent", 'Int'>
    readonly description: FieldRef<"MatchEvent", 'String'>
    readonly eventData: FieldRef<"MatchEvent", 'String'>
    readonly fieldX: FieldRef<"MatchEvent", 'Decimal'>
    readonly fieldY: FieldRef<"MatchEvent", 'Decimal'>
    readonly isConfirmed: FieldRef<"MatchEvent", 'Int'>
    readonly createdBy: FieldRef<"MatchEvent", 'Decimal'>
    readonly notes: FieldRef<"MatchEvent", 'String'>
    readonly ord: FieldRef<"MatchEvent", 'Int'>
    readonly createdAt: FieldRef<"MatchEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchEvent findUnique
   */
  export type MatchEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent findUniqueOrThrow
   */
  export type MatchEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent findFirst
   */
  export type MatchEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchEvents.
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchEvents.
     */
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * MatchEvent findFirstOrThrow
   */
  export type MatchEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchEvents.
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchEvents.
     */
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * MatchEvent findMany
   */
  export type MatchEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * Filter, which MatchEvents to fetch.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchEvents.
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * MatchEvent create
   */
  export type MatchEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * The data needed to create a MatchEvent.
     */
    data: XOR<MatchEventCreateInput, MatchEventUncheckedCreateInput>
  }

  /**
   * MatchEvent createMany
   */
  export type MatchEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchEvents.
     */
    data: MatchEventCreateManyInput | MatchEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchEvent createManyAndReturn
   */
  export type MatchEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * The data used to create many MatchEvents.
     */
    data: MatchEventCreateManyInput | MatchEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchEvent update
   */
  export type MatchEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * The data needed to update a MatchEvent.
     */
    data: XOR<MatchEventUpdateInput, MatchEventUncheckedUpdateInput>
    /**
     * Choose, which MatchEvent to update.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent updateMany
   */
  export type MatchEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchEvents.
     */
    data: XOR<MatchEventUpdateManyMutationInput, MatchEventUncheckedUpdateManyInput>
    /**
     * Filter which MatchEvents to update
     */
    where?: MatchEventWhereInput
    /**
     * Limit how many MatchEvents to update.
     */
    limit?: number
  }

  /**
   * MatchEvent updateManyAndReturn
   */
  export type MatchEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * The data used to update MatchEvents.
     */
    data: XOR<MatchEventUpdateManyMutationInput, MatchEventUncheckedUpdateManyInput>
    /**
     * Filter which MatchEvents to update
     */
    where?: MatchEventWhereInput
    /**
     * Limit how many MatchEvents to update.
     */
    limit?: number
  }

  /**
   * MatchEvent upsert
   */
  export type MatchEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * The filter to search for the MatchEvent to update in case it exists.
     */
    where: MatchEventWhereUniqueInput
    /**
     * In case the MatchEvent found by the `where` argument doesn't exist, create a new MatchEvent with this data.
     */
    create: XOR<MatchEventCreateInput, MatchEventUncheckedCreateInput>
    /**
     * In case the MatchEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchEventUpdateInput, MatchEventUncheckedUpdateInput>
  }

  /**
   * MatchEvent delete
   */
  export type MatchEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
    /**
     * Filter which MatchEvent to delete.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent deleteMany
   */
  export type MatchEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchEvents to delete
     */
    where?: MatchEventWhereInput
    /**
     * Limit how many MatchEvents to delete.
     */
    limit?: number
  }

  /**
   * MatchEvent without action
   */
  export type MatchEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchEvent
     */
    omit?: MatchEventOmit<ExtArgs> | null
  }


  /**
   * Model MatchLineup
   */

  export type AggregateMatchLineup = {
    _count: MatchLineupCountAggregateOutputType | null
    _avg: MatchLineupAvgAggregateOutputType | null
    _sum: MatchLineupSumAggregateOutputType | null
    _min: MatchLineupMinAggregateOutputType | null
    _max: MatchLineupMaxAggregateOutputType | null
  }

  export type MatchLineupAvgAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    teamId: Decimal | null
    isConfirmed: number | null
    createdBy: Decimal | null
    ord: number | null
  }

  export type MatchLineupSumAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    teamId: Decimal | null
    isConfirmed: number | null
    createdBy: Decimal | null
    ord: number | null
  }

  export type MatchLineupMinAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    teamId: Decimal | null
    formation: string | null
    lineupData: string | null
    announcedAt: Date | null
    isConfirmed: number | null
    createdBy: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchLineupMaxAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    teamId: Decimal | null
    formation: string | null
    lineupData: string | null
    announcedAt: Date | null
    isConfirmed: number | null
    createdBy: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchLineupCountAggregateOutputType = {
    id: number
    matchId: number
    teamId: number
    formation: number
    lineupData: number
    announcedAt: number
    isConfirmed: number
    createdBy: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchLineupAvgAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    isConfirmed?: true
    createdBy?: true
    ord?: true
  }

  export type MatchLineupSumAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    isConfirmed?: true
    createdBy?: true
    ord?: true
  }

  export type MatchLineupMinAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    formation?: true
    lineupData?: true
    announcedAt?: true
    isConfirmed?: true
    createdBy?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchLineupMaxAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    formation?: true
    lineupData?: true
    announcedAt?: true
    isConfirmed?: true
    createdBy?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchLineupCountAggregateInputType = {
    id?: true
    matchId?: true
    teamId?: true
    formation?: true
    lineupData?: true
    announcedAt?: true
    isConfirmed?: true
    createdBy?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchLineupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchLineup to aggregate.
     */
    where?: MatchLineupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchLineups to fetch.
     */
    orderBy?: MatchLineupOrderByWithRelationInput | MatchLineupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchLineupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchLineups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchLineups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchLineups
    **/
    _count?: true | MatchLineupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchLineupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchLineupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchLineupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchLineupMaxAggregateInputType
  }

  export type GetMatchLineupAggregateType<T extends MatchLineupAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchLineup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchLineup[P]>
      : GetScalarType<T[P], AggregateMatchLineup[P]>
  }




  export type MatchLineupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchLineupWhereInput
    orderBy?: MatchLineupOrderByWithAggregationInput | MatchLineupOrderByWithAggregationInput[]
    by: MatchLineupScalarFieldEnum[] | MatchLineupScalarFieldEnum
    having?: MatchLineupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchLineupCountAggregateInputType | true
    _avg?: MatchLineupAvgAggregateInputType
    _sum?: MatchLineupSumAggregateInputType
    _min?: MatchLineupMinAggregateInputType
    _max?: MatchLineupMaxAggregateInputType
  }

  export type MatchLineupGroupByOutputType = {
    id: Decimal
    matchId: Decimal
    teamId: Decimal
    formation: string | null
    lineupData: string | null
    announcedAt: Date | null
    isConfirmed: number
    createdBy: Decimal | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MatchLineupCountAggregateOutputType | null
    _avg: MatchLineupAvgAggregateOutputType | null
    _sum: MatchLineupSumAggregateOutputType | null
    _min: MatchLineupMinAggregateOutputType | null
    _max: MatchLineupMaxAggregateOutputType | null
  }

  type GetMatchLineupGroupByPayload<T extends MatchLineupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchLineupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchLineupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchLineupGroupByOutputType[P]>
            : GetScalarType<T[P], MatchLineupGroupByOutputType[P]>
        }
      >
    >


  export type MatchLineupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    formation?: boolean
    lineupData?: boolean
    announcedAt?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchLineup"]>

  export type MatchLineupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    formation?: boolean
    lineupData?: boolean
    announcedAt?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchLineup"]>

  export type MatchLineupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    formation?: boolean
    lineupData?: boolean
    announcedAt?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchLineup"]>

  export type MatchLineupSelectScalar = {
    id?: boolean
    matchId?: boolean
    teamId?: boolean
    formation?: boolean
    lineupData?: boolean
    announcedAt?: boolean
    isConfirmed?: boolean
    createdBy?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchLineupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "teamId" | "formation" | "lineupData" | "announcedAt" | "isConfirmed" | "createdBy" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["matchLineup"]>

  export type $MatchLineupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchLineup"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      matchId: Prisma.Decimal
      teamId: Prisma.Decimal
      formation: string | null
      lineupData: string | null
      announcedAt: Date | null
      isConfirmed: number
      createdBy: Prisma.Decimal | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["matchLineup"]>
    composites: {}
  }

  type MatchLineupGetPayload<S extends boolean | null | undefined | MatchLineupDefaultArgs> = $Result.GetResult<Prisma.$MatchLineupPayload, S>

  type MatchLineupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchLineupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchLineupCountAggregateInputType | true
    }

  export interface MatchLineupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchLineup'], meta: { name: 'MatchLineup' } }
    /**
     * Find zero or one MatchLineup that matches the filter.
     * @param {MatchLineupFindUniqueArgs} args - Arguments to find a MatchLineup
     * @example
     * // Get one MatchLineup
     * const matchLineup = await prisma.matchLineup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchLineupFindUniqueArgs>(args: SelectSubset<T, MatchLineupFindUniqueArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchLineup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchLineupFindUniqueOrThrowArgs} args - Arguments to find a MatchLineup
     * @example
     * // Get one MatchLineup
     * const matchLineup = await prisma.matchLineup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchLineupFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchLineupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchLineup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupFindFirstArgs} args - Arguments to find a MatchLineup
     * @example
     * // Get one MatchLineup
     * const matchLineup = await prisma.matchLineup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchLineupFindFirstArgs>(args?: SelectSubset<T, MatchLineupFindFirstArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchLineup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupFindFirstOrThrowArgs} args - Arguments to find a MatchLineup
     * @example
     * // Get one MatchLineup
     * const matchLineup = await prisma.matchLineup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchLineupFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchLineupFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchLineups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchLineups
     * const matchLineups = await prisma.matchLineup.findMany()
     * 
     * // Get first 10 MatchLineups
     * const matchLineups = await prisma.matchLineup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchLineupWithIdOnly = await prisma.matchLineup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchLineupFindManyArgs>(args?: SelectSubset<T, MatchLineupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchLineup.
     * @param {MatchLineupCreateArgs} args - Arguments to create a MatchLineup.
     * @example
     * // Create one MatchLineup
     * const MatchLineup = await prisma.matchLineup.create({
     *   data: {
     *     // ... data to create a MatchLineup
     *   }
     * })
     * 
     */
    create<T extends MatchLineupCreateArgs>(args: SelectSubset<T, MatchLineupCreateArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchLineups.
     * @param {MatchLineupCreateManyArgs} args - Arguments to create many MatchLineups.
     * @example
     * // Create many MatchLineups
     * const matchLineup = await prisma.matchLineup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchLineupCreateManyArgs>(args?: SelectSubset<T, MatchLineupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchLineups and returns the data saved in the database.
     * @param {MatchLineupCreateManyAndReturnArgs} args - Arguments to create many MatchLineups.
     * @example
     * // Create many MatchLineups
     * const matchLineup = await prisma.matchLineup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchLineups and only return the `id`
     * const matchLineupWithIdOnly = await prisma.matchLineup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchLineupCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchLineupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchLineup.
     * @param {MatchLineupDeleteArgs} args - Arguments to delete one MatchLineup.
     * @example
     * // Delete one MatchLineup
     * const MatchLineup = await prisma.matchLineup.delete({
     *   where: {
     *     // ... filter to delete one MatchLineup
     *   }
     * })
     * 
     */
    delete<T extends MatchLineupDeleteArgs>(args: SelectSubset<T, MatchLineupDeleteArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchLineup.
     * @param {MatchLineupUpdateArgs} args - Arguments to update one MatchLineup.
     * @example
     * // Update one MatchLineup
     * const matchLineup = await prisma.matchLineup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchLineupUpdateArgs>(args: SelectSubset<T, MatchLineupUpdateArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchLineups.
     * @param {MatchLineupDeleteManyArgs} args - Arguments to filter MatchLineups to delete.
     * @example
     * // Delete a few MatchLineups
     * const { count } = await prisma.matchLineup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchLineupDeleteManyArgs>(args?: SelectSubset<T, MatchLineupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchLineups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchLineups
     * const matchLineup = await prisma.matchLineup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchLineupUpdateManyArgs>(args: SelectSubset<T, MatchLineupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchLineups and returns the data updated in the database.
     * @param {MatchLineupUpdateManyAndReturnArgs} args - Arguments to update many MatchLineups.
     * @example
     * // Update many MatchLineups
     * const matchLineup = await prisma.matchLineup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchLineups and only return the `id`
     * const matchLineupWithIdOnly = await prisma.matchLineup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchLineupUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchLineupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchLineup.
     * @param {MatchLineupUpsertArgs} args - Arguments to update or create a MatchLineup.
     * @example
     * // Update or create a MatchLineup
     * const matchLineup = await prisma.matchLineup.upsert({
     *   create: {
     *     // ... data to create a MatchLineup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchLineup we want to update
     *   }
     * })
     */
    upsert<T extends MatchLineupUpsertArgs>(args: SelectSubset<T, MatchLineupUpsertArgs<ExtArgs>>): Prisma__MatchLineupClient<$Result.GetResult<Prisma.$MatchLineupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchLineups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupCountArgs} args - Arguments to filter MatchLineups to count.
     * @example
     * // Count the number of MatchLineups
     * const count = await prisma.matchLineup.count({
     *   where: {
     *     // ... the filter for the MatchLineups we want to count
     *   }
     * })
    **/
    count<T extends MatchLineupCountArgs>(
      args?: Subset<T, MatchLineupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchLineupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchLineup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchLineupAggregateArgs>(args: Subset<T, MatchLineupAggregateArgs>): Prisma.PrismaPromise<GetMatchLineupAggregateType<T>>

    /**
     * Group by MatchLineup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchLineupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchLineupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchLineupGroupByArgs['orderBy'] }
        : { orderBy?: MatchLineupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchLineupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchLineupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchLineup model
   */
  readonly fields: MatchLineupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchLineup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchLineupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchLineup model
   */
  interface MatchLineupFieldRefs {
    readonly id: FieldRef<"MatchLineup", 'Decimal'>
    readonly matchId: FieldRef<"MatchLineup", 'Decimal'>
    readonly teamId: FieldRef<"MatchLineup", 'Decimal'>
    readonly formation: FieldRef<"MatchLineup", 'String'>
    readonly lineupData: FieldRef<"MatchLineup", 'String'>
    readonly announcedAt: FieldRef<"MatchLineup", 'DateTime'>
    readonly isConfirmed: FieldRef<"MatchLineup", 'Int'>
    readonly createdBy: FieldRef<"MatchLineup", 'Decimal'>
    readonly notes: FieldRef<"MatchLineup", 'String'>
    readonly ord: FieldRef<"MatchLineup", 'Int'>
    readonly createdAt: FieldRef<"MatchLineup", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchLineup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchLineup findUnique
   */
  export type MatchLineupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * Filter, which MatchLineup to fetch.
     */
    where: MatchLineupWhereUniqueInput
  }

  /**
   * MatchLineup findUniqueOrThrow
   */
  export type MatchLineupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * Filter, which MatchLineup to fetch.
     */
    where: MatchLineupWhereUniqueInput
  }

  /**
   * MatchLineup findFirst
   */
  export type MatchLineupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * Filter, which MatchLineup to fetch.
     */
    where?: MatchLineupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchLineups to fetch.
     */
    orderBy?: MatchLineupOrderByWithRelationInput | MatchLineupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchLineups.
     */
    cursor?: MatchLineupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchLineups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchLineups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchLineups.
     */
    distinct?: MatchLineupScalarFieldEnum | MatchLineupScalarFieldEnum[]
  }

  /**
   * MatchLineup findFirstOrThrow
   */
  export type MatchLineupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * Filter, which MatchLineup to fetch.
     */
    where?: MatchLineupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchLineups to fetch.
     */
    orderBy?: MatchLineupOrderByWithRelationInput | MatchLineupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchLineups.
     */
    cursor?: MatchLineupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchLineups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchLineups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchLineups.
     */
    distinct?: MatchLineupScalarFieldEnum | MatchLineupScalarFieldEnum[]
  }

  /**
   * MatchLineup findMany
   */
  export type MatchLineupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * Filter, which MatchLineups to fetch.
     */
    where?: MatchLineupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchLineups to fetch.
     */
    orderBy?: MatchLineupOrderByWithRelationInput | MatchLineupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchLineups.
     */
    cursor?: MatchLineupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchLineups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchLineups.
     */
    skip?: number
    distinct?: MatchLineupScalarFieldEnum | MatchLineupScalarFieldEnum[]
  }

  /**
   * MatchLineup create
   */
  export type MatchLineupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * The data needed to create a MatchLineup.
     */
    data: XOR<MatchLineupCreateInput, MatchLineupUncheckedCreateInput>
  }

  /**
   * MatchLineup createMany
   */
  export type MatchLineupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchLineups.
     */
    data: MatchLineupCreateManyInput | MatchLineupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchLineup createManyAndReturn
   */
  export type MatchLineupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * The data used to create many MatchLineups.
     */
    data: MatchLineupCreateManyInput | MatchLineupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchLineup update
   */
  export type MatchLineupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * The data needed to update a MatchLineup.
     */
    data: XOR<MatchLineupUpdateInput, MatchLineupUncheckedUpdateInput>
    /**
     * Choose, which MatchLineup to update.
     */
    where: MatchLineupWhereUniqueInput
  }

  /**
   * MatchLineup updateMany
   */
  export type MatchLineupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchLineups.
     */
    data: XOR<MatchLineupUpdateManyMutationInput, MatchLineupUncheckedUpdateManyInput>
    /**
     * Filter which MatchLineups to update
     */
    where?: MatchLineupWhereInput
    /**
     * Limit how many MatchLineups to update.
     */
    limit?: number
  }

  /**
   * MatchLineup updateManyAndReturn
   */
  export type MatchLineupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * The data used to update MatchLineups.
     */
    data: XOR<MatchLineupUpdateManyMutationInput, MatchLineupUncheckedUpdateManyInput>
    /**
     * Filter which MatchLineups to update
     */
    where?: MatchLineupWhereInput
    /**
     * Limit how many MatchLineups to update.
     */
    limit?: number
  }

  /**
   * MatchLineup upsert
   */
  export type MatchLineupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * The filter to search for the MatchLineup to update in case it exists.
     */
    where: MatchLineupWhereUniqueInput
    /**
     * In case the MatchLineup found by the `where` argument doesn't exist, create a new MatchLineup with this data.
     */
    create: XOR<MatchLineupCreateInput, MatchLineupUncheckedCreateInput>
    /**
     * In case the MatchLineup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchLineupUpdateInput, MatchLineupUncheckedUpdateInput>
  }

  /**
   * MatchLineup delete
   */
  export type MatchLineupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
    /**
     * Filter which MatchLineup to delete.
     */
    where: MatchLineupWhereUniqueInput
  }

  /**
   * MatchLineup deleteMany
   */
  export type MatchLineupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchLineups to delete
     */
    where?: MatchLineupWhereInput
    /**
     * Limit how many MatchLineups to delete.
     */
    limit?: number
  }

  /**
   * MatchLineup without action
   */
  export type MatchLineupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchLineup
     */
    select?: MatchLineupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchLineup
     */
    omit?: MatchLineupOmit<ExtArgs> | null
  }


  /**
   * Model MatchMedia
   */

  export type AggregateMatchMedia = {
    _count: MatchMediaCountAggregateOutputType | null
    _avg: MatchMediaAvgAggregateOutputType | null
    _sum: MatchMediaSumAggregateOutputType | null
    _min: MatchMediaMinAggregateOutputType | null
    _max: MatchMediaMaxAggregateOutputType | null
  }

  export type MatchMediaAvgAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    fileSize: number | null
    isPublic: number | null
    uploadedBy: Decimal | null
    ord: number | null
  }

  export type MatchMediaSumAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    fileSize: bigint | null
    isPublic: number | null
    uploadedBy: Decimal | null
    ord: number | null
  }

  export type MatchMediaMinAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    mediaType: string | null
    fileName: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    description: string | null
    category: string | null
    isPublic: number | null
    uploadedBy: Decimal | null
    uploadedAt: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMediaMaxAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    mediaType: string | null
    fileName: string | null
    filePath: string | null
    fileSize: bigint | null
    mimeType: string | null
    description: string | null
    category: string | null
    isPublic: number | null
    uploadedBy: Decimal | null
    uploadedAt: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMediaCountAggregateOutputType = {
    id: number
    matchId: number
    mediaType: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    description: number
    category: number
    isPublic: number
    uploadedBy: number
    uploadedAt: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchMediaAvgAggregateInputType = {
    id?: true
    matchId?: true
    fileSize?: true
    isPublic?: true
    uploadedBy?: true
    ord?: true
  }

  export type MatchMediaSumAggregateInputType = {
    id?: true
    matchId?: true
    fileSize?: true
    isPublic?: true
    uploadedBy?: true
    ord?: true
  }

  export type MatchMediaMinAggregateInputType = {
    id?: true
    matchId?: true
    mediaType?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    description?: true
    category?: true
    isPublic?: true
    uploadedBy?: true
    uploadedAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMediaMaxAggregateInputType = {
    id?: true
    matchId?: true
    mediaType?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    description?: true
    category?: true
    isPublic?: true
    uploadedBy?: true
    uploadedAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMediaCountAggregateInputType = {
    id?: true
    matchId?: true
    mediaType?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    description?: true
    category?: true
    isPublic?: true
    uploadedBy?: true
    uploadedAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchMedia to aggregate.
     */
    where?: MatchMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMedias to fetch.
     */
    orderBy?: MatchMediaOrderByWithRelationInput | MatchMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchMedias
    **/
    _count?: true | MatchMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMediaMaxAggregateInputType
  }

  export type GetMatchMediaAggregateType<T extends MatchMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchMedia[P]>
      : GetScalarType<T[P], AggregateMatchMedia[P]>
  }




  export type MatchMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMediaWhereInput
    orderBy?: MatchMediaOrderByWithAggregationInput | MatchMediaOrderByWithAggregationInput[]
    by: MatchMediaScalarFieldEnum[] | MatchMediaScalarFieldEnum
    having?: MatchMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchMediaCountAggregateInputType | true
    _avg?: MatchMediaAvgAggregateInputType
    _sum?: MatchMediaSumAggregateInputType
    _min?: MatchMediaMinAggregateInputType
    _max?: MatchMediaMaxAggregateInputType
  }

  export type MatchMediaGroupByOutputType = {
    id: Decimal
    matchId: Decimal
    mediaType: string
    fileName: string
    filePath: string
    fileSize: bigint | null
    mimeType: string | null
    description: string | null
    category: string | null
    isPublic: number
    uploadedBy: Decimal | null
    uploadedAt: Date
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MatchMediaCountAggregateOutputType | null
    _avg: MatchMediaAvgAggregateOutputType | null
    _sum: MatchMediaSumAggregateOutputType | null
    _min: MatchMediaMinAggregateOutputType | null
    _max: MatchMediaMaxAggregateOutputType | null
  }

  type GetMatchMediaGroupByPayload<T extends MatchMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchMediaGroupByOutputType[P]>
            : GetScalarType<T[P], MatchMediaGroupByOutputType[P]>
        }
      >
    >


  export type MatchMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    mediaType?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    category?: boolean
    isPublic?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchMedia"]>

  export type MatchMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    mediaType?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    category?: boolean
    isPublic?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchMedia"]>

  export type MatchMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    mediaType?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    category?: boolean
    isPublic?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchMedia"]>

  export type MatchMediaSelectScalar = {
    id?: boolean
    matchId?: boolean
    mediaType?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    description?: boolean
    category?: boolean
    isPublic?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "mediaType" | "fileName" | "filePath" | "fileSize" | "mimeType" | "description" | "category" | "isPublic" | "uploadedBy" | "uploadedAt" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["matchMedia"]>

  export type $MatchMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchMedia"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      matchId: Prisma.Decimal
      mediaType: string
      fileName: string
      filePath: string
      fileSize: bigint | null
      mimeType: string | null
      description: string | null
      category: string | null
      isPublic: number
      uploadedBy: Prisma.Decimal | null
      uploadedAt: Date
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["matchMedia"]>
    composites: {}
  }

  type MatchMediaGetPayload<S extends boolean | null | undefined | MatchMediaDefaultArgs> = $Result.GetResult<Prisma.$MatchMediaPayload, S>

  type MatchMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchMediaCountAggregateInputType | true
    }

  export interface MatchMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchMedia'], meta: { name: 'MatchMedia' } }
    /**
     * Find zero or one MatchMedia that matches the filter.
     * @param {MatchMediaFindUniqueArgs} args - Arguments to find a MatchMedia
     * @example
     * // Get one MatchMedia
     * const matchMedia = await prisma.matchMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchMediaFindUniqueArgs>(args: SelectSubset<T, MatchMediaFindUniqueArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchMediaFindUniqueOrThrowArgs} args - Arguments to find a MatchMedia
     * @example
     * // Get one MatchMedia
     * const matchMedia = await prisma.matchMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaFindFirstArgs} args - Arguments to find a MatchMedia
     * @example
     * // Get one MatchMedia
     * const matchMedia = await prisma.matchMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchMediaFindFirstArgs>(args?: SelectSubset<T, MatchMediaFindFirstArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaFindFirstOrThrowArgs} args - Arguments to find a MatchMedia
     * @example
     * // Get one MatchMedia
     * const matchMedia = await prisma.matchMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchMedias
     * const matchMedias = await prisma.matchMedia.findMany()
     * 
     * // Get first 10 MatchMedias
     * const matchMedias = await prisma.matchMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchMediaWithIdOnly = await prisma.matchMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchMediaFindManyArgs>(args?: SelectSubset<T, MatchMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchMedia.
     * @param {MatchMediaCreateArgs} args - Arguments to create a MatchMedia.
     * @example
     * // Create one MatchMedia
     * const MatchMedia = await prisma.matchMedia.create({
     *   data: {
     *     // ... data to create a MatchMedia
     *   }
     * })
     * 
     */
    create<T extends MatchMediaCreateArgs>(args: SelectSubset<T, MatchMediaCreateArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchMedias.
     * @param {MatchMediaCreateManyArgs} args - Arguments to create many MatchMedias.
     * @example
     * // Create many MatchMedias
     * const matchMedia = await prisma.matchMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchMediaCreateManyArgs>(args?: SelectSubset<T, MatchMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchMedias and returns the data saved in the database.
     * @param {MatchMediaCreateManyAndReturnArgs} args - Arguments to create many MatchMedias.
     * @example
     * // Create many MatchMedias
     * const matchMedia = await prisma.matchMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchMedias and only return the `id`
     * const matchMediaWithIdOnly = await prisma.matchMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchMedia.
     * @param {MatchMediaDeleteArgs} args - Arguments to delete one MatchMedia.
     * @example
     * // Delete one MatchMedia
     * const MatchMedia = await prisma.matchMedia.delete({
     *   where: {
     *     // ... filter to delete one MatchMedia
     *   }
     * })
     * 
     */
    delete<T extends MatchMediaDeleteArgs>(args: SelectSubset<T, MatchMediaDeleteArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchMedia.
     * @param {MatchMediaUpdateArgs} args - Arguments to update one MatchMedia.
     * @example
     * // Update one MatchMedia
     * const matchMedia = await prisma.matchMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchMediaUpdateArgs>(args: SelectSubset<T, MatchMediaUpdateArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchMedias.
     * @param {MatchMediaDeleteManyArgs} args - Arguments to filter MatchMedias to delete.
     * @example
     * // Delete a few MatchMedias
     * const { count } = await prisma.matchMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchMediaDeleteManyArgs>(args?: SelectSubset<T, MatchMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchMedias
     * const matchMedia = await prisma.matchMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchMediaUpdateManyArgs>(args: SelectSubset<T, MatchMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchMedias and returns the data updated in the database.
     * @param {MatchMediaUpdateManyAndReturnArgs} args - Arguments to update many MatchMedias.
     * @example
     * // Update many MatchMedias
     * const matchMedia = await prisma.matchMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchMedias and only return the `id`
     * const matchMediaWithIdOnly = await prisma.matchMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchMedia.
     * @param {MatchMediaUpsertArgs} args - Arguments to update or create a MatchMedia.
     * @example
     * // Update or create a MatchMedia
     * const matchMedia = await prisma.matchMedia.upsert({
     *   create: {
     *     // ... data to create a MatchMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchMedia we want to update
     *   }
     * })
     */
    upsert<T extends MatchMediaUpsertArgs>(args: SelectSubset<T, MatchMediaUpsertArgs<ExtArgs>>): Prisma__MatchMediaClient<$Result.GetResult<Prisma.$MatchMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaCountArgs} args - Arguments to filter MatchMedias to count.
     * @example
     * // Count the number of MatchMedias
     * const count = await prisma.matchMedia.count({
     *   where: {
     *     // ... the filter for the MatchMedias we want to count
     *   }
     * })
    **/
    count<T extends MatchMediaCountArgs>(
      args?: Subset<T, MatchMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchMediaAggregateArgs>(args: Subset<T, MatchMediaAggregateArgs>): Prisma.PrismaPromise<GetMatchMediaAggregateType<T>>

    /**
     * Group by MatchMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchMediaGroupByArgs['orderBy'] }
        : { orderBy?: MatchMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchMedia model
   */
  readonly fields: MatchMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchMedia model
   */
  interface MatchMediaFieldRefs {
    readonly id: FieldRef<"MatchMedia", 'Decimal'>
    readonly matchId: FieldRef<"MatchMedia", 'Decimal'>
    readonly mediaType: FieldRef<"MatchMedia", 'String'>
    readonly fileName: FieldRef<"MatchMedia", 'String'>
    readonly filePath: FieldRef<"MatchMedia", 'String'>
    readonly fileSize: FieldRef<"MatchMedia", 'BigInt'>
    readonly mimeType: FieldRef<"MatchMedia", 'String'>
    readonly description: FieldRef<"MatchMedia", 'String'>
    readonly category: FieldRef<"MatchMedia", 'String'>
    readonly isPublic: FieldRef<"MatchMedia", 'Int'>
    readonly uploadedBy: FieldRef<"MatchMedia", 'Decimal'>
    readonly uploadedAt: FieldRef<"MatchMedia", 'DateTime'>
    readonly notes: FieldRef<"MatchMedia", 'String'>
    readonly ord: FieldRef<"MatchMedia", 'Int'>
    readonly createdAt: FieldRef<"MatchMedia", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchMedia findUnique
   */
  export type MatchMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * Filter, which MatchMedia to fetch.
     */
    where: MatchMediaWhereUniqueInput
  }

  /**
   * MatchMedia findUniqueOrThrow
   */
  export type MatchMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * Filter, which MatchMedia to fetch.
     */
    where: MatchMediaWhereUniqueInput
  }

  /**
   * MatchMedia findFirst
   */
  export type MatchMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * Filter, which MatchMedia to fetch.
     */
    where?: MatchMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMedias to fetch.
     */
    orderBy?: MatchMediaOrderByWithRelationInput | MatchMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchMedias.
     */
    cursor?: MatchMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchMedias.
     */
    distinct?: MatchMediaScalarFieldEnum | MatchMediaScalarFieldEnum[]
  }

  /**
   * MatchMedia findFirstOrThrow
   */
  export type MatchMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * Filter, which MatchMedia to fetch.
     */
    where?: MatchMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMedias to fetch.
     */
    orderBy?: MatchMediaOrderByWithRelationInput | MatchMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchMedias.
     */
    cursor?: MatchMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchMedias.
     */
    distinct?: MatchMediaScalarFieldEnum | MatchMediaScalarFieldEnum[]
  }

  /**
   * MatchMedia findMany
   */
  export type MatchMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * Filter, which MatchMedias to fetch.
     */
    where?: MatchMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMedias to fetch.
     */
    orderBy?: MatchMediaOrderByWithRelationInput | MatchMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchMedias.
     */
    cursor?: MatchMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMedias.
     */
    skip?: number
    distinct?: MatchMediaScalarFieldEnum | MatchMediaScalarFieldEnum[]
  }

  /**
   * MatchMedia create
   */
  export type MatchMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * The data needed to create a MatchMedia.
     */
    data: XOR<MatchMediaCreateInput, MatchMediaUncheckedCreateInput>
  }

  /**
   * MatchMedia createMany
   */
  export type MatchMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchMedias.
     */
    data: MatchMediaCreateManyInput | MatchMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchMedia createManyAndReturn
   */
  export type MatchMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * The data used to create many MatchMedias.
     */
    data: MatchMediaCreateManyInput | MatchMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchMedia update
   */
  export type MatchMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * The data needed to update a MatchMedia.
     */
    data: XOR<MatchMediaUpdateInput, MatchMediaUncheckedUpdateInput>
    /**
     * Choose, which MatchMedia to update.
     */
    where: MatchMediaWhereUniqueInput
  }

  /**
   * MatchMedia updateMany
   */
  export type MatchMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchMedias.
     */
    data: XOR<MatchMediaUpdateManyMutationInput, MatchMediaUncheckedUpdateManyInput>
    /**
     * Filter which MatchMedias to update
     */
    where?: MatchMediaWhereInput
    /**
     * Limit how many MatchMedias to update.
     */
    limit?: number
  }

  /**
   * MatchMedia updateManyAndReturn
   */
  export type MatchMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * The data used to update MatchMedias.
     */
    data: XOR<MatchMediaUpdateManyMutationInput, MatchMediaUncheckedUpdateManyInput>
    /**
     * Filter which MatchMedias to update
     */
    where?: MatchMediaWhereInput
    /**
     * Limit how many MatchMedias to update.
     */
    limit?: number
  }

  /**
   * MatchMedia upsert
   */
  export type MatchMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * The filter to search for the MatchMedia to update in case it exists.
     */
    where: MatchMediaWhereUniqueInput
    /**
     * In case the MatchMedia found by the `where` argument doesn't exist, create a new MatchMedia with this data.
     */
    create: XOR<MatchMediaCreateInput, MatchMediaUncheckedCreateInput>
    /**
     * In case the MatchMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchMediaUpdateInput, MatchMediaUncheckedUpdateInput>
  }

  /**
   * MatchMedia delete
   */
  export type MatchMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
    /**
     * Filter which MatchMedia to delete.
     */
    where: MatchMediaWhereUniqueInput
  }

  /**
   * MatchMedia deleteMany
   */
  export type MatchMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchMedias to delete
     */
    where?: MatchMediaWhereInput
    /**
     * Limit how many MatchMedias to delete.
     */
    limit?: number
  }

  /**
   * MatchMedia without action
   */
  export type MatchMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMedia
     */
    select?: MatchMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMedia
     */
    omit?: MatchMediaOmit<ExtArgs> | null
  }


  /**
   * Model MatchRoster
   */

  export type AggregateMatchRoster = {
    _count: MatchRosterCountAggregateOutputType | null
    _avg: MatchRosterAvgAggregateOutputType | null
    _sum: MatchRosterSumAggregateOutputType | null
    _min: MatchRosterMinAggregateOutputType | null
    _max: MatchRosterMaxAggregateOutputType | null
  }

  export type MatchRosterAvgAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    isStarting: number | null
    isSubstitute: number | null
    substitutionInMinute: number | null
    substitutionOutMinute: number | null
    minutesPlayed: number | null
    ord: number | null
  }

  export type MatchRosterSumAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    isStarting: number | null
    isSubstitute: number | null
    substitutionInMinute: number | null
    substitutionOutMinute: number | null
    minutesPlayed: number | null
    ord: number | null
  }

  export type MatchRosterMinAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    isStarting: number | null
    isSubstitute: number | null
    position: string | null
    jerseyNumber: string | null
    substitutionInMinute: number | null
    substitutionOutMinute: number | null
    substitutionReason: string | null
    minutesPlayed: number | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchRosterMaxAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    isStarting: number | null
    isSubstitute: number | null
    position: string | null
    jerseyNumber: string | null
    substitutionInMinute: number | null
    substitutionOutMinute: number | null
    substitutionReason: string | null
    minutesPlayed: number | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchRosterCountAggregateOutputType = {
    id: number
    matchId: number
    playerId: number
    teamId: number
    isStarting: number
    isSubstitute: number
    position: number
    jerseyNumber: number
    substitutionInMinute: number
    substitutionOutMinute: number
    substitutionReason: number
    minutesPlayed: number
    status: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchRosterAvgAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    isStarting?: true
    isSubstitute?: true
    substitutionInMinute?: true
    substitutionOutMinute?: true
    minutesPlayed?: true
    ord?: true
  }

  export type MatchRosterSumAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    isStarting?: true
    isSubstitute?: true
    substitutionInMinute?: true
    substitutionOutMinute?: true
    minutesPlayed?: true
    ord?: true
  }

  export type MatchRosterMinAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    isStarting?: true
    isSubstitute?: true
    position?: true
    jerseyNumber?: true
    substitutionInMinute?: true
    substitutionOutMinute?: true
    substitutionReason?: true
    minutesPlayed?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchRosterMaxAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    isStarting?: true
    isSubstitute?: true
    position?: true
    jerseyNumber?: true
    substitutionInMinute?: true
    substitutionOutMinute?: true
    substitutionReason?: true
    minutesPlayed?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchRosterCountAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    isStarting?: true
    isSubstitute?: true
    position?: true
    jerseyNumber?: true
    substitutionInMinute?: true
    substitutionOutMinute?: true
    substitutionReason?: true
    minutesPlayed?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchRosterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchRoster to aggregate.
     */
    where?: MatchRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRosters to fetch.
     */
    orderBy?: MatchRosterOrderByWithRelationInput | MatchRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchRosters
    **/
    _count?: true | MatchRosterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchRosterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchRosterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchRosterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchRosterMaxAggregateInputType
  }

  export type GetMatchRosterAggregateType<T extends MatchRosterAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchRoster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchRoster[P]>
      : GetScalarType<T[P], AggregateMatchRoster[P]>
  }




  export type MatchRosterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchRosterWhereInput
    orderBy?: MatchRosterOrderByWithAggregationInput | MatchRosterOrderByWithAggregationInput[]
    by: MatchRosterScalarFieldEnum[] | MatchRosterScalarFieldEnum
    having?: MatchRosterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchRosterCountAggregateInputType | true
    _avg?: MatchRosterAvgAggregateInputType
    _sum?: MatchRosterSumAggregateInputType
    _min?: MatchRosterMinAggregateInputType
    _max?: MatchRosterMaxAggregateInputType
  }

  export type MatchRosterGroupByOutputType = {
    id: Decimal
    matchId: Decimal
    playerId: Decimal
    teamId: Decimal
    isStarting: number
    isSubstitute: number
    position: string | null
    jerseyNumber: string | null
    substitutionInMinute: number | null
    substitutionOutMinute: number | null
    substitutionReason: string | null
    minutesPlayed: number | null
    status: string
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MatchRosterCountAggregateOutputType | null
    _avg: MatchRosterAvgAggregateOutputType | null
    _sum: MatchRosterSumAggregateOutputType | null
    _min: MatchRosterMinAggregateOutputType | null
    _max: MatchRosterMaxAggregateOutputType | null
  }

  type GetMatchRosterGroupByPayload<T extends MatchRosterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchRosterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchRosterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchRosterGroupByOutputType[P]>
            : GetScalarType<T[P], MatchRosterGroupByOutputType[P]>
        }
      >
    >


  export type MatchRosterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    isStarting?: boolean
    isSubstitute?: boolean
    position?: boolean
    jerseyNumber?: boolean
    substitutionInMinute?: boolean
    substitutionOutMinute?: boolean
    substitutionReason?: boolean
    minutesPlayed?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchRoster"]>

  export type MatchRosterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    isStarting?: boolean
    isSubstitute?: boolean
    position?: boolean
    jerseyNumber?: boolean
    substitutionInMinute?: boolean
    substitutionOutMinute?: boolean
    substitutionReason?: boolean
    minutesPlayed?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchRoster"]>

  export type MatchRosterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    isStarting?: boolean
    isSubstitute?: boolean
    position?: boolean
    jerseyNumber?: boolean
    substitutionInMinute?: boolean
    substitutionOutMinute?: boolean
    substitutionReason?: boolean
    minutesPlayed?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchRoster"]>

  export type MatchRosterSelectScalar = {
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    isStarting?: boolean
    isSubstitute?: boolean
    position?: boolean
    jerseyNumber?: boolean
    substitutionInMinute?: boolean
    substitutionOutMinute?: boolean
    substitutionReason?: boolean
    minutesPlayed?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchRosterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "playerId" | "teamId" | "isStarting" | "isSubstitute" | "position" | "jerseyNumber" | "substitutionInMinute" | "substitutionOutMinute" | "substitutionReason" | "minutesPlayed" | "status" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["matchRoster"]>

  export type $MatchRosterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchRoster"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      matchId: Prisma.Decimal
      playerId: Prisma.Decimal
      teamId: Prisma.Decimal
      isStarting: number
      isSubstitute: number
      position: string | null
      jerseyNumber: string | null
      substitutionInMinute: number | null
      substitutionOutMinute: number | null
      substitutionReason: string | null
      minutesPlayed: number | null
      status: string
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["matchRoster"]>
    composites: {}
  }

  type MatchRosterGetPayload<S extends boolean | null | undefined | MatchRosterDefaultArgs> = $Result.GetResult<Prisma.$MatchRosterPayload, S>

  type MatchRosterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchRosterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchRosterCountAggregateInputType | true
    }

  export interface MatchRosterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchRoster'], meta: { name: 'MatchRoster' } }
    /**
     * Find zero or one MatchRoster that matches the filter.
     * @param {MatchRosterFindUniqueArgs} args - Arguments to find a MatchRoster
     * @example
     * // Get one MatchRoster
     * const matchRoster = await prisma.matchRoster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchRosterFindUniqueArgs>(args: SelectSubset<T, MatchRosterFindUniqueArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchRoster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchRosterFindUniqueOrThrowArgs} args - Arguments to find a MatchRoster
     * @example
     * // Get one MatchRoster
     * const matchRoster = await prisma.matchRoster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchRosterFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchRosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchRoster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterFindFirstArgs} args - Arguments to find a MatchRoster
     * @example
     * // Get one MatchRoster
     * const matchRoster = await prisma.matchRoster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchRosterFindFirstArgs>(args?: SelectSubset<T, MatchRosterFindFirstArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchRoster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterFindFirstOrThrowArgs} args - Arguments to find a MatchRoster
     * @example
     * // Get one MatchRoster
     * const matchRoster = await prisma.matchRoster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchRosterFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchRosterFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchRosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchRosters
     * const matchRosters = await prisma.matchRoster.findMany()
     * 
     * // Get first 10 MatchRosters
     * const matchRosters = await prisma.matchRoster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchRosterWithIdOnly = await prisma.matchRoster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchRosterFindManyArgs>(args?: SelectSubset<T, MatchRosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchRoster.
     * @param {MatchRosterCreateArgs} args - Arguments to create a MatchRoster.
     * @example
     * // Create one MatchRoster
     * const MatchRoster = await prisma.matchRoster.create({
     *   data: {
     *     // ... data to create a MatchRoster
     *   }
     * })
     * 
     */
    create<T extends MatchRosterCreateArgs>(args: SelectSubset<T, MatchRosterCreateArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchRosters.
     * @param {MatchRosterCreateManyArgs} args - Arguments to create many MatchRosters.
     * @example
     * // Create many MatchRosters
     * const matchRoster = await prisma.matchRoster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchRosterCreateManyArgs>(args?: SelectSubset<T, MatchRosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchRosters and returns the data saved in the database.
     * @param {MatchRosterCreateManyAndReturnArgs} args - Arguments to create many MatchRosters.
     * @example
     * // Create many MatchRosters
     * const matchRoster = await prisma.matchRoster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchRosters and only return the `id`
     * const matchRosterWithIdOnly = await prisma.matchRoster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchRosterCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchRosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchRoster.
     * @param {MatchRosterDeleteArgs} args - Arguments to delete one MatchRoster.
     * @example
     * // Delete one MatchRoster
     * const MatchRoster = await prisma.matchRoster.delete({
     *   where: {
     *     // ... filter to delete one MatchRoster
     *   }
     * })
     * 
     */
    delete<T extends MatchRosterDeleteArgs>(args: SelectSubset<T, MatchRosterDeleteArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchRoster.
     * @param {MatchRosterUpdateArgs} args - Arguments to update one MatchRoster.
     * @example
     * // Update one MatchRoster
     * const matchRoster = await prisma.matchRoster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchRosterUpdateArgs>(args: SelectSubset<T, MatchRosterUpdateArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchRosters.
     * @param {MatchRosterDeleteManyArgs} args - Arguments to filter MatchRosters to delete.
     * @example
     * // Delete a few MatchRosters
     * const { count } = await prisma.matchRoster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchRosterDeleteManyArgs>(args?: SelectSubset<T, MatchRosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchRosters
     * const matchRoster = await prisma.matchRoster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchRosterUpdateManyArgs>(args: SelectSubset<T, MatchRosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchRosters and returns the data updated in the database.
     * @param {MatchRosterUpdateManyAndReturnArgs} args - Arguments to update many MatchRosters.
     * @example
     * // Update many MatchRosters
     * const matchRoster = await prisma.matchRoster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchRosters and only return the `id`
     * const matchRosterWithIdOnly = await prisma.matchRoster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchRosterUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchRosterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchRoster.
     * @param {MatchRosterUpsertArgs} args - Arguments to update or create a MatchRoster.
     * @example
     * // Update or create a MatchRoster
     * const matchRoster = await prisma.matchRoster.upsert({
     *   create: {
     *     // ... data to create a MatchRoster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchRoster we want to update
     *   }
     * })
     */
    upsert<T extends MatchRosterUpsertArgs>(args: SelectSubset<T, MatchRosterUpsertArgs<ExtArgs>>): Prisma__MatchRosterClient<$Result.GetResult<Prisma.$MatchRosterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterCountArgs} args - Arguments to filter MatchRosters to count.
     * @example
     * // Count the number of MatchRosters
     * const count = await prisma.matchRoster.count({
     *   where: {
     *     // ... the filter for the MatchRosters we want to count
     *   }
     * })
    **/
    count<T extends MatchRosterCountArgs>(
      args?: Subset<T, MatchRosterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchRosterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchRosterAggregateArgs>(args: Subset<T, MatchRosterAggregateArgs>): Prisma.PrismaPromise<GetMatchRosterAggregateType<T>>

    /**
     * Group by MatchRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRosterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchRosterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchRosterGroupByArgs['orderBy'] }
        : { orderBy?: MatchRosterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchRosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchRosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchRoster model
   */
  readonly fields: MatchRosterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchRoster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchRosterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchRoster model
   */
  interface MatchRosterFieldRefs {
    readonly id: FieldRef<"MatchRoster", 'Decimal'>
    readonly matchId: FieldRef<"MatchRoster", 'Decimal'>
    readonly playerId: FieldRef<"MatchRoster", 'Decimal'>
    readonly teamId: FieldRef<"MatchRoster", 'Decimal'>
    readonly isStarting: FieldRef<"MatchRoster", 'Int'>
    readonly isSubstitute: FieldRef<"MatchRoster", 'Int'>
    readonly position: FieldRef<"MatchRoster", 'String'>
    readonly jerseyNumber: FieldRef<"MatchRoster", 'String'>
    readonly substitutionInMinute: FieldRef<"MatchRoster", 'Int'>
    readonly substitutionOutMinute: FieldRef<"MatchRoster", 'Int'>
    readonly substitutionReason: FieldRef<"MatchRoster", 'String'>
    readonly minutesPlayed: FieldRef<"MatchRoster", 'Int'>
    readonly status: FieldRef<"MatchRoster", 'String'>
    readonly notes: FieldRef<"MatchRoster", 'String'>
    readonly ord: FieldRef<"MatchRoster", 'Int'>
    readonly createdAt: FieldRef<"MatchRoster", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchRoster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchRoster findUnique
   */
  export type MatchRosterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * Filter, which MatchRoster to fetch.
     */
    where: MatchRosterWhereUniqueInput
  }

  /**
   * MatchRoster findUniqueOrThrow
   */
  export type MatchRosterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * Filter, which MatchRoster to fetch.
     */
    where: MatchRosterWhereUniqueInput
  }

  /**
   * MatchRoster findFirst
   */
  export type MatchRosterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * Filter, which MatchRoster to fetch.
     */
    where?: MatchRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRosters to fetch.
     */
    orderBy?: MatchRosterOrderByWithRelationInput | MatchRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchRosters.
     */
    cursor?: MatchRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchRosters.
     */
    distinct?: MatchRosterScalarFieldEnum | MatchRosterScalarFieldEnum[]
  }

  /**
   * MatchRoster findFirstOrThrow
   */
  export type MatchRosterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * Filter, which MatchRoster to fetch.
     */
    where?: MatchRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRosters to fetch.
     */
    orderBy?: MatchRosterOrderByWithRelationInput | MatchRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchRosters.
     */
    cursor?: MatchRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchRosters.
     */
    distinct?: MatchRosterScalarFieldEnum | MatchRosterScalarFieldEnum[]
  }

  /**
   * MatchRoster findMany
   */
  export type MatchRosterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * Filter, which MatchRosters to fetch.
     */
    where?: MatchRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRosters to fetch.
     */
    orderBy?: MatchRosterOrderByWithRelationInput | MatchRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchRosters.
     */
    cursor?: MatchRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRosters.
     */
    skip?: number
    distinct?: MatchRosterScalarFieldEnum | MatchRosterScalarFieldEnum[]
  }

  /**
   * MatchRoster create
   */
  export type MatchRosterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * The data needed to create a MatchRoster.
     */
    data: XOR<MatchRosterCreateInput, MatchRosterUncheckedCreateInput>
  }

  /**
   * MatchRoster createMany
   */
  export type MatchRosterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchRosters.
     */
    data: MatchRosterCreateManyInput | MatchRosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchRoster createManyAndReturn
   */
  export type MatchRosterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * The data used to create many MatchRosters.
     */
    data: MatchRosterCreateManyInput | MatchRosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchRoster update
   */
  export type MatchRosterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * The data needed to update a MatchRoster.
     */
    data: XOR<MatchRosterUpdateInput, MatchRosterUncheckedUpdateInput>
    /**
     * Choose, which MatchRoster to update.
     */
    where: MatchRosterWhereUniqueInput
  }

  /**
   * MatchRoster updateMany
   */
  export type MatchRosterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchRosters.
     */
    data: XOR<MatchRosterUpdateManyMutationInput, MatchRosterUncheckedUpdateManyInput>
    /**
     * Filter which MatchRosters to update
     */
    where?: MatchRosterWhereInput
    /**
     * Limit how many MatchRosters to update.
     */
    limit?: number
  }

  /**
   * MatchRoster updateManyAndReturn
   */
  export type MatchRosterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * The data used to update MatchRosters.
     */
    data: XOR<MatchRosterUpdateManyMutationInput, MatchRosterUncheckedUpdateManyInput>
    /**
     * Filter which MatchRosters to update
     */
    where?: MatchRosterWhereInput
    /**
     * Limit how many MatchRosters to update.
     */
    limit?: number
  }

  /**
   * MatchRoster upsert
   */
  export type MatchRosterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * The filter to search for the MatchRoster to update in case it exists.
     */
    where: MatchRosterWhereUniqueInput
    /**
     * In case the MatchRoster found by the `where` argument doesn't exist, create a new MatchRoster with this data.
     */
    create: XOR<MatchRosterCreateInput, MatchRosterUncheckedCreateInput>
    /**
     * In case the MatchRoster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchRosterUpdateInput, MatchRosterUncheckedUpdateInput>
  }

  /**
   * MatchRoster delete
   */
  export type MatchRosterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
    /**
     * Filter which MatchRoster to delete.
     */
    where: MatchRosterWhereUniqueInput
  }

  /**
   * MatchRoster deleteMany
   */
  export type MatchRosterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchRosters to delete
     */
    where?: MatchRosterWhereInput
    /**
     * Limit how many MatchRosters to delete.
     */
    limit?: number
  }

  /**
   * MatchRoster without action
   */
  export type MatchRosterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRoster
     */
    select?: MatchRosterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchRoster
     */
    omit?: MatchRosterOmit<ExtArgs> | null
  }


  /**
   * Model MatchStatistic
   */

  export type AggregateMatchStatistic = {
    _count: MatchStatisticCountAggregateOutputType | null
    _avg: MatchStatisticAvgAggregateOutputType | null
    _sum: MatchStatisticSumAggregateOutputType | null
    _min: MatchStatisticMinAggregateOutputType | null
    _max: MatchStatisticMaxAggregateOutputType | null
  }

  export type MatchStatisticAvgAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    minutesPlayed: number | null
    goals: number | null
    assists: number | null
    shots: number | null
    shots_on_target: number | null
    passes: number | null
    passesCompleted: number | null
    passAccuracy: Decimal | null
    tackles: number | null
    interceptions: number | null
    clearances: number | null
    blocks: number | null
    yellowCards: number | null
    redCards: number | null
    foulsCommitted: number | null
    foulsWon: number | null
    saves: number | null
    goalsConceded: number | null
    cleanSheets: number | null
    rating: Decimal | null
    ord: number | null
  }

  export type MatchStatisticSumAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    minutesPlayed: number | null
    goals: number | null
    assists: number | null
    shots: number | null
    shots_on_target: number | null
    passes: number | null
    passesCompleted: number | null
    passAccuracy: Decimal | null
    tackles: number | null
    interceptions: number | null
    clearances: number | null
    blocks: number | null
    yellowCards: number | null
    redCards: number | null
    foulsCommitted: number | null
    foulsWon: number | null
    saves: number | null
    goalsConceded: number | null
    cleanSheets: number | null
    rating: Decimal | null
    ord: number | null
  }

  export type MatchStatisticMinAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    minutesPlayed: number | null
    goals: number | null
    assists: number | null
    shots: number | null
    shots_on_target: number | null
    passes: number | null
    passesCompleted: number | null
    passAccuracy: Decimal | null
    tackles: number | null
    interceptions: number | null
    clearances: number | null
    blocks: number | null
    yellowCards: number | null
    redCards: number | null
    foulsCommitted: number | null
    foulsWon: number | null
    saves: number | null
    goalsConceded: number | null
    cleanSheets: number | null
    rating: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchStatisticMaxAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    playerId: Decimal | null
    teamId: Decimal | null
    minutesPlayed: number | null
    goals: number | null
    assists: number | null
    shots: number | null
    shots_on_target: number | null
    passes: number | null
    passesCompleted: number | null
    passAccuracy: Decimal | null
    tackles: number | null
    interceptions: number | null
    clearances: number | null
    blocks: number | null
    yellowCards: number | null
    redCards: number | null
    foulsCommitted: number | null
    foulsWon: number | null
    saves: number | null
    goalsConceded: number | null
    cleanSheets: number | null
    rating: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchStatisticCountAggregateOutputType = {
    id: number
    matchId: number
    playerId: number
    teamId: number
    minutesPlayed: number
    goals: number
    assists: number
    shots: number
    shots_on_target: number
    passes: number
    passesCompleted: number
    passAccuracy: number
    tackles: number
    interceptions: number
    clearances: number
    blocks: number
    yellowCards: number
    redCards: number
    foulsCommitted: number
    foulsWon: number
    saves: number
    goalsConceded: number
    cleanSheets: number
    rating: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchStatisticAvgAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minutesPlayed?: true
    goals?: true
    assists?: true
    shots?: true
    shots_on_target?: true
    passes?: true
    passesCompleted?: true
    passAccuracy?: true
    tackles?: true
    interceptions?: true
    clearances?: true
    blocks?: true
    yellowCards?: true
    redCards?: true
    foulsCommitted?: true
    foulsWon?: true
    saves?: true
    goalsConceded?: true
    cleanSheets?: true
    rating?: true
    ord?: true
  }

  export type MatchStatisticSumAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minutesPlayed?: true
    goals?: true
    assists?: true
    shots?: true
    shots_on_target?: true
    passes?: true
    passesCompleted?: true
    passAccuracy?: true
    tackles?: true
    interceptions?: true
    clearances?: true
    blocks?: true
    yellowCards?: true
    redCards?: true
    foulsCommitted?: true
    foulsWon?: true
    saves?: true
    goalsConceded?: true
    cleanSheets?: true
    rating?: true
    ord?: true
  }

  export type MatchStatisticMinAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minutesPlayed?: true
    goals?: true
    assists?: true
    shots?: true
    shots_on_target?: true
    passes?: true
    passesCompleted?: true
    passAccuracy?: true
    tackles?: true
    interceptions?: true
    clearances?: true
    blocks?: true
    yellowCards?: true
    redCards?: true
    foulsCommitted?: true
    foulsWon?: true
    saves?: true
    goalsConceded?: true
    cleanSheets?: true
    rating?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchStatisticMaxAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minutesPlayed?: true
    goals?: true
    assists?: true
    shots?: true
    shots_on_target?: true
    passes?: true
    passesCompleted?: true
    passAccuracy?: true
    tackles?: true
    interceptions?: true
    clearances?: true
    blocks?: true
    yellowCards?: true
    redCards?: true
    foulsCommitted?: true
    foulsWon?: true
    saves?: true
    goalsConceded?: true
    cleanSheets?: true
    rating?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchStatisticCountAggregateInputType = {
    id?: true
    matchId?: true
    playerId?: true
    teamId?: true
    minutesPlayed?: true
    goals?: true
    assists?: true
    shots?: true
    shots_on_target?: true
    passes?: true
    passesCompleted?: true
    passAccuracy?: true
    tackles?: true
    interceptions?: true
    clearances?: true
    blocks?: true
    yellowCards?: true
    redCards?: true
    foulsCommitted?: true
    foulsWon?: true
    saves?: true
    goalsConceded?: true
    cleanSheets?: true
    rating?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchStatisticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchStatistic to aggregate.
     */
    where?: MatchStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchStatistics to fetch.
     */
    orderBy?: MatchStatisticOrderByWithRelationInput | MatchStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchStatistics
    **/
    _count?: true | MatchStatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchStatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchStatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchStatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchStatisticMaxAggregateInputType
  }

  export type GetMatchStatisticAggregateType<T extends MatchStatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchStatistic[P]>
      : GetScalarType<T[P], AggregateMatchStatistic[P]>
  }




  export type MatchStatisticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchStatisticWhereInput
    orderBy?: MatchStatisticOrderByWithAggregationInput | MatchStatisticOrderByWithAggregationInput[]
    by: MatchStatisticScalarFieldEnum[] | MatchStatisticScalarFieldEnum
    having?: MatchStatisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchStatisticCountAggregateInputType | true
    _avg?: MatchStatisticAvgAggregateInputType
    _sum?: MatchStatisticSumAggregateInputType
    _min?: MatchStatisticMinAggregateInputType
    _max?: MatchStatisticMaxAggregateInputType
  }

  export type MatchStatisticGroupByOutputType = {
    id: Decimal
    matchId: Decimal
    playerId: Decimal
    teamId: Decimal
    minutesPlayed: number
    goals: number
    assists: number
    shots: number
    shots_on_target: number
    passes: number
    passesCompleted: number
    passAccuracy: Decimal
    tackles: number
    interceptions: number
    clearances: number
    blocks: number
    yellowCards: number
    redCards: number
    foulsCommitted: number
    foulsWon: number
    saves: number
    goalsConceded: number
    cleanSheets: number
    rating: Decimal | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MatchStatisticCountAggregateOutputType | null
    _avg: MatchStatisticAvgAggregateOutputType | null
    _sum: MatchStatisticSumAggregateOutputType | null
    _min: MatchStatisticMinAggregateOutputType | null
    _max: MatchStatisticMaxAggregateOutputType | null
  }

  type GetMatchStatisticGroupByPayload<T extends MatchStatisticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchStatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchStatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchStatisticGroupByOutputType[P]>
            : GetScalarType<T[P], MatchStatisticGroupByOutputType[P]>
        }
      >
    >


  export type MatchStatisticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    minutesPlayed?: boolean
    goals?: boolean
    assists?: boolean
    shots?: boolean
    shots_on_target?: boolean
    passes?: boolean
    passesCompleted?: boolean
    passAccuracy?: boolean
    tackles?: boolean
    interceptions?: boolean
    clearances?: boolean
    blocks?: boolean
    yellowCards?: boolean
    redCards?: boolean
    foulsCommitted?: boolean
    foulsWon?: boolean
    saves?: boolean
    goalsConceded?: boolean
    cleanSheets?: boolean
    rating?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchStatistic"]>

  export type MatchStatisticSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    minutesPlayed?: boolean
    goals?: boolean
    assists?: boolean
    shots?: boolean
    shots_on_target?: boolean
    passes?: boolean
    passesCompleted?: boolean
    passAccuracy?: boolean
    tackles?: boolean
    interceptions?: boolean
    clearances?: boolean
    blocks?: boolean
    yellowCards?: boolean
    redCards?: boolean
    foulsCommitted?: boolean
    foulsWon?: boolean
    saves?: boolean
    goalsConceded?: boolean
    cleanSheets?: boolean
    rating?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchStatistic"]>

  export type MatchStatisticSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    minutesPlayed?: boolean
    goals?: boolean
    assists?: boolean
    shots?: boolean
    shots_on_target?: boolean
    passes?: boolean
    passesCompleted?: boolean
    passAccuracy?: boolean
    tackles?: boolean
    interceptions?: boolean
    clearances?: boolean
    blocks?: boolean
    yellowCards?: boolean
    redCards?: boolean
    foulsCommitted?: boolean
    foulsWon?: boolean
    saves?: boolean
    goalsConceded?: boolean
    cleanSheets?: boolean
    rating?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matchStatistic"]>

  export type MatchStatisticSelectScalar = {
    id?: boolean
    matchId?: boolean
    playerId?: boolean
    teamId?: boolean
    minutesPlayed?: boolean
    goals?: boolean
    assists?: boolean
    shots?: boolean
    shots_on_target?: boolean
    passes?: boolean
    passesCompleted?: boolean
    passAccuracy?: boolean
    tackles?: boolean
    interceptions?: boolean
    clearances?: boolean
    blocks?: boolean
    yellowCards?: boolean
    redCards?: boolean
    foulsCommitted?: boolean
    foulsWon?: boolean
    saves?: boolean
    goalsConceded?: boolean
    cleanSheets?: boolean
    rating?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchStatisticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "playerId" | "teamId" | "minutesPlayed" | "goals" | "assists" | "shots" | "shots_on_target" | "passes" | "passesCompleted" | "passAccuracy" | "tackles" | "interceptions" | "clearances" | "blocks" | "yellowCards" | "redCards" | "foulsCommitted" | "foulsWon" | "saves" | "goalsConceded" | "cleanSheets" | "rating" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["matchStatistic"]>

  export type $MatchStatisticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchStatistic"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      matchId: Prisma.Decimal
      playerId: Prisma.Decimal
      teamId: Prisma.Decimal
      minutesPlayed: number
      goals: number
      assists: number
      shots: number
      shots_on_target: number
      passes: number
      passesCompleted: number
      passAccuracy: Prisma.Decimal
      tackles: number
      interceptions: number
      clearances: number
      blocks: number
      yellowCards: number
      redCards: number
      foulsCommitted: number
      foulsWon: number
      saves: number
      goalsConceded: number
      cleanSheets: number
      rating: Prisma.Decimal | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["matchStatistic"]>
    composites: {}
  }

  type MatchStatisticGetPayload<S extends boolean | null | undefined | MatchStatisticDefaultArgs> = $Result.GetResult<Prisma.$MatchStatisticPayload, S>

  type MatchStatisticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchStatisticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchStatisticCountAggregateInputType | true
    }

  export interface MatchStatisticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchStatistic'], meta: { name: 'MatchStatistic' } }
    /**
     * Find zero or one MatchStatistic that matches the filter.
     * @param {MatchStatisticFindUniqueArgs} args - Arguments to find a MatchStatistic
     * @example
     * // Get one MatchStatistic
     * const matchStatistic = await prisma.matchStatistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchStatisticFindUniqueArgs>(args: SelectSubset<T, MatchStatisticFindUniqueArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchStatistic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchStatisticFindUniqueOrThrowArgs} args - Arguments to find a MatchStatistic
     * @example
     * // Get one MatchStatistic
     * const matchStatistic = await prisma.matchStatistic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchStatisticFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchStatisticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchStatistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticFindFirstArgs} args - Arguments to find a MatchStatistic
     * @example
     * // Get one MatchStatistic
     * const matchStatistic = await prisma.matchStatistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchStatisticFindFirstArgs>(args?: SelectSubset<T, MatchStatisticFindFirstArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchStatistic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticFindFirstOrThrowArgs} args - Arguments to find a MatchStatistic
     * @example
     * // Get one MatchStatistic
     * const matchStatistic = await prisma.matchStatistic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchStatisticFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchStatisticFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchStatistics
     * const matchStatistics = await prisma.matchStatistic.findMany()
     * 
     * // Get first 10 MatchStatistics
     * const matchStatistics = await prisma.matchStatistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchStatisticWithIdOnly = await prisma.matchStatistic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchStatisticFindManyArgs>(args?: SelectSubset<T, MatchStatisticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchStatistic.
     * @param {MatchStatisticCreateArgs} args - Arguments to create a MatchStatistic.
     * @example
     * // Create one MatchStatistic
     * const MatchStatistic = await prisma.matchStatistic.create({
     *   data: {
     *     // ... data to create a MatchStatistic
     *   }
     * })
     * 
     */
    create<T extends MatchStatisticCreateArgs>(args: SelectSubset<T, MatchStatisticCreateArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchStatistics.
     * @param {MatchStatisticCreateManyArgs} args - Arguments to create many MatchStatistics.
     * @example
     * // Create many MatchStatistics
     * const matchStatistic = await prisma.matchStatistic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchStatisticCreateManyArgs>(args?: SelectSubset<T, MatchStatisticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchStatistics and returns the data saved in the database.
     * @param {MatchStatisticCreateManyAndReturnArgs} args - Arguments to create many MatchStatistics.
     * @example
     * // Create many MatchStatistics
     * const matchStatistic = await prisma.matchStatistic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchStatistics and only return the `id`
     * const matchStatisticWithIdOnly = await prisma.matchStatistic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchStatisticCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchStatisticCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchStatistic.
     * @param {MatchStatisticDeleteArgs} args - Arguments to delete one MatchStatistic.
     * @example
     * // Delete one MatchStatistic
     * const MatchStatistic = await prisma.matchStatistic.delete({
     *   where: {
     *     // ... filter to delete one MatchStatistic
     *   }
     * })
     * 
     */
    delete<T extends MatchStatisticDeleteArgs>(args: SelectSubset<T, MatchStatisticDeleteArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchStatistic.
     * @param {MatchStatisticUpdateArgs} args - Arguments to update one MatchStatistic.
     * @example
     * // Update one MatchStatistic
     * const matchStatistic = await prisma.matchStatistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchStatisticUpdateArgs>(args: SelectSubset<T, MatchStatisticUpdateArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchStatistics.
     * @param {MatchStatisticDeleteManyArgs} args - Arguments to filter MatchStatistics to delete.
     * @example
     * // Delete a few MatchStatistics
     * const { count } = await prisma.matchStatistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchStatisticDeleteManyArgs>(args?: SelectSubset<T, MatchStatisticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchStatistics
     * const matchStatistic = await prisma.matchStatistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchStatisticUpdateManyArgs>(args: SelectSubset<T, MatchStatisticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchStatistics and returns the data updated in the database.
     * @param {MatchStatisticUpdateManyAndReturnArgs} args - Arguments to update many MatchStatistics.
     * @example
     * // Update many MatchStatistics
     * const matchStatistic = await prisma.matchStatistic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchStatistics and only return the `id`
     * const matchStatisticWithIdOnly = await prisma.matchStatistic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchStatisticUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchStatisticUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchStatistic.
     * @param {MatchStatisticUpsertArgs} args - Arguments to update or create a MatchStatistic.
     * @example
     * // Update or create a MatchStatistic
     * const matchStatistic = await prisma.matchStatistic.upsert({
     *   create: {
     *     // ... data to create a MatchStatistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchStatistic we want to update
     *   }
     * })
     */
    upsert<T extends MatchStatisticUpsertArgs>(args: SelectSubset<T, MatchStatisticUpsertArgs<ExtArgs>>): Prisma__MatchStatisticClient<$Result.GetResult<Prisma.$MatchStatisticPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticCountArgs} args - Arguments to filter MatchStatistics to count.
     * @example
     * // Count the number of MatchStatistics
     * const count = await prisma.matchStatistic.count({
     *   where: {
     *     // ... the filter for the MatchStatistics we want to count
     *   }
     * })
    **/
    count<T extends MatchStatisticCountArgs>(
      args?: Subset<T, MatchStatisticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchStatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchStatisticAggregateArgs>(args: Subset<T, MatchStatisticAggregateArgs>): Prisma.PrismaPromise<GetMatchStatisticAggregateType<T>>

    /**
     * Group by MatchStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchStatisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchStatisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchStatisticGroupByArgs['orderBy'] }
        : { orderBy?: MatchStatisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchStatisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchStatisticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchStatistic model
   */
  readonly fields: MatchStatisticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchStatistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchStatisticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchStatistic model
   */
  interface MatchStatisticFieldRefs {
    readonly id: FieldRef<"MatchStatistic", 'Decimal'>
    readonly matchId: FieldRef<"MatchStatistic", 'Decimal'>
    readonly playerId: FieldRef<"MatchStatistic", 'Decimal'>
    readonly teamId: FieldRef<"MatchStatistic", 'Decimal'>
    readonly minutesPlayed: FieldRef<"MatchStatistic", 'Int'>
    readonly goals: FieldRef<"MatchStatistic", 'Int'>
    readonly assists: FieldRef<"MatchStatistic", 'Int'>
    readonly shots: FieldRef<"MatchStatistic", 'Int'>
    readonly shots_on_target: FieldRef<"MatchStatistic", 'Int'>
    readonly passes: FieldRef<"MatchStatistic", 'Int'>
    readonly passesCompleted: FieldRef<"MatchStatistic", 'Int'>
    readonly passAccuracy: FieldRef<"MatchStatistic", 'Decimal'>
    readonly tackles: FieldRef<"MatchStatistic", 'Int'>
    readonly interceptions: FieldRef<"MatchStatistic", 'Int'>
    readonly clearances: FieldRef<"MatchStatistic", 'Int'>
    readonly blocks: FieldRef<"MatchStatistic", 'Int'>
    readonly yellowCards: FieldRef<"MatchStatistic", 'Int'>
    readonly redCards: FieldRef<"MatchStatistic", 'Int'>
    readonly foulsCommitted: FieldRef<"MatchStatistic", 'Int'>
    readonly foulsWon: FieldRef<"MatchStatistic", 'Int'>
    readonly saves: FieldRef<"MatchStatistic", 'Int'>
    readonly goalsConceded: FieldRef<"MatchStatistic", 'Int'>
    readonly cleanSheets: FieldRef<"MatchStatistic", 'Int'>
    readonly rating: FieldRef<"MatchStatistic", 'Decimal'>
    readonly notes: FieldRef<"MatchStatistic", 'String'>
    readonly ord: FieldRef<"MatchStatistic", 'Int'>
    readonly createdAt: FieldRef<"MatchStatistic", 'DateTime'>
    readonly updatedAt: FieldRef<"MatchStatistic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchStatistic findUnique
   */
  export type MatchStatisticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * Filter, which MatchStatistic to fetch.
     */
    where: MatchStatisticWhereUniqueInput
  }

  /**
   * MatchStatistic findUniqueOrThrow
   */
  export type MatchStatisticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * Filter, which MatchStatistic to fetch.
     */
    where: MatchStatisticWhereUniqueInput
  }

  /**
   * MatchStatistic findFirst
   */
  export type MatchStatisticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * Filter, which MatchStatistic to fetch.
     */
    where?: MatchStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchStatistics to fetch.
     */
    orderBy?: MatchStatisticOrderByWithRelationInput | MatchStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchStatistics.
     */
    cursor?: MatchStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchStatistics.
     */
    distinct?: MatchStatisticScalarFieldEnum | MatchStatisticScalarFieldEnum[]
  }

  /**
   * MatchStatistic findFirstOrThrow
   */
  export type MatchStatisticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * Filter, which MatchStatistic to fetch.
     */
    where?: MatchStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchStatistics to fetch.
     */
    orderBy?: MatchStatisticOrderByWithRelationInput | MatchStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchStatistics.
     */
    cursor?: MatchStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchStatistics.
     */
    distinct?: MatchStatisticScalarFieldEnum | MatchStatisticScalarFieldEnum[]
  }

  /**
   * MatchStatistic findMany
   */
  export type MatchStatisticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * Filter, which MatchStatistics to fetch.
     */
    where?: MatchStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchStatistics to fetch.
     */
    orderBy?: MatchStatisticOrderByWithRelationInput | MatchStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchStatistics.
     */
    cursor?: MatchStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchStatistics.
     */
    skip?: number
    distinct?: MatchStatisticScalarFieldEnum | MatchStatisticScalarFieldEnum[]
  }

  /**
   * MatchStatistic create
   */
  export type MatchStatisticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * The data needed to create a MatchStatistic.
     */
    data: XOR<MatchStatisticCreateInput, MatchStatisticUncheckedCreateInput>
  }

  /**
   * MatchStatistic createMany
   */
  export type MatchStatisticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchStatistics.
     */
    data: MatchStatisticCreateManyInput | MatchStatisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchStatistic createManyAndReturn
   */
  export type MatchStatisticCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * The data used to create many MatchStatistics.
     */
    data: MatchStatisticCreateManyInput | MatchStatisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchStatistic update
   */
  export type MatchStatisticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * The data needed to update a MatchStatistic.
     */
    data: XOR<MatchStatisticUpdateInput, MatchStatisticUncheckedUpdateInput>
    /**
     * Choose, which MatchStatistic to update.
     */
    where: MatchStatisticWhereUniqueInput
  }

  /**
   * MatchStatistic updateMany
   */
  export type MatchStatisticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchStatistics.
     */
    data: XOR<MatchStatisticUpdateManyMutationInput, MatchStatisticUncheckedUpdateManyInput>
    /**
     * Filter which MatchStatistics to update
     */
    where?: MatchStatisticWhereInput
    /**
     * Limit how many MatchStatistics to update.
     */
    limit?: number
  }

  /**
   * MatchStatistic updateManyAndReturn
   */
  export type MatchStatisticUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * The data used to update MatchStatistics.
     */
    data: XOR<MatchStatisticUpdateManyMutationInput, MatchStatisticUncheckedUpdateManyInput>
    /**
     * Filter which MatchStatistics to update
     */
    where?: MatchStatisticWhereInput
    /**
     * Limit how many MatchStatistics to update.
     */
    limit?: number
  }

  /**
   * MatchStatistic upsert
   */
  export type MatchStatisticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * The filter to search for the MatchStatistic to update in case it exists.
     */
    where: MatchStatisticWhereUniqueInput
    /**
     * In case the MatchStatistic found by the `where` argument doesn't exist, create a new MatchStatistic with this data.
     */
    create: XOR<MatchStatisticCreateInput, MatchStatisticUncheckedCreateInput>
    /**
     * In case the MatchStatistic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchStatisticUpdateInput, MatchStatisticUncheckedUpdateInput>
  }

  /**
   * MatchStatistic delete
   */
  export type MatchStatisticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
    /**
     * Filter which MatchStatistic to delete.
     */
    where: MatchStatisticWhereUniqueInput
  }

  /**
   * MatchStatistic deleteMany
   */
  export type MatchStatisticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchStatistics to delete
     */
    where?: MatchStatisticWhereInput
    /**
     * Limit how many MatchStatistics to delete.
     */
    limit?: number
  }

  /**
   * MatchStatistic without action
   */
  export type MatchStatisticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchStatistic
     */
    select?: MatchStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchStatistic
     */
    omit?: MatchStatisticOmit<ExtArgs> | null
  }


  /**
   * Model MemberClubAdmin
   */

  export type AggregateMemberClubAdmin = {
    _count: MemberClubAdminCountAggregateOutputType | null
    _avg: MemberClubAdminAvgAggregateOutputType | null
    _sum: MemberClubAdminSumAggregateOutputType | null
    _min: MemberClubAdminMinAggregateOutputType | null
    _max: MemberClubAdminMaxAggregateOutputType | null
  }

  export type MemberClubAdminAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    clubId: Decimal | null
    ord: number | null
  }

  export type MemberClubAdminSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    clubId: Decimal | null
    ord: number | null
  }

  export type MemberClubAdminMinAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    clubId: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberClubAdminMaxAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    clubId: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberClubAdminCountAggregateOutputType = {
    id: number
    personId: number
    clubId: number
    emergencyContactName: number
    emergencyContactPhone: number
    status: number
    bio: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberClubAdminAvgAggregateInputType = {
    id?: true
    personId?: true
    clubId?: true
    ord?: true
  }

  export type MemberClubAdminSumAggregateInputType = {
    id?: true
    personId?: true
    clubId?: true
    ord?: true
  }

  export type MemberClubAdminMinAggregateInputType = {
    id?: true
    personId?: true
    clubId?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberClubAdminMaxAggregateInputType = {
    id?: true
    personId?: true
    clubId?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberClubAdminCountAggregateInputType = {
    id?: true
    personId?: true
    clubId?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberClubAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberClubAdmin to aggregate.
     */
    where?: MemberClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberClubAdmins to fetch.
     */
    orderBy?: MemberClubAdminOrderByWithRelationInput | MemberClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberClubAdmins
    **/
    _count?: true | MemberClubAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberClubAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberClubAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberClubAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberClubAdminMaxAggregateInputType
  }

  export type GetMemberClubAdminAggregateType<T extends MemberClubAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberClubAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberClubAdmin[P]>
      : GetScalarType<T[P], AggregateMemberClubAdmin[P]>
  }




  export type MemberClubAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberClubAdminWhereInput
    orderBy?: MemberClubAdminOrderByWithAggregationInput | MemberClubAdminOrderByWithAggregationInput[]
    by: MemberClubAdminScalarFieldEnum[] | MemberClubAdminScalarFieldEnum
    having?: MemberClubAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberClubAdminCountAggregateInputType | true
    _avg?: MemberClubAdminAvgAggregateInputType
    _sum?: MemberClubAdminSumAggregateInputType
    _min?: MemberClubAdminMinAggregateInputType
    _max?: MemberClubAdminMaxAggregateInputType
  }

  export type MemberClubAdminGroupByOutputType = {
    id: Decimal
    personId: Decimal
    clubId: Decimal
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string
    bio: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberClubAdminCountAggregateOutputType | null
    _avg: MemberClubAdminAvgAggregateOutputType | null
    _sum: MemberClubAdminSumAggregateOutputType | null
    _min: MemberClubAdminMinAggregateOutputType | null
    _max: MemberClubAdminMaxAggregateOutputType | null
  }

  type GetMemberClubAdminGroupByPayload<T extends MemberClubAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberClubAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberClubAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberClubAdminGroupByOutputType[P]>
            : GetScalarType<T[P], MemberClubAdminGroupByOutputType[P]>
        }
      >
    >


  export type MemberClubAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    clubId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberClubAdmin"]>

  export type MemberClubAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    clubId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberClubAdmin"]>

  export type MemberClubAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    clubId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberClubAdmin"]>

  export type MemberClubAdminSelectScalar = {
    id?: boolean
    personId?: boolean
    clubId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberClubAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "clubId" | "emergencyContactName" | "emergencyContactPhone" | "status" | "bio" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberClubAdmin"]>

  export type $MemberClubAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberClubAdmin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      personId: Prisma.Decimal
      clubId: Prisma.Decimal
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      status: string
      bio: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberClubAdmin"]>
    composites: {}
  }

  type MemberClubAdminGetPayload<S extends boolean | null | undefined | MemberClubAdminDefaultArgs> = $Result.GetResult<Prisma.$MemberClubAdminPayload, S>

  type MemberClubAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberClubAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberClubAdminCountAggregateInputType | true
    }

  export interface MemberClubAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberClubAdmin'], meta: { name: 'MemberClubAdmin' } }
    /**
     * Find zero or one MemberClubAdmin that matches the filter.
     * @param {MemberClubAdminFindUniqueArgs} args - Arguments to find a MemberClubAdmin
     * @example
     * // Get one MemberClubAdmin
     * const memberClubAdmin = await prisma.memberClubAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberClubAdminFindUniqueArgs>(args: SelectSubset<T, MemberClubAdminFindUniqueArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberClubAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberClubAdminFindUniqueOrThrowArgs} args - Arguments to find a MemberClubAdmin
     * @example
     * // Get one MemberClubAdmin
     * const memberClubAdmin = await prisma.memberClubAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberClubAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberClubAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberClubAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminFindFirstArgs} args - Arguments to find a MemberClubAdmin
     * @example
     * // Get one MemberClubAdmin
     * const memberClubAdmin = await prisma.memberClubAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberClubAdminFindFirstArgs>(args?: SelectSubset<T, MemberClubAdminFindFirstArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberClubAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminFindFirstOrThrowArgs} args - Arguments to find a MemberClubAdmin
     * @example
     * // Get one MemberClubAdmin
     * const memberClubAdmin = await prisma.memberClubAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberClubAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberClubAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberClubAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberClubAdmins
     * const memberClubAdmins = await prisma.memberClubAdmin.findMany()
     * 
     * // Get first 10 MemberClubAdmins
     * const memberClubAdmins = await prisma.memberClubAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberClubAdminWithIdOnly = await prisma.memberClubAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberClubAdminFindManyArgs>(args?: SelectSubset<T, MemberClubAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberClubAdmin.
     * @param {MemberClubAdminCreateArgs} args - Arguments to create a MemberClubAdmin.
     * @example
     * // Create one MemberClubAdmin
     * const MemberClubAdmin = await prisma.memberClubAdmin.create({
     *   data: {
     *     // ... data to create a MemberClubAdmin
     *   }
     * })
     * 
     */
    create<T extends MemberClubAdminCreateArgs>(args: SelectSubset<T, MemberClubAdminCreateArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberClubAdmins.
     * @param {MemberClubAdminCreateManyArgs} args - Arguments to create many MemberClubAdmins.
     * @example
     * // Create many MemberClubAdmins
     * const memberClubAdmin = await prisma.memberClubAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberClubAdminCreateManyArgs>(args?: SelectSubset<T, MemberClubAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberClubAdmins and returns the data saved in the database.
     * @param {MemberClubAdminCreateManyAndReturnArgs} args - Arguments to create many MemberClubAdmins.
     * @example
     * // Create many MemberClubAdmins
     * const memberClubAdmin = await prisma.memberClubAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberClubAdmins and only return the `id`
     * const memberClubAdminWithIdOnly = await prisma.memberClubAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberClubAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberClubAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberClubAdmin.
     * @param {MemberClubAdminDeleteArgs} args - Arguments to delete one MemberClubAdmin.
     * @example
     * // Delete one MemberClubAdmin
     * const MemberClubAdmin = await prisma.memberClubAdmin.delete({
     *   where: {
     *     // ... filter to delete one MemberClubAdmin
     *   }
     * })
     * 
     */
    delete<T extends MemberClubAdminDeleteArgs>(args: SelectSubset<T, MemberClubAdminDeleteArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberClubAdmin.
     * @param {MemberClubAdminUpdateArgs} args - Arguments to update one MemberClubAdmin.
     * @example
     * // Update one MemberClubAdmin
     * const memberClubAdmin = await prisma.memberClubAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberClubAdminUpdateArgs>(args: SelectSubset<T, MemberClubAdminUpdateArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberClubAdmins.
     * @param {MemberClubAdminDeleteManyArgs} args - Arguments to filter MemberClubAdmins to delete.
     * @example
     * // Delete a few MemberClubAdmins
     * const { count } = await prisma.memberClubAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberClubAdminDeleteManyArgs>(args?: SelectSubset<T, MemberClubAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberClubAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberClubAdmins
     * const memberClubAdmin = await prisma.memberClubAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberClubAdminUpdateManyArgs>(args: SelectSubset<T, MemberClubAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberClubAdmins and returns the data updated in the database.
     * @param {MemberClubAdminUpdateManyAndReturnArgs} args - Arguments to update many MemberClubAdmins.
     * @example
     * // Update many MemberClubAdmins
     * const memberClubAdmin = await prisma.memberClubAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberClubAdmins and only return the `id`
     * const memberClubAdminWithIdOnly = await prisma.memberClubAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberClubAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberClubAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberClubAdmin.
     * @param {MemberClubAdminUpsertArgs} args - Arguments to update or create a MemberClubAdmin.
     * @example
     * // Update or create a MemberClubAdmin
     * const memberClubAdmin = await prisma.memberClubAdmin.upsert({
     *   create: {
     *     // ... data to create a MemberClubAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberClubAdmin we want to update
     *   }
     * })
     */
    upsert<T extends MemberClubAdminUpsertArgs>(args: SelectSubset<T, MemberClubAdminUpsertArgs<ExtArgs>>): Prisma__MemberClubAdminClient<$Result.GetResult<Prisma.$MemberClubAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberClubAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminCountArgs} args - Arguments to filter MemberClubAdmins to count.
     * @example
     * // Count the number of MemberClubAdmins
     * const count = await prisma.memberClubAdmin.count({
     *   where: {
     *     // ... the filter for the MemberClubAdmins we want to count
     *   }
     * })
    **/
    count<T extends MemberClubAdminCountArgs>(
      args?: Subset<T, MemberClubAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberClubAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberClubAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberClubAdminAggregateArgs>(args: Subset<T, MemberClubAdminAggregateArgs>): Prisma.PrismaPromise<GetMemberClubAdminAggregateType<T>>

    /**
     * Group by MemberClubAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberClubAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberClubAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberClubAdminGroupByArgs['orderBy'] }
        : { orderBy?: MemberClubAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberClubAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberClubAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberClubAdmin model
   */
  readonly fields: MemberClubAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberClubAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClubAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberClubAdmin model
   */
  interface MemberClubAdminFieldRefs {
    readonly id: FieldRef<"MemberClubAdmin", 'Decimal'>
    readonly personId: FieldRef<"MemberClubAdmin", 'Decimal'>
    readonly clubId: FieldRef<"MemberClubAdmin", 'Decimal'>
    readonly emergencyContactName: FieldRef<"MemberClubAdmin", 'String'>
    readonly emergencyContactPhone: FieldRef<"MemberClubAdmin", 'String'>
    readonly status: FieldRef<"MemberClubAdmin", 'String'>
    readonly bio: FieldRef<"MemberClubAdmin", 'String'>
    readonly ord: FieldRef<"MemberClubAdmin", 'Int'>
    readonly createdAt: FieldRef<"MemberClubAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberClubAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberClubAdmin findUnique
   */
  export type MemberClubAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which MemberClubAdmin to fetch.
     */
    where: MemberClubAdminWhereUniqueInput
  }

  /**
   * MemberClubAdmin findUniqueOrThrow
   */
  export type MemberClubAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which MemberClubAdmin to fetch.
     */
    where: MemberClubAdminWhereUniqueInput
  }

  /**
   * MemberClubAdmin findFirst
   */
  export type MemberClubAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which MemberClubAdmin to fetch.
     */
    where?: MemberClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberClubAdmins to fetch.
     */
    orderBy?: MemberClubAdminOrderByWithRelationInput | MemberClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberClubAdmins.
     */
    cursor?: MemberClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberClubAdmins.
     */
    distinct?: MemberClubAdminScalarFieldEnum | MemberClubAdminScalarFieldEnum[]
  }

  /**
   * MemberClubAdmin findFirstOrThrow
   */
  export type MemberClubAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which MemberClubAdmin to fetch.
     */
    where?: MemberClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberClubAdmins to fetch.
     */
    orderBy?: MemberClubAdminOrderByWithRelationInput | MemberClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberClubAdmins.
     */
    cursor?: MemberClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberClubAdmins.
     */
    distinct?: MemberClubAdminScalarFieldEnum | MemberClubAdminScalarFieldEnum[]
  }

  /**
   * MemberClubAdmin findMany
   */
  export type MemberClubAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which MemberClubAdmins to fetch.
     */
    where?: MemberClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberClubAdmins to fetch.
     */
    orderBy?: MemberClubAdminOrderByWithRelationInput | MemberClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberClubAdmins.
     */
    cursor?: MemberClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberClubAdmins.
     */
    skip?: number
    distinct?: MemberClubAdminScalarFieldEnum | MemberClubAdminScalarFieldEnum[]
  }

  /**
   * MemberClubAdmin create
   */
  export type MemberClubAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberClubAdmin.
     */
    data: XOR<MemberClubAdminCreateInput, MemberClubAdminUncheckedCreateInput>
  }

  /**
   * MemberClubAdmin createMany
   */
  export type MemberClubAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberClubAdmins.
     */
    data: MemberClubAdminCreateManyInput | MemberClubAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberClubAdmin createManyAndReturn
   */
  export type MemberClubAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * The data used to create many MemberClubAdmins.
     */
    data: MemberClubAdminCreateManyInput | MemberClubAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberClubAdmin update
   */
  export type MemberClubAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberClubAdmin.
     */
    data: XOR<MemberClubAdminUpdateInput, MemberClubAdminUncheckedUpdateInput>
    /**
     * Choose, which MemberClubAdmin to update.
     */
    where: MemberClubAdminWhereUniqueInput
  }

  /**
   * MemberClubAdmin updateMany
   */
  export type MemberClubAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberClubAdmins.
     */
    data: XOR<MemberClubAdminUpdateManyMutationInput, MemberClubAdminUncheckedUpdateManyInput>
    /**
     * Filter which MemberClubAdmins to update
     */
    where?: MemberClubAdminWhereInput
    /**
     * Limit how many MemberClubAdmins to update.
     */
    limit?: number
  }

  /**
   * MemberClubAdmin updateManyAndReturn
   */
  export type MemberClubAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * The data used to update MemberClubAdmins.
     */
    data: XOR<MemberClubAdminUpdateManyMutationInput, MemberClubAdminUncheckedUpdateManyInput>
    /**
     * Filter which MemberClubAdmins to update
     */
    where?: MemberClubAdminWhereInput
    /**
     * Limit how many MemberClubAdmins to update.
     */
    limit?: number
  }

  /**
   * MemberClubAdmin upsert
   */
  export type MemberClubAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberClubAdmin to update in case it exists.
     */
    where: MemberClubAdminWhereUniqueInput
    /**
     * In case the MemberClubAdmin found by the `where` argument doesn't exist, create a new MemberClubAdmin with this data.
     */
    create: XOR<MemberClubAdminCreateInput, MemberClubAdminUncheckedCreateInput>
    /**
     * In case the MemberClubAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberClubAdminUpdateInput, MemberClubAdminUncheckedUpdateInput>
  }

  /**
   * MemberClubAdmin delete
   */
  export type MemberClubAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
    /**
     * Filter which MemberClubAdmin to delete.
     */
    where: MemberClubAdminWhereUniqueInput
  }

  /**
   * MemberClubAdmin deleteMany
   */
  export type MemberClubAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberClubAdmins to delete
     */
    where?: MemberClubAdminWhereInput
    /**
     * Limit how many MemberClubAdmins to delete.
     */
    limit?: number
  }

  /**
   * MemberClubAdmin without action
   */
  export type MemberClubAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberClubAdmin
     */
    select?: MemberClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberClubAdmin
     */
    omit?: MemberClubAdminOmit<ExtArgs> | null
  }


  /**
   * Model MemberCoache
   */

  export type AggregateMemberCoache = {
    _count: MemberCoacheCountAggregateOutputType | null
    _avg: MemberCoacheAvgAggregateOutputType | null
    _sum: MemberCoacheSumAggregateOutputType | null
    _min: MemberCoacheMinAggregateOutputType | null
    _max: MemberCoacheMaxAggregateOutputType | null
  }

  export type MemberCoacheAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    ord: number | null
  }

  export type MemberCoacheSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    ord: number | null
  }

  export type MemberCoacheMinAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    licenseNumber: string | null
    certification: string | null
    specialization: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCoacheMaxAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    licenseNumber: string | null
    certification: string | null
    specialization: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCoacheCountAggregateOutputType = {
    id: number
    personId: number
    licenseNumber: number
    certification: number
    specialization: number
    emergencyContactName: number
    emergencyContactPhone: number
    status: number
    bio: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberCoacheAvgAggregateInputType = {
    id?: true
    personId?: true
    ord?: true
  }

  export type MemberCoacheSumAggregateInputType = {
    id?: true
    personId?: true
    ord?: true
  }

  export type MemberCoacheMinAggregateInputType = {
    id?: true
    personId?: true
    licenseNumber?: true
    certification?: true
    specialization?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCoacheMaxAggregateInputType = {
    id?: true
    personId?: true
    licenseNumber?: true
    certification?: true
    specialization?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCoacheCountAggregateInputType = {
    id?: true
    personId?: true
    licenseNumber?: true
    certification?: true
    specialization?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberCoacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberCoache to aggregate.
     */
    where?: MemberCoacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCoaches to fetch.
     */
    orderBy?: MemberCoacheOrderByWithRelationInput | MemberCoacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberCoacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberCoaches
    **/
    _count?: true | MemberCoacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberCoacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberCoacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberCoacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberCoacheMaxAggregateInputType
  }

  export type GetMemberCoacheAggregateType<T extends MemberCoacheAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberCoache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberCoache[P]>
      : GetScalarType<T[P], AggregateMemberCoache[P]>
  }




  export type MemberCoacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberCoacheWhereInput
    orderBy?: MemberCoacheOrderByWithAggregationInput | MemberCoacheOrderByWithAggregationInput[]
    by: MemberCoacheScalarFieldEnum[] | MemberCoacheScalarFieldEnum
    having?: MemberCoacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCoacheCountAggregateInputType | true
    _avg?: MemberCoacheAvgAggregateInputType
    _sum?: MemberCoacheSumAggregateInputType
    _min?: MemberCoacheMinAggregateInputType
    _max?: MemberCoacheMaxAggregateInputType
  }

  export type MemberCoacheGroupByOutputType = {
    id: Decimal
    personId: Decimal
    licenseNumber: string | null
    certification: string | null
    specialization: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberCoacheCountAggregateOutputType | null
    _avg: MemberCoacheAvgAggregateOutputType | null
    _sum: MemberCoacheSumAggregateOutputType | null
    _min: MemberCoacheMinAggregateOutputType | null
    _max: MemberCoacheMaxAggregateOutputType | null
  }

  type GetMemberCoacheGroupByPayload<T extends MemberCoacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberCoacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberCoacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberCoacheGroupByOutputType[P]>
            : GetScalarType<T[P], MemberCoacheGroupByOutputType[P]>
        }
      >
    >


  export type MemberCoacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    certification?: boolean
    specialization?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberCoache"]>

  export type MemberCoacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    certification?: boolean
    specialization?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberCoache"]>

  export type MemberCoacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    certification?: boolean
    specialization?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberCoache"]>

  export type MemberCoacheSelectScalar = {
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    certification?: boolean
    specialization?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberCoacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "licenseNumber" | "certification" | "specialization" | "emergencyContactName" | "emergencyContactPhone" | "status" | "bio" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberCoache"]>

  export type $MemberCoachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberCoache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      personId: Prisma.Decimal
      licenseNumber: string | null
      certification: string | null
      specialization: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      status: string
      bio: string | null
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberCoache"]>
    composites: {}
  }

  type MemberCoacheGetPayload<S extends boolean | null | undefined | MemberCoacheDefaultArgs> = $Result.GetResult<Prisma.$MemberCoachePayload, S>

  type MemberCoacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberCoacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCoacheCountAggregateInputType | true
    }

  export interface MemberCoacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberCoache'], meta: { name: 'MemberCoache' } }
    /**
     * Find zero or one MemberCoache that matches the filter.
     * @param {MemberCoacheFindUniqueArgs} args - Arguments to find a MemberCoache
     * @example
     * // Get one MemberCoache
     * const memberCoache = await prisma.memberCoache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberCoacheFindUniqueArgs>(args: SelectSubset<T, MemberCoacheFindUniqueArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberCoache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberCoacheFindUniqueOrThrowArgs} args - Arguments to find a MemberCoache
     * @example
     * // Get one MemberCoache
     * const memberCoache = await prisma.memberCoache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberCoacheFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberCoacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberCoache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheFindFirstArgs} args - Arguments to find a MemberCoache
     * @example
     * // Get one MemberCoache
     * const memberCoache = await prisma.memberCoache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberCoacheFindFirstArgs>(args?: SelectSubset<T, MemberCoacheFindFirstArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberCoache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheFindFirstOrThrowArgs} args - Arguments to find a MemberCoache
     * @example
     * // Get one MemberCoache
     * const memberCoache = await prisma.memberCoache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberCoacheFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberCoacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberCoaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberCoaches
     * const memberCoaches = await prisma.memberCoache.findMany()
     * 
     * // Get first 10 MemberCoaches
     * const memberCoaches = await prisma.memberCoache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberCoacheWithIdOnly = await prisma.memberCoache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberCoacheFindManyArgs>(args?: SelectSubset<T, MemberCoacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberCoache.
     * @param {MemberCoacheCreateArgs} args - Arguments to create a MemberCoache.
     * @example
     * // Create one MemberCoache
     * const MemberCoache = await prisma.memberCoache.create({
     *   data: {
     *     // ... data to create a MemberCoache
     *   }
     * })
     * 
     */
    create<T extends MemberCoacheCreateArgs>(args: SelectSubset<T, MemberCoacheCreateArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberCoaches.
     * @param {MemberCoacheCreateManyArgs} args - Arguments to create many MemberCoaches.
     * @example
     * // Create many MemberCoaches
     * const memberCoache = await prisma.memberCoache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCoacheCreateManyArgs>(args?: SelectSubset<T, MemberCoacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberCoaches and returns the data saved in the database.
     * @param {MemberCoacheCreateManyAndReturnArgs} args - Arguments to create many MemberCoaches.
     * @example
     * // Create many MemberCoaches
     * const memberCoache = await prisma.memberCoache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberCoaches and only return the `id`
     * const memberCoacheWithIdOnly = await prisma.memberCoache.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCoacheCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCoacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberCoache.
     * @param {MemberCoacheDeleteArgs} args - Arguments to delete one MemberCoache.
     * @example
     * // Delete one MemberCoache
     * const MemberCoache = await prisma.memberCoache.delete({
     *   where: {
     *     // ... filter to delete one MemberCoache
     *   }
     * })
     * 
     */
    delete<T extends MemberCoacheDeleteArgs>(args: SelectSubset<T, MemberCoacheDeleteArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberCoache.
     * @param {MemberCoacheUpdateArgs} args - Arguments to update one MemberCoache.
     * @example
     * // Update one MemberCoache
     * const memberCoache = await prisma.memberCoache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberCoacheUpdateArgs>(args: SelectSubset<T, MemberCoacheUpdateArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberCoaches.
     * @param {MemberCoacheDeleteManyArgs} args - Arguments to filter MemberCoaches to delete.
     * @example
     * // Delete a few MemberCoaches
     * const { count } = await prisma.memberCoache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberCoacheDeleteManyArgs>(args?: SelectSubset<T, MemberCoacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberCoaches
     * const memberCoache = await prisma.memberCoache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberCoacheUpdateManyArgs>(args: SelectSubset<T, MemberCoacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberCoaches and returns the data updated in the database.
     * @param {MemberCoacheUpdateManyAndReturnArgs} args - Arguments to update many MemberCoaches.
     * @example
     * // Update many MemberCoaches
     * const memberCoache = await prisma.memberCoache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberCoaches and only return the `id`
     * const memberCoacheWithIdOnly = await prisma.memberCoache.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberCoacheUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberCoacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberCoache.
     * @param {MemberCoacheUpsertArgs} args - Arguments to update or create a MemberCoache.
     * @example
     * // Update or create a MemberCoache
     * const memberCoache = await prisma.memberCoache.upsert({
     *   create: {
     *     // ... data to create a MemberCoache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberCoache we want to update
     *   }
     * })
     */
    upsert<T extends MemberCoacheUpsertArgs>(args: SelectSubset<T, MemberCoacheUpsertArgs<ExtArgs>>): Prisma__MemberCoacheClient<$Result.GetResult<Prisma.$MemberCoachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheCountArgs} args - Arguments to filter MemberCoaches to count.
     * @example
     * // Count the number of MemberCoaches
     * const count = await prisma.memberCoache.count({
     *   where: {
     *     // ... the filter for the MemberCoaches we want to count
     *   }
     * })
    **/
    count<T extends MemberCoacheCountArgs>(
      args?: Subset<T, MemberCoacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCoacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberCoache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberCoacheAggregateArgs>(args: Subset<T, MemberCoacheAggregateArgs>): Prisma.PrismaPromise<GetMemberCoacheAggregateType<T>>

    /**
     * Group by MemberCoache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCoacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberCoacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberCoacheGroupByArgs['orderBy'] }
        : { orderBy?: MemberCoacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberCoacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberCoacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberCoache model
   */
  readonly fields: MemberCoacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberCoache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberCoacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberCoache model
   */
  interface MemberCoacheFieldRefs {
    readonly id: FieldRef<"MemberCoache", 'Decimal'>
    readonly personId: FieldRef<"MemberCoache", 'Decimal'>
    readonly licenseNumber: FieldRef<"MemberCoache", 'String'>
    readonly certification: FieldRef<"MemberCoache", 'String'>
    readonly specialization: FieldRef<"MemberCoache", 'String'>
    readonly emergencyContactName: FieldRef<"MemberCoache", 'String'>
    readonly emergencyContactPhone: FieldRef<"MemberCoache", 'String'>
    readonly status: FieldRef<"MemberCoache", 'String'>
    readonly bio: FieldRef<"MemberCoache", 'String'>
    readonly ord: FieldRef<"MemberCoache", 'Int'>
    readonly createdAt: FieldRef<"MemberCoache", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberCoache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberCoache findUnique
   */
  export type MemberCoacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * Filter, which MemberCoache to fetch.
     */
    where: MemberCoacheWhereUniqueInput
  }

  /**
   * MemberCoache findUniqueOrThrow
   */
  export type MemberCoacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * Filter, which MemberCoache to fetch.
     */
    where: MemberCoacheWhereUniqueInput
  }

  /**
   * MemberCoache findFirst
   */
  export type MemberCoacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * Filter, which MemberCoache to fetch.
     */
    where?: MemberCoacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCoaches to fetch.
     */
    orderBy?: MemberCoacheOrderByWithRelationInput | MemberCoacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCoaches.
     */
    cursor?: MemberCoacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCoaches.
     */
    distinct?: MemberCoacheScalarFieldEnum | MemberCoacheScalarFieldEnum[]
  }

  /**
   * MemberCoache findFirstOrThrow
   */
  export type MemberCoacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * Filter, which MemberCoache to fetch.
     */
    where?: MemberCoacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCoaches to fetch.
     */
    orderBy?: MemberCoacheOrderByWithRelationInput | MemberCoacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCoaches.
     */
    cursor?: MemberCoacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCoaches.
     */
    distinct?: MemberCoacheScalarFieldEnum | MemberCoacheScalarFieldEnum[]
  }

  /**
   * MemberCoache findMany
   */
  export type MemberCoacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * Filter, which MemberCoaches to fetch.
     */
    where?: MemberCoacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCoaches to fetch.
     */
    orderBy?: MemberCoacheOrderByWithRelationInput | MemberCoacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberCoaches.
     */
    cursor?: MemberCoacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCoaches.
     */
    skip?: number
    distinct?: MemberCoacheScalarFieldEnum | MemberCoacheScalarFieldEnum[]
  }

  /**
   * MemberCoache create
   */
  export type MemberCoacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberCoache.
     */
    data: XOR<MemberCoacheCreateInput, MemberCoacheUncheckedCreateInput>
  }

  /**
   * MemberCoache createMany
   */
  export type MemberCoacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberCoaches.
     */
    data: MemberCoacheCreateManyInput | MemberCoacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberCoache createManyAndReturn
   */
  export type MemberCoacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * The data used to create many MemberCoaches.
     */
    data: MemberCoacheCreateManyInput | MemberCoacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberCoache update
   */
  export type MemberCoacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberCoache.
     */
    data: XOR<MemberCoacheUpdateInput, MemberCoacheUncheckedUpdateInput>
    /**
     * Choose, which MemberCoache to update.
     */
    where: MemberCoacheWhereUniqueInput
  }

  /**
   * MemberCoache updateMany
   */
  export type MemberCoacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberCoaches.
     */
    data: XOR<MemberCoacheUpdateManyMutationInput, MemberCoacheUncheckedUpdateManyInput>
    /**
     * Filter which MemberCoaches to update
     */
    where?: MemberCoacheWhereInput
    /**
     * Limit how many MemberCoaches to update.
     */
    limit?: number
  }

  /**
   * MemberCoache updateManyAndReturn
   */
  export type MemberCoacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * The data used to update MemberCoaches.
     */
    data: XOR<MemberCoacheUpdateManyMutationInput, MemberCoacheUncheckedUpdateManyInput>
    /**
     * Filter which MemberCoaches to update
     */
    where?: MemberCoacheWhereInput
    /**
     * Limit how many MemberCoaches to update.
     */
    limit?: number
  }

  /**
   * MemberCoache upsert
   */
  export type MemberCoacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberCoache to update in case it exists.
     */
    where: MemberCoacheWhereUniqueInput
    /**
     * In case the MemberCoache found by the `where` argument doesn't exist, create a new MemberCoache with this data.
     */
    create: XOR<MemberCoacheCreateInput, MemberCoacheUncheckedCreateInput>
    /**
     * In case the MemberCoache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberCoacheUpdateInput, MemberCoacheUncheckedUpdateInput>
  }

  /**
   * MemberCoache delete
   */
  export type MemberCoacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
    /**
     * Filter which MemberCoache to delete.
     */
    where: MemberCoacheWhereUniqueInput
  }

  /**
   * MemberCoache deleteMany
   */
  export type MemberCoacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberCoaches to delete
     */
    where?: MemberCoacheWhereInput
    /**
     * Limit how many MemberCoaches to delete.
     */
    limit?: number
  }

  /**
   * MemberCoache without action
   */
  export type MemberCoacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCoache
     */
    select?: MemberCoacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberCoache
     */
    omit?: MemberCoacheOmit<ExtArgs> | null
  }


  /**
   * Model MemberParent
   */

  export type AggregateMemberParent = {
    _count: MemberParentCountAggregateOutputType | null
    _avg: MemberParentAvgAggregateOutputType | null
    _sum: MemberParentSumAggregateOutputType | null
    _min: MemberParentMinAggregateOutputType | null
    _max: MemberParentMaxAggregateOutputType | null
  }

  export type MemberParentAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    ord: number | null
  }

  export type MemberParentSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    ord: number | null
  }

  export type MemberParentMinAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberParentMaxAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberParentCountAggregateOutputType = {
    id: number
    personId: number
    status: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberParentAvgAggregateInputType = {
    id?: true
    personId?: true
    ord?: true
  }

  export type MemberParentSumAggregateInputType = {
    id?: true
    personId?: true
    ord?: true
  }

  export type MemberParentMinAggregateInputType = {
    id?: true
    personId?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberParentMaxAggregateInputType = {
    id?: true
    personId?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberParentCountAggregateInputType = {
    id?: true
    personId?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberParent to aggregate.
     */
    where?: MemberParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberParents to fetch.
     */
    orderBy?: MemberParentOrderByWithRelationInput | MemberParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberParents
    **/
    _count?: true | MemberParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberParentMaxAggregateInputType
  }

  export type GetMemberParentAggregateType<T extends MemberParentAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberParent[P]>
      : GetScalarType<T[P], AggregateMemberParent[P]>
  }




  export type MemberParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberParentWhereInput
    orderBy?: MemberParentOrderByWithAggregationInput | MemberParentOrderByWithAggregationInput[]
    by: MemberParentScalarFieldEnum[] | MemberParentScalarFieldEnum
    having?: MemberParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberParentCountAggregateInputType | true
    _avg?: MemberParentAvgAggregateInputType
    _sum?: MemberParentSumAggregateInputType
    _min?: MemberParentMinAggregateInputType
    _max?: MemberParentMaxAggregateInputType
  }

  export type MemberParentGroupByOutputType = {
    id: Decimal
    personId: Decimal
    status: string
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberParentCountAggregateOutputType | null
    _avg: MemberParentAvgAggregateOutputType | null
    _sum: MemberParentSumAggregateOutputType | null
    _min: MemberParentMinAggregateOutputType | null
    _max: MemberParentMaxAggregateOutputType | null
  }

  type GetMemberParentGroupByPayload<T extends MemberParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberParentGroupByOutputType[P]>
            : GetScalarType<T[P], MemberParentGroupByOutputType[P]>
        }
      >
    >


  export type MemberParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberParent"]>

  export type MemberParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberParent"]>

  export type MemberParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberParent"]>

  export type MemberParentSelectScalar = {
    id?: boolean
    personId?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "status" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberParent"]>

  export type $MemberParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberParent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      personId: Prisma.Decimal
      status: string
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberParent"]>
    composites: {}
  }

  type MemberParentGetPayload<S extends boolean | null | undefined | MemberParentDefaultArgs> = $Result.GetResult<Prisma.$MemberParentPayload, S>

  type MemberParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberParentCountAggregateInputType | true
    }

  export interface MemberParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberParent'], meta: { name: 'MemberParent' } }
    /**
     * Find zero or one MemberParent that matches the filter.
     * @param {MemberParentFindUniqueArgs} args - Arguments to find a MemberParent
     * @example
     * // Get one MemberParent
     * const memberParent = await prisma.memberParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberParentFindUniqueArgs>(args: SelectSubset<T, MemberParentFindUniqueArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberParent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberParentFindUniqueOrThrowArgs} args - Arguments to find a MemberParent
     * @example
     * // Get one MemberParent
     * const memberParent = await prisma.memberParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberParentFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentFindFirstArgs} args - Arguments to find a MemberParent
     * @example
     * // Get one MemberParent
     * const memberParent = await prisma.memberParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberParentFindFirstArgs>(args?: SelectSubset<T, MemberParentFindFirstArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentFindFirstOrThrowArgs} args - Arguments to find a MemberParent
     * @example
     * // Get one MemberParent
     * const memberParent = await prisma.memberParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberParentFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberParents
     * const memberParents = await prisma.memberParent.findMany()
     * 
     * // Get first 10 MemberParents
     * const memberParents = await prisma.memberParent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberParentWithIdOnly = await prisma.memberParent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberParentFindManyArgs>(args?: SelectSubset<T, MemberParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberParent.
     * @param {MemberParentCreateArgs} args - Arguments to create a MemberParent.
     * @example
     * // Create one MemberParent
     * const MemberParent = await prisma.memberParent.create({
     *   data: {
     *     // ... data to create a MemberParent
     *   }
     * })
     * 
     */
    create<T extends MemberParentCreateArgs>(args: SelectSubset<T, MemberParentCreateArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberParents.
     * @param {MemberParentCreateManyArgs} args - Arguments to create many MemberParents.
     * @example
     * // Create many MemberParents
     * const memberParent = await prisma.memberParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberParentCreateManyArgs>(args?: SelectSubset<T, MemberParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberParents and returns the data saved in the database.
     * @param {MemberParentCreateManyAndReturnArgs} args - Arguments to create many MemberParents.
     * @example
     * // Create many MemberParents
     * const memberParent = await prisma.memberParent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberParents and only return the `id`
     * const memberParentWithIdOnly = await prisma.memberParent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberParentCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberParent.
     * @param {MemberParentDeleteArgs} args - Arguments to delete one MemberParent.
     * @example
     * // Delete one MemberParent
     * const MemberParent = await prisma.memberParent.delete({
     *   where: {
     *     // ... filter to delete one MemberParent
     *   }
     * })
     * 
     */
    delete<T extends MemberParentDeleteArgs>(args: SelectSubset<T, MemberParentDeleteArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberParent.
     * @param {MemberParentUpdateArgs} args - Arguments to update one MemberParent.
     * @example
     * // Update one MemberParent
     * const memberParent = await prisma.memberParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberParentUpdateArgs>(args: SelectSubset<T, MemberParentUpdateArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberParents.
     * @param {MemberParentDeleteManyArgs} args - Arguments to filter MemberParents to delete.
     * @example
     * // Delete a few MemberParents
     * const { count } = await prisma.memberParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberParentDeleteManyArgs>(args?: SelectSubset<T, MemberParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberParents
     * const memberParent = await prisma.memberParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberParentUpdateManyArgs>(args: SelectSubset<T, MemberParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberParents and returns the data updated in the database.
     * @param {MemberParentUpdateManyAndReturnArgs} args - Arguments to update many MemberParents.
     * @example
     * // Update many MemberParents
     * const memberParent = await prisma.memberParent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberParents and only return the `id`
     * const memberParentWithIdOnly = await prisma.memberParent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberParentUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberParent.
     * @param {MemberParentUpsertArgs} args - Arguments to update or create a MemberParent.
     * @example
     * // Update or create a MemberParent
     * const memberParent = await prisma.memberParent.upsert({
     *   create: {
     *     // ... data to create a MemberParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberParent we want to update
     *   }
     * })
     */
    upsert<T extends MemberParentUpsertArgs>(args: SelectSubset<T, MemberParentUpsertArgs<ExtArgs>>): Prisma__MemberParentClient<$Result.GetResult<Prisma.$MemberParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentCountArgs} args - Arguments to filter MemberParents to count.
     * @example
     * // Count the number of MemberParents
     * const count = await prisma.memberParent.count({
     *   where: {
     *     // ... the filter for the MemberParents we want to count
     *   }
     * })
    **/
    count<T extends MemberParentCountArgs>(
      args?: Subset<T, MemberParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberParentAggregateArgs>(args: Subset<T, MemberParentAggregateArgs>): Prisma.PrismaPromise<GetMemberParentAggregateType<T>>

    /**
     * Group by MemberParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberParentGroupByArgs['orderBy'] }
        : { orderBy?: MemberParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberParent model
   */
  readonly fields: MemberParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberParent model
   */
  interface MemberParentFieldRefs {
    readonly id: FieldRef<"MemberParent", 'Decimal'>
    readonly personId: FieldRef<"MemberParent", 'Decimal'>
    readonly status: FieldRef<"MemberParent", 'String'>
    readonly notes: FieldRef<"MemberParent", 'String'>
    readonly ord: FieldRef<"MemberParent", 'Int'>
    readonly createdAt: FieldRef<"MemberParent", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberParent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberParent findUnique
   */
  export type MemberParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * Filter, which MemberParent to fetch.
     */
    where: MemberParentWhereUniqueInput
  }

  /**
   * MemberParent findUniqueOrThrow
   */
  export type MemberParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * Filter, which MemberParent to fetch.
     */
    where: MemberParentWhereUniqueInput
  }

  /**
   * MemberParent findFirst
   */
  export type MemberParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * Filter, which MemberParent to fetch.
     */
    where?: MemberParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberParents to fetch.
     */
    orderBy?: MemberParentOrderByWithRelationInput | MemberParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberParents.
     */
    cursor?: MemberParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberParents.
     */
    distinct?: MemberParentScalarFieldEnum | MemberParentScalarFieldEnum[]
  }

  /**
   * MemberParent findFirstOrThrow
   */
  export type MemberParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * Filter, which MemberParent to fetch.
     */
    where?: MemberParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberParents to fetch.
     */
    orderBy?: MemberParentOrderByWithRelationInput | MemberParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberParents.
     */
    cursor?: MemberParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberParents.
     */
    distinct?: MemberParentScalarFieldEnum | MemberParentScalarFieldEnum[]
  }

  /**
   * MemberParent findMany
   */
  export type MemberParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * Filter, which MemberParents to fetch.
     */
    where?: MemberParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberParents to fetch.
     */
    orderBy?: MemberParentOrderByWithRelationInput | MemberParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberParents.
     */
    cursor?: MemberParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberParents.
     */
    skip?: number
    distinct?: MemberParentScalarFieldEnum | MemberParentScalarFieldEnum[]
  }

  /**
   * MemberParent create
   */
  export type MemberParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberParent.
     */
    data: XOR<MemberParentCreateInput, MemberParentUncheckedCreateInput>
  }

  /**
   * MemberParent createMany
   */
  export type MemberParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberParents.
     */
    data: MemberParentCreateManyInput | MemberParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberParent createManyAndReturn
   */
  export type MemberParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * The data used to create many MemberParents.
     */
    data: MemberParentCreateManyInput | MemberParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberParent update
   */
  export type MemberParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberParent.
     */
    data: XOR<MemberParentUpdateInput, MemberParentUncheckedUpdateInput>
    /**
     * Choose, which MemberParent to update.
     */
    where: MemberParentWhereUniqueInput
  }

  /**
   * MemberParent updateMany
   */
  export type MemberParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberParents.
     */
    data: XOR<MemberParentUpdateManyMutationInput, MemberParentUncheckedUpdateManyInput>
    /**
     * Filter which MemberParents to update
     */
    where?: MemberParentWhereInput
    /**
     * Limit how many MemberParents to update.
     */
    limit?: number
  }

  /**
   * MemberParent updateManyAndReturn
   */
  export type MemberParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * The data used to update MemberParents.
     */
    data: XOR<MemberParentUpdateManyMutationInput, MemberParentUncheckedUpdateManyInput>
    /**
     * Filter which MemberParents to update
     */
    where?: MemberParentWhereInput
    /**
     * Limit how many MemberParents to update.
     */
    limit?: number
  }

  /**
   * MemberParent upsert
   */
  export type MemberParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberParent to update in case it exists.
     */
    where: MemberParentWhereUniqueInput
    /**
     * In case the MemberParent found by the `where` argument doesn't exist, create a new MemberParent with this data.
     */
    create: XOR<MemberParentCreateInput, MemberParentUncheckedCreateInput>
    /**
     * In case the MemberParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberParentUpdateInput, MemberParentUncheckedUpdateInput>
  }

  /**
   * MemberParent delete
   */
  export type MemberParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
    /**
     * Filter which MemberParent to delete.
     */
    where: MemberParentWhereUniqueInput
  }

  /**
   * MemberParent deleteMany
   */
  export type MemberParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberParents to delete
     */
    where?: MemberParentWhereInput
    /**
     * Limit how many MemberParents to delete.
     */
    limit?: number
  }

  /**
   * MemberParent without action
   */
  export type MemberParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberParent
     */
    select?: MemberParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberParent
     */
    omit?: MemberParentOmit<ExtArgs> | null
  }


  /**
   * Model MemberPerson
   */

  export type AggregateMemberPerson = {
    _count: MemberPersonCountAggregateOutputType | null
    _avg: MemberPersonAvgAggregateOutputType | null
    _sum: MemberPersonSumAggregateOutputType | null
    _min: MemberPersonMinAggregateOutputType | null
    _max: MemberPersonMaxAggregateOutputType | null
  }

  export type MemberPersonAvgAggregateOutputType = {
    id: Decimal | null
    countryId: Decimal | null
  }

  export type MemberPersonSumAggregateOutputType = {
    id: Decimal | null
    countryId: Decimal | null
  }

  export type MemberPersonMinAggregateOutputType = {
    id: Decimal | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dob: Date | null
    gender: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    countryId: Decimal | null
    photoPath: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberPersonMaxAggregateOutputType = {
    id: Decimal | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dob: Date | null
    gender: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    countryId: Decimal | null
    photoPath: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberPersonCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    dob: number
    gender: number
    address: number
    city: number
    state: number
    zipCode: number
    countryId: number
    photoPath: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberPersonAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type MemberPersonSumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type MemberPersonMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dob?: true
    gender?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    countryId?: true
    photoPath?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberPersonMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dob?: true
    gender?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    countryId?: true
    photoPath?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberPersonCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dob?: true
    gender?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    countryId?: true
    photoPath?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberPersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberPerson to aggregate.
     */
    where?: MemberPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPeople to fetch.
     */
    orderBy?: MemberPersonOrderByWithRelationInput | MemberPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberPeople
    **/
    _count?: true | MemberPersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberPersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberPersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberPersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberPersonMaxAggregateInputType
  }

  export type GetMemberPersonAggregateType<T extends MemberPersonAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberPerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberPerson[P]>
      : GetScalarType<T[P], AggregateMemberPerson[P]>
  }




  export type MemberPersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberPersonWhereInput
    orderBy?: MemberPersonOrderByWithAggregationInput | MemberPersonOrderByWithAggregationInput[]
    by: MemberPersonScalarFieldEnum[] | MemberPersonScalarFieldEnum
    having?: MemberPersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberPersonCountAggregateInputType | true
    _avg?: MemberPersonAvgAggregateInputType
    _sum?: MemberPersonSumAggregateInputType
    _min?: MemberPersonMinAggregateInputType
    _max?: MemberPersonMaxAggregateInputType
  }

  export type MemberPersonGroupByOutputType = {
    id: Decimal
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    dob: Date | null
    gender: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    countryId: Decimal | null
    photoPath: string | null
    status: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberPersonCountAggregateOutputType | null
    _avg: MemberPersonAvgAggregateOutputType | null
    _sum: MemberPersonSumAggregateOutputType | null
    _min: MemberPersonMinAggregateOutputType | null
    _max: MemberPersonMaxAggregateOutputType | null
  }

  type GetMemberPersonGroupByPayload<T extends MemberPersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberPersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberPersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberPersonGroupByOutputType[P]>
            : GetScalarType<T[P], MemberPersonGroupByOutputType[P]>
        }
      >
    >


  export type MemberPersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dob?: boolean
    gender?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    countryId?: boolean
    photoPath?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberPerson"]>

  export type MemberPersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dob?: boolean
    gender?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    countryId?: boolean
    photoPath?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberPerson"]>

  export type MemberPersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dob?: boolean
    gender?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    countryId?: boolean
    photoPath?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberPerson"]>

  export type MemberPersonSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dob?: boolean
    gender?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    countryId?: boolean
    photoPath?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberPersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "phone" | "dob" | "gender" | "address" | "city" | "state" | "zipCode" | "countryId" | "photoPath" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["memberPerson"]>

  export type $MemberPersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberPerson"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      dob: Date | null
      gender: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      countryId: Prisma.Decimal | null
      photoPath: string | null
      status: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberPerson"]>
    composites: {}
  }

  type MemberPersonGetPayload<S extends boolean | null | undefined | MemberPersonDefaultArgs> = $Result.GetResult<Prisma.$MemberPersonPayload, S>

  type MemberPersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberPersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberPersonCountAggregateInputType | true
    }

  export interface MemberPersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberPerson'], meta: { name: 'MemberPerson' } }
    /**
     * Find zero or one MemberPerson that matches the filter.
     * @param {MemberPersonFindUniqueArgs} args - Arguments to find a MemberPerson
     * @example
     * // Get one MemberPerson
     * const memberPerson = await prisma.memberPerson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberPersonFindUniqueArgs>(args: SelectSubset<T, MemberPersonFindUniqueArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberPerson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberPersonFindUniqueOrThrowArgs} args - Arguments to find a MemberPerson
     * @example
     * // Get one MemberPerson
     * const memberPerson = await prisma.memberPerson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberPersonFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberPersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberPerson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonFindFirstArgs} args - Arguments to find a MemberPerson
     * @example
     * // Get one MemberPerson
     * const memberPerson = await prisma.memberPerson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberPersonFindFirstArgs>(args?: SelectSubset<T, MemberPersonFindFirstArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberPerson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonFindFirstOrThrowArgs} args - Arguments to find a MemberPerson
     * @example
     * // Get one MemberPerson
     * const memberPerson = await prisma.memberPerson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberPersonFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberPersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberPeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberPeople
     * const memberPeople = await prisma.memberPerson.findMany()
     * 
     * // Get first 10 MemberPeople
     * const memberPeople = await prisma.memberPerson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberPersonWithIdOnly = await prisma.memberPerson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberPersonFindManyArgs>(args?: SelectSubset<T, MemberPersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberPerson.
     * @param {MemberPersonCreateArgs} args - Arguments to create a MemberPerson.
     * @example
     * // Create one MemberPerson
     * const MemberPerson = await prisma.memberPerson.create({
     *   data: {
     *     // ... data to create a MemberPerson
     *   }
     * })
     * 
     */
    create<T extends MemberPersonCreateArgs>(args: SelectSubset<T, MemberPersonCreateArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberPeople.
     * @param {MemberPersonCreateManyArgs} args - Arguments to create many MemberPeople.
     * @example
     * // Create many MemberPeople
     * const memberPerson = await prisma.memberPerson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberPersonCreateManyArgs>(args?: SelectSubset<T, MemberPersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberPeople and returns the data saved in the database.
     * @param {MemberPersonCreateManyAndReturnArgs} args - Arguments to create many MemberPeople.
     * @example
     * // Create many MemberPeople
     * const memberPerson = await prisma.memberPerson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberPeople and only return the `id`
     * const memberPersonWithIdOnly = await prisma.memberPerson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberPersonCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberPersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberPerson.
     * @param {MemberPersonDeleteArgs} args - Arguments to delete one MemberPerson.
     * @example
     * // Delete one MemberPerson
     * const MemberPerson = await prisma.memberPerson.delete({
     *   where: {
     *     // ... filter to delete one MemberPerson
     *   }
     * })
     * 
     */
    delete<T extends MemberPersonDeleteArgs>(args: SelectSubset<T, MemberPersonDeleteArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberPerson.
     * @param {MemberPersonUpdateArgs} args - Arguments to update one MemberPerson.
     * @example
     * // Update one MemberPerson
     * const memberPerson = await prisma.memberPerson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberPersonUpdateArgs>(args: SelectSubset<T, MemberPersonUpdateArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberPeople.
     * @param {MemberPersonDeleteManyArgs} args - Arguments to filter MemberPeople to delete.
     * @example
     * // Delete a few MemberPeople
     * const { count } = await prisma.memberPerson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberPersonDeleteManyArgs>(args?: SelectSubset<T, MemberPersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberPeople
     * const memberPerson = await prisma.memberPerson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberPersonUpdateManyArgs>(args: SelectSubset<T, MemberPersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberPeople and returns the data updated in the database.
     * @param {MemberPersonUpdateManyAndReturnArgs} args - Arguments to update many MemberPeople.
     * @example
     * // Update many MemberPeople
     * const memberPerson = await prisma.memberPerson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberPeople and only return the `id`
     * const memberPersonWithIdOnly = await prisma.memberPerson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberPersonUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberPersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberPerson.
     * @param {MemberPersonUpsertArgs} args - Arguments to update or create a MemberPerson.
     * @example
     * // Update or create a MemberPerson
     * const memberPerson = await prisma.memberPerson.upsert({
     *   create: {
     *     // ... data to create a MemberPerson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberPerson we want to update
     *   }
     * })
     */
    upsert<T extends MemberPersonUpsertArgs>(args: SelectSubset<T, MemberPersonUpsertArgs<ExtArgs>>): Prisma__MemberPersonClient<$Result.GetResult<Prisma.$MemberPersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberPeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonCountArgs} args - Arguments to filter MemberPeople to count.
     * @example
     * // Count the number of MemberPeople
     * const count = await prisma.memberPerson.count({
     *   where: {
     *     // ... the filter for the MemberPeople we want to count
     *   }
     * })
    **/
    count<T extends MemberPersonCountArgs>(
      args?: Subset<T, MemberPersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberPersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberPersonAggregateArgs>(args: Subset<T, MemberPersonAggregateArgs>): Prisma.PrismaPromise<GetMemberPersonAggregateType<T>>

    /**
     * Group by MemberPerson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberPersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberPersonGroupByArgs['orderBy'] }
        : { orderBy?: MemberPersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberPersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberPerson model
   */
  readonly fields: MemberPersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberPerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberPersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberPerson model
   */
  interface MemberPersonFieldRefs {
    readonly id: FieldRef<"MemberPerson", 'Decimal'>
    readonly firstName: FieldRef<"MemberPerson", 'String'>
    readonly lastName: FieldRef<"MemberPerson", 'String'>
    readonly email: FieldRef<"MemberPerson", 'String'>
    readonly phone: FieldRef<"MemberPerson", 'String'>
    readonly dob: FieldRef<"MemberPerson", 'DateTime'>
    readonly gender: FieldRef<"MemberPerson", 'String'>
    readonly address: FieldRef<"MemberPerson", 'String'>
    readonly city: FieldRef<"MemberPerson", 'String'>
    readonly state: FieldRef<"MemberPerson", 'String'>
    readonly zipCode: FieldRef<"MemberPerson", 'String'>
    readonly countryId: FieldRef<"MemberPerson", 'Decimal'>
    readonly photoPath: FieldRef<"MemberPerson", 'String'>
    readonly status: FieldRef<"MemberPerson", 'String'>
    readonly createdAt: FieldRef<"MemberPerson", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberPerson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberPerson findUnique
   */
  export type MemberPersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * Filter, which MemberPerson to fetch.
     */
    where: MemberPersonWhereUniqueInput
  }

  /**
   * MemberPerson findUniqueOrThrow
   */
  export type MemberPersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * Filter, which MemberPerson to fetch.
     */
    where: MemberPersonWhereUniqueInput
  }

  /**
   * MemberPerson findFirst
   */
  export type MemberPersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * Filter, which MemberPerson to fetch.
     */
    where?: MemberPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPeople to fetch.
     */
    orderBy?: MemberPersonOrderByWithRelationInput | MemberPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberPeople.
     */
    cursor?: MemberPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberPeople.
     */
    distinct?: MemberPersonScalarFieldEnum | MemberPersonScalarFieldEnum[]
  }

  /**
   * MemberPerson findFirstOrThrow
   */
  export type MemberPersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * Filter, which MemberPerson to fetch.
     */
    where?: MemberPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPeople to fetch.
     */
    orderBy?: MemberPersonOrderByWithRelationInput | MemberPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberPeople.
     */
    cursor?: MemberPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberPeople.
     */
    distinct?: MemberPersonScalarFieldEnum | MemberPersonScalarFieldEnum[]
  }

  /**
   * MemberPerson findMany
   */
  export type MemberPersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * Filter, which MemberPeople to fetch.
     */
    where?: MemberPersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPeople to fetch.
     */
    orderBy?: MemberPersonOrderByWithRelationInput | MemberPersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberPeople.
     */
    cursor?: MemberPersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPeople.
     */
    skip?: number
    distinct?: MemberPersonScalarFieldEnum | MemberPersonScalarFieldEnum[]
  }

  /**
   * MemberPerson create
   */
  export type MemberPersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberPerson.
     */
    data: XOR<MemberPersonCreateInput, MemberPersonUncheckedCreateInput>
  }

  /**
   * MemberPerson createMany
   */
  export type MemberPersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberPeople.
     */
    data: MemberPersonCreateManyInput | MemberPersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberPerson createManyAndReturn
   */
  export type MemberPersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * The data used to create many MemberPeople.
     */
    data: MemberPersonCreateManyInput | MemberPersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberPerson update
   */
  export type MemberPersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberPerson.
     */
    data: XOR<MemberPersonUpdateInput, MemberPersonUncheckedUpdateInput>
    /**
     * Choose, which MemberPerson to update.
     */
    where: MemberPersonWhereUniqueInput
  }

  /**
   * MemberPerson updateMany
   */
  export type MemberPersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberPeople.
     */
    data: XOR<MemberPersonUpdateManyMutationInput, MemberPersonUncheckedUpdateManyInput>
    /**
     * Filter which MemberPeople to update
     */
    where?: MemberPersonWhereInput
    /**
     * Limit how many MemberPeople to update.
     */
    limit?: number
  }

  /**
   * MemberPerson updateManyAndReturn
   */
  export type MemberPersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * The data used to update MemberPeople.
     */
    data: XOR<MemberPersonUpdateManyMutationInput, MemberPersonUncheckedUpdateManyInput>
    /**
     * Filter which MemberPeople to update
     */
    where?: MemberPersonWhereInput
    /**
     * Limit how many MemberPeople to update.
     */
    limit?: number
  }

  /**
   * MemberPerson upsert
   */
  export type MemberPersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberPerson to update in case it exists.
     */
    where: MemberPersonWhereUniqueInput
    /**
     * In case the MemberPerson found by the `where` argument doesn't exist, create a new MemberPerson with this data.
     */
    create: XOR<MemberPersonCreateInput, MemberPersonUncheckedCreateInput>
    /**
     * In case the MemberPerson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberPersonUpdateInput, MemberPersonUncheckedUpdateInput>
  }

  /**
   * MemberPerson delete
   */
  export type MemberPersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
    /**
     * Filter which MemberPerson to delete.
     */
    where: MemberPersonWhereUniqueInput
  }

  /**
   * MemberPerson deleteMany
   */
  export type MemberPersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberPeople to delete
     */
    where?: MemberPersonWhereInput
    /**
     * Limit how many MemberPeople to delete.
     */
    limit?: number
  }

  /**
   * MemberPerson without action
   */
  export type MemberPersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPerson
     */
    select?: MemberPersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPerson
     */
    omit?: MemberPersonOmit<ExtArgs> | null
  }


  /**
   * Model MemberPlayer
   */

  export type AggregateMemberPlayer = {
    _count: MemberPlayerCountAggregateOutputType | null
    _avg: MemberPlayerAvgAggregateOutputType | null
    _sum: MemberPlayerSumAggregateOutputType | null
    _min: MemberPlayerMinAggregateOutputType | null
    _max: MemberPlayerMaxAggregateOutputType | null
  }

  export type MemberPlayerAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    height: Decimal | null
    weight: Decimal | null
    ord: number | null
  }

  export type MemberPlayerSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    height: Decimal | null
    weight: Decimal | null
    ord: number | null
  }

  export type MemberPlayerMinAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    height: Decimal | null
    weight: Decimal | null
    preferredFoot: string | null
    contractStart: Date | null
    contractEnd: Date | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberPlayerMaxAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    height: Decimal | null
    weight: Decimal | null
    preferredFoot: string | null
    contractStart: Date | null
    contractEnd: Date | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberPlayerCountAggregateOutputType = {
    id: number
    personId: number
    height: number
    weight: number
    preferredFoot: number
    contractStart: number
    contractEnd: number
    emergencyContactName: number
    emergencyContactPhone: number
    status: number
    bio: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberPlayerAvgAggregateInputType = {
    id?: true
    personId?: true
    height?: true
    weight?: true
    ord?: true
  }

  export type MemberPlayerSumAggregateInputType = {
    id?: true
    personId?: true
    height?: true
    weight?: true
    ord?: true
  }

  export type MemberPlayerMinAggregateInputType = {
    id?: true
    personId?: true
    height?: true
    weight?: true
    preferredFoot?: true
    contractStart?: true
    contractEnd?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberPlayerMaxAggregateInputType = {
    id?: true
    personId?: true
    height?: true
    weight?: true
    preferredFoot?: true
    contractStart?: true
    contractEnd?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberPlayerCountAggregateInputType = {
    id?: true
    personId?: true
    height?: true
    weight?: true
    preferredFoot?: true
    contractStart?: true
    contractEnd?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberPlayer to aggregate.
     */
    where?: MemberPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPlayers to fetch.
     */
    orderBy?: MemberPlayerOrderByWithRelationInput | MemberPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberPlayers
    **/
    _count?: true | MemberPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberPlayerMaxAggregateInputType
  }

  export type GetMemberPlayerAggregateType<T extends MemberPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberPlayer[P]>
      : GetScalarType<T[P], AggregateMemberPlayer[P]>
  }




  export type MemberPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberPlayerWhereInput
    orderBy?: MemberPlayerOrderByWithAggregationInput | MemberPlayerOrderByWithAggregationInput[]
    by: MemberPlayerScalarFieldEnum[] | MemberPlayerScalarFieldEnum
    having?: MemberPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberPlayerCountAggregateInputType | true
    _avg?: MemberPlayerAvgAggregateInputType
    _sum?: MemberPlayerSumAggregateInputType
    _min?: MemberPlayerMinAggregateInputType
    _max?: MemberPlayerMaxAggregateInputType
  }

  export type MemberPlayerGroupByOutputType = {
    id: Decimal
    personId: Decimal
    height: Decimal | null
    weight: Decimal | null
    preferredFoot: string | null
    contractStart: Date | null
    contractEnd: Date | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string
    bio: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberPlayerCountAggregateOutputType | null
    _avg: MemberPlayerAvgAggregateOutputType | null
    _sum: MemberPlayerSumAggregateOutputType | null
    _min: MemberPlayerMinAggregateOutputType | null
    _max: MemberPlayerMaxAggregateOutputType | null
  }

  type GetMemberPlayerGroupByPayload<T extends MemberPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], MemberPlayerGroupByOutputType[P]>
        }
      >
    >


  export type MemberPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    height?: boolean
    weight?: boolean
    preferredFoot?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberPlayer"]>

  export type MemberPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    height?: boolean
    weight?: boolean
    preferredFoot?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberPlayer"]>

  export type MemberPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    height?: boolean
    weight?: boolean
    preferredFoot?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberPlayer"]>

  export type MemberPlayerSelectScalar = {
    id?: boolean
    personId?: boolean
    height?: boolean
    weight?: boolean
    preferredFoot?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "height" | "weight" | "preferredFoot" | "contractStart" | "contractEnd" | "emergencyContactName" | "emergencyContactPhone" | "status" | "bio" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberPlayer"]>

  export type $MemberPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberPlayer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      personId: Prisma.Decimal
      height: Prisma.Decimal | null
      weight: Prisma.Decimal | null
      preferredFoot: string | null
      contractStart: Date | null
      contractEnd: Date | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      status: string
      bio: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberPlayer"]>
    composites: {}
  }

  type MemberPlayerGetPayload<S extends boolean | null | undefined | MemberPlayerDefaultArgs> = $Result.GetResult<Prisma.$MemberPlayerPayload, S>

  type MemberPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberPlayerCountAggregateInputType | true
    }

  export interface MemberPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberPlayer'], meta: { name: 'MemberPlayer' } }
    /**
     * Find zero or one MemberPlayer that matches the filter.
     * @param {MemberPlayerFindUniqueArgs} args - Arguments to find a MemberPlayer
     * @example
     * // Get one MemberPlayer
     * const memberPlayer = await prisma.memberPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberPlayerFindUniqueArgs>(args: SelectSubset<T, MemberPlayerFindUniqueArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberPlayerFindUniqueOrThrowArgs} args - Arguments to find a MemberPlayer
     * @example
     * // Get one MemberPlayer
     * const memberPlayer = await prisma.memberPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerFindFirstArgs} args - Arguments to find a MemberPlayer
     * @example
     * // Get one MemberPlayer
     * const memberPlayer = await prisma.memberPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberPlayerFindFirstArgs>(args?: SelectSubset<T, MemberPlayerFindFirstArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerFindFirstOrThrowArgs} args - Arguments to find a MemberPlayer
     * @example
     * // Get one MemberPlayer
     * const memberPlayer = await prisma.memberPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberPlayers
     * const memberPlayers = await prisma.memberPlayer.findMany()
     * 
     * // Get first 10 MemberPlayers
     * const memberPlayers = await prisma.memberPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberPlayerWithIdOnly = await prisma.memberPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberPlayerFindManyArgs>(args?: SelectSubset<T, MemberPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberPlayer.
     * @param {MemberPlayerCreateArgs} args - Arguments to create a MemberPlayer.
     * @example
     * // Create one MemberPlayer
     * const MemberPlayer = await prisma.memberPlayer.create({
     *   data: {
     *     // ... data to create a MemberPlayer
     *   }
     * })
     * 
     */
    create<T extends MemberPlayerCreateArgs>(args: SelectSubset<T, MemberPlayerCreateArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberPlayers.
     * @param {MemberPlayerCreateManyArgs} args - Arguments to create many MemberPlayers.
     * @example
     * // Create many MemberPlayers
     * const memberPlayer = await prisma.memberPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberPlayerCreateManyArgs>(args?: SelectSubset<T, MemberPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberPlayers and returns the data saved in the database.
     * @param {MemberPlayerCreateManyAndReturnArgs} args - Arguments to create many MemberPlayers.
     * @example
     * // Create many MemberPlayers
     * const memberPlayer = await prisma.memberPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberPlayers and only return the `id`
     * const memberPlayerWithIdOnly = await prisma.memberPlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberPlayer.
     * @param {MemberPlayerDeleteArgs} args - Arguments to delete one MemberPlayer.
     * @example
     * // Delete one MemberPlayer
     * const MemberPlayer = await prisma.memberPlayer.delete({
     *   where: {
     *     // ... filter to delete one MemberPlayer
     *   }
     * })
     * 
     */
    delete<T extends MemberPlayerDeleteArgs>(args: SelectSubset<T, MemberPlayerDeleteArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberPlayer.
     * @param {MemberPlayerUpdateArgs} args - Arguments to update one MemberPlayer.
     * @example
     * // Update one MemberPlayer
     * const memberPlayer = await prisma.memberPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberPlayerUpdateArgs>(args: SelectSubset<T, MemberPlayerUpdateArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberPlayers.
     * @param {MemberPlayerDeleteManyArgs} args - Arguments to filter MemberPlayers to delete.
     * @example
     * // Delete a few MemberPlayers
     * const { count } = await prisma.memberPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberPlayerDeleteManyArgs>(args?: SelectSubset<T, MemberPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberPlayers
     * const memberPlayer = await prisma.memberPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberPlayerUpdateManyArgs>(args: SelectSubset<T, MemberPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberPlayers and returns the data updated in the database.
     * @param {MemberPlayerUpdateManyAndReturnArgs} args - Arguments to update many MemberPlayers.
     * @example
     * // Update many MemberPlayers
     * const memberPlayer = await prisma.memberPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberPlayers and only return the `id`
     * const memberPlayerWithIdOnly = await prisma.memberPlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberPlayer.
     * @param {MemberPlayerUpsertArgs} args - Arguments to update or create a MemberPlayer.
     * @example
     * // Update or create a MemberPlayer
     * const memberPlayer = await prisma.memberPlayer.upsert({
     *   create: {
     *     // ... data to create a MemberPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberPlayer we want to update
     *   }
     * })
     */
    upsert<T extends MemberPlayerUpsertArgs>(args: SelectSubset<T, MemberPlayerUpsertArgs<ExtArgs>>): Prisma__MemberPlayerClient<$Result.GetResult<Prisma.$MemberPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerCountArgs} args - Arguments to filter MemberPlayers to count.
     * @example
     * // Count the number of MemberPlayers
     * const count = await prisma.memberPlayer.count({
     *   where: {
     *     // ... the filter for the MemberPlayers we want to count
     *   }
     * })
    **/
    count<T extends MemberPlayerCountArgs>(
      args?: Subset<T, MemberPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberPlayerAggregateArgs>(args: Subset<T, MemberPlayerAggregateArgs>): Prisma.PrismaPromise<GetMemberPlayerAggregateType<T>>

    /**
     * Group by MemberPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberPlayerGroupByArgs['orderBy'] }
        : { orderBy?: MemberPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberPlayer model
   */
  readonly fields: MemberPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberPlayer model
   */
  interface MemberPlayerFieldRefs {
    readonly id: FieldRef<"MemberPlayer", 'Decimal'>
    readonly personId: FieldRef<"MemberPlayer", 'Decimal'>
    readonly height: FieldRef<"MemberPlayer", 'Decimal'>
    readonly weight: FieldRef<"MemberPlayer", 'Decimal'>
    readonly preferredFoot: FieldRef<"MemberPlayer", 'String'>
    readonly contractStart: FieldRef<"MemberPlayer", 'DateTime'>
    readonly contractEnd: FieldRef<"MemberPlayer", 'DateTime'>
    readonly emergencyContactName: FieldRef<"MemberPlayer", 'String'>
    readonly emergencyContactPhone: FieldRef<"MemberPlayer", 'String'>
    readonly status: FieldRef<"MemberPlayer", 'String'>
    readonly bio: FieldRef<"MemberPlayer", 'String'>
    readonly ord: FieldRef<"MemberPlayer", 'Int'>
    readonly createdAt: FieldRef<"MemberPlayer", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberPlayer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberPlayer findUnique
   */
  export type MemberPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * Filter, which MemberPlayer to fetch.
     */
    where: MemberPlayerWhereUniqueInput
  }

  /**
   * MemberPlayer findUniqueOrThrow
   */
  export type MemberPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * Filter, which MemberPlayer to fetch.
     */
    where: MemberPlayerWhereUniqueInput
  }

  /**
   * MemberPlayer findFirst
   */
  export type MemberPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * Filter, which MemberPlayer to fetch.
     */
    where?: MemberPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPlayers to fetch.
     */
    orderBy?: MemberPlayerOrderByWithRelationInput | MemberPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberPlayers.
     */
    cursor?: MemberPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberPlayers.
     */
    distinct?: MemberPlayerScalarFieldEnum | MemberPlayerScalarFieldEnum[]
  }

  /**
   * MemberPlayer findFirstOrThrow
   */
  export type MemberPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * Filter, which MemberPlayer to fetch.
     */
    where?: MemberPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPlayers to fetch.
     */
    orderBy?: MemberPlayerOrderByWithRelationInput | MemberPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberPlayers.
     */
    cursor?: MemberPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberPlayers.
     */
    distinct?: MemberPlayerScalarFieldEnum | MemberPlayerScalarFieldEnum[]
  }

  /**
   * MemberPlayer findMany
   */
  export type MemberPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * Filter, which MemberPlayers to fetch.
     */
    where?: MemberPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberPlayers to fetch.
     */
    orderBy?: MemberPlayerOrderByWithRelationInput | MemberPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberPlayers.
     */
    cursor?: MemberPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberPlayers.
     */
    skip?: number
    distinct?: MemberPlayerScalarFieldEnum | MemberPlayerScalarFieldEnum[]
  }

  /**
   * MemberPlayer create
   */
  export type MemberPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberPlayer.
     */
    data: XOR<MemberPlayerCreateInput, MemberPlayerUncheckedCreateInput>
  }

  /**
   * MemberPlayer createMany
   */
  export type MemberPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberPlayers.
     */
    data: MemberPlayerCreateManyInput | MemberPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberPlayer createManyAndReturn
   */
  export type MemberPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many MemberPlayers.
     */
    data: MemberPlayerCreateManyInput | MemberPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberPlayer update
   */
  export type MemberPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberPlayer.
     */
    data: XOR<MemberPlayerUpdateInput, MemberPlayerUncheckedUpdateInput>
    /**
     * Choose, which MemberPlayer to update.
     */
    where: MemberPlayerWhereUniqueInput
  }

  /**
   * MemberPlayer updateMany
   */
  export type MemberPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberPlayers.
     */
    data: XOR<MemberPlayerUpdateManyMutationInput, MemberPlayerUncheckedUpdateManyInput>
    /**
     * Filter which MemberPlayers to update
     */
    where?: MemberPlayerWhereInput
    /**
     * Limit how many MemberPlayers to update.
     */
    limit?: number
  }

  /**
   * MemberPlayer updateManyAndReturn
   */
  export type MemberPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * The data used to update MemberPlayers.
     */
    data: XOR<MemberPlayerUpdateManyMutationInput, MemberPlayerUncheckedUpdateManyInput>
    /**
     * Filter which MemberPlayers to update
     */
    where?: MemberPlayerWhereInput
    /**
     * Limit how many MemberPlayers to update.
     */
    limit?: number
  }

  /**
   * MemberPlayer upsert
   */
  export type MemberPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberPlayer to update in case it exists.
     */
    where: MemberPlayerWhereUniqueInput
    /**
     * In case the MemberPlayer found by the `where` argument doesn't exist, create a new MemberPlayer with this data.
     */
    create: XOR<MemberPlayerCreateInput, MemberPlayerUncheckedCreateInput>
    /**
     * In case the MemberPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberPlayerUpdateInput, MemberPlayerUncheckedUpdateInput>
  }

  /**
   * MemberPlayer delete
   */
  export type MemberPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
    /**
     * Filter which MemberPlayer to delete.
     */
    where: MemberPlayerWhereUniqueInput
  }

  /**
   * MemberPlayer deleteMany
   */
  export type MemberPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberPlayers to delete
     */
    where?: MemberPlayerWhereInput
    /**
     * Limit how many MemberPlayers to delete.
     */
    limit?: number
  }

  /**
   * MemberPlayer without action
   */
  export type MemberPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberPlayer
     */
    select?: MemberPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberPlayer
     */
    omit?: MemberPlayerOmit<ExtArgs> | null
  }


  /**
   * Model MemberReferee
   */

  export type AggregateMemberReferee = {
    _count: MemberRefereeCountAggregateOutputType | null
    _avg: MemberRefereeAvgAggregateOutputType | null
    _sum: MemberRefereeSumAggregateOutputType | null
    _min: MemberRefereeMinAggregateOutputType | null
    _max: MemberRefereeMaxAggregateOutputType | null
  }

  export type MemberRefereeAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    matchFee: Decimal | null
    ord: number | null
  }

  export type MemberRefereeSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    matchFee: Decimal | null
    ord: number | null
  }

  export type MemberRefereeMinAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    licenseNumber: string | null
    licenseLevel: string | null
    certification: string | null
    refereeType: string | null
    specialization: string | null
    languages: string | null
    matchFee: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberRefereeMaxAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    licenseNumber: string | null
    licenseLevel: string | null
    certification: string | null
    refereeType: string | null
    specialization: string | null
    languages: string | null
    matchFee: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberRefereeCountAggregateOutputType = {
    id: number
    personId: number
    licenseNumber: number
    licenseLevel: number
    certification: number
    refereeType: number
    specialization: number
    languages: number
    matchFee: number
    emergencyContactName: number
    emergencyContactPhone: number
    status: number
    bio: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberRefereeAvgAggregateInputType = {
    id?: true
    personId?: true
    matchFee?: true
    ord?: true
  }

  export type MemberRefereeSumAggregateInputType = {
    id?: true
    personId?: true
    matchFee?: true
    ord?: true
  }

  export type MemberRefereeMinAggregateInputType = {
    id?: true
    personId?: true
    licenseNumber?: true
    licenseLevel?: true
    certification?: true
    refereeType?: true
    specialization?: true
    languages?: true
    matchFee?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberRefereeMaxAggregateInputType = {
    id?: true
    personId?: true
    licenseNumber?: true
    licenseLevel?: true
    certification?: true
    refereeType?: true
    specialization?: true
    languages?: true
    matchFee?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberRefereeCountAggregateInputType = {
    id?: true
    personId?: true
    licenseNumber?: true
    licenseLevel?: true
    certification?: true
    refereeType?: true
    specialization?: true
    languages?: true
    matchFee?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberRefereeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberReferee to aggregate.
     */
    where?: MemberRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberReferees to fetch.
     */
    orderBy?: MemberRefereeOrderByWithRelationInput | MemberRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberReferees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberReferees
    **/
    _count?: true | MemberRefereeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberRefereeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberRefereeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberRefereeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberRefereeMaxAggregateInputType
  }

  export type GetMemberRefereeAggregateType<T extends MemberRefereeAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberReferee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberReferee[P]>
      : GetScalarType<T[P], AggregateMemberReferee[P]>
  }




  export type MemberRefereeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberRefereeWhereInput
    orderBy?: MemberRefereeOrderByWithAggregationInput | MemberRefereeOrderByWithAggregationInput[]
    by: MemberRefereeScalarFieldEnum[] | MemberRefereeScalarFieldEnum
    having?: MemberRefereeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberRefereeCountAggregateInputType | true
    _avg?: MemberRefereeAvgAggregateInputType
    _sum?: MemberRefereeSumAggregateInputType
    _min?: MemberRefereeMinAggregateInputType
    _max?: MemberRefereeMaxAggregateInputType
  }

  export type MemberRefereeGroupByOutputType = {
    id: Decimal
    personId: Decimal
    licenseNumber: string
    licenseLevel: string | null
    certification: string | null
    refereeType: string
    specialization: string | null
    languages: string | null
    matchFee: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string
    bio: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberRefereeCountAggregateOutputType | null
    _avg: MemberRefereeAvgAggregateOutputType | null
    _sum: MemberRefereeSumAggregateOutputType | null
    _min: MemberRefereeMinAggregateOutputType | null
    _max: MemberRefereeMaxAggregateOutputType | null
  }

  type GetMemberRefereeGroupByPayload<T extends MemberRefereeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberRefereeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberRefereeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberRefereeGroupByOutputType[P]>
            : GetScalarType<T[P], MemberRefereeGroupByOutputType[P]>
        }
      >
    >


  export type MemberRefereeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    licenseLevel?: boolean
    certification?: boolean
    refereeType?: boolean
    specialization?: boolean
    languages?: boolean
    matchFee?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberReferee"]>

  export type MemberRefereeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    licenseLevel?: boolean
    certification?: boolean
    refereeType?: boolean
    specialization?: boolean
    languages?: boolean
    matchFee?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberReferee"]>

  export type MemberRefereeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    licenseLevel?: boolean
    certification?: boolean
    refereeType?: boolean
    specialization?: boolean
    languages?: boolean
    matchFee?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberReferee"]>

  export type MemberRefereeSelectScalar = {
    id?: boolean
    personId?: boolean
    licenseNumber?: boolean
    licenseLevel?: boolean
    certification?: boolean
    refereeType?: boolean
    specialization?: boolean
    languages?: boolean
    matchFee?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberRefereeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "licenseNumber" | "licenseLevel" | "certification" | "refereeType" | "specialization" | "languages" | "matchFee" | "emergencyContactName" | "emergencyContactPhone" | "status" | "bio" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberReferee"]>

  export type $MemberRefereePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberReferee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      personId: Prisma.Decimal
      licenseNumber: string
      licenseLevel: string | null
      certification: string | null
      refereeType: string
      specialization: string | null
      languages: string | null
      matchFee: Prisma.Decimal | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      status: string
      bio: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberReferee"]>
    composites: {}
  }

  type MemberRefereeGetPayload<S extends boolean | null | undefined | MemberRefereeDefaultArgs> = $Result.GetResult<Prisma.$MemberRefereePayload, S>

  type MemberRefereeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberRefereeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberRefereeCountAggregateInputType | true
    }

  export interface MemberRefereeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberReferee'], meta: { name: 'MemberReferee' } }
    /**
     * Find zero or one MemberReferee that matches the filter.
     * @param {MemberRefereeFindUniqueArgs} args - Arguments to find a MemberReferee
     * @example
     * // Get one MemberReferee
     * const memberReferee = await prisma.memberReferee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberRefereeFindUniqueArgs>(args: SelectSubset<T, MemberRefereeFindUniqueArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberReferee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberRefereeFindUniqueOrThrowArgs} args - Arguments to find a MemberReferee
     * @example
     * // Get one MemberReferee
     * const memberReferee = await prisma.memberReferee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberRefereeFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberRefereeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberReferee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeFindFirstArgs} args - Arguments to find a MemberReferee
     * @example
     * // Get one MemberReferee
     * const memberReferee = await prisma.memberReferee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberRefereeFindFirstArgs>(args?: SelectSubset<T, MemberRefereeFindFirstArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberReferee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeFindFirstOrThrowArgs} args - Arguments to find a MemberReferee
     * @example
     * // Get one MemberReferee
     * const memberReferee = await prisma.memberReferee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberRefereeFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberRefereeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberReferees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberReferees
     * const memberReferees = await prisma.memberReferee.findMany()
     * 
     * // Get first 10 MemberReferees
     * const memberReferees = await prisma.memberReferee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberRefereeWithIdOnly = await prisma.memberReferee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberRefereeFindManyArgs>(args?: SelectSubset<T, MemberRefereeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberReferee.
     * @param {MemberRefereeCreateArgs} args - Arguments to create a MemberReferee.
     * @example
     * // Create one MemberReferee
     * const MemberReferee = await prisma.memberReferee.create({
     *   data: {
     *     // ... data to create a MemberReferee
     *   }
     * })
     * 
     */
    create<T extends MemberRefereeCreateArgs>(args: SelectSubset<T, MemberRefereeCreateArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberReferees.
     * @param {MemberRefereeCreateManyArgs} args - Arguments to create many MemberReferees.
     * @example
     * // Create many MemberReferees
     * const memberReferee = await prisma.memberReferee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberRefereeCreateManyArgs>(args?: SelectSubset<T, MemberRefereeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberReferees and returns the data saved in the database.
     * @param {MemberRefereeCreateManyAndReturnArgs} args - Arguments to create many MemberReferees.
     * @example
     * // Create many MemberReferees
     * const memberReferee = await prisma.memberReferee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberReferees and only return the `id`
     * const memberRefereeWithIdOnly = await prisma.memberReferee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberRefereeCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberRefereeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberReferee.
     * @param {MemberRefereeDeleteArgs} args - Arguments to delete one MemberReferee.
     * @example
     * // Delete one MemberReferee
     * const MemberReferee = await prisma.memberReferee.delete({
     *   where: {
     *     // ... filter to delete one MemberReferee
     *   }
     * })
     * 
     */
    delete<T extends MemberRefereeDeleteArgs>(args: SelectSubset<T, MemberRefereeDeleteArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberReferee.
     * @param {MemberRefereeUpdateArgs} args - Arguments to update one MemberReferee.
     * @example
     * // Update one MemberReferee
     * const memberReferee = await prisma.memberReferee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberRefereeUpdateArgs>(args: SelectSubset<T, MemberRefereeUpdateArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberReferees.
     * @param {MemberRefereeDeleteManyArgs} args - Arguments to filter MemberReferees to delete.
     * @example
     * // Delete a few MemberReferees
     * const { count } = await prisma.memberReferee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberRefereeDeleteManyArgs>(args?: SelectSubset<T, MemberRefereeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberReferees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberReferees
     * const memberReferee = await prisma.memberReferee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberRefereeUpdateManyArgs>(args: SelectSubset<T, MemberRefereeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberReferees and returns the data updated in the database.
     * @param {MemberRefereeUpdateManyAndReturnArgs} args - Arguments to update many MemberReferees.
     * @example
     * // Update many MemberReferees
     * const memberReferee = await prisma.memberReferee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberReferees and only return the `id`
     * const memberRefereeWithIdOnly = await prisma.memberReferee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberRefereeUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberRefereeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberReferee.
     * @param {MemberRefereeUpsertArgs} args - Arguments to update or create a MemberReferee.
     * @example
     * // Update or create a MemberReferee
     * const memberReferee = await prisma.memberReferee.upsert({
     *   create: {
     *     // ... data to create a MemberReferee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberReferee we want to update
     *   }
     * })
     */
    upsert<T extends MemberRefereeUpsertArgs>(args: SelectSubset<T, MemberRefereeUpsertArgs<ExtArgs>>): Prisma__MemberRefereeClient<$Result.GetResult<Prisma.$MemberRefereePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberReferees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeCountArgs} args - Arguments to filter MemberReferees to count.
     * @example
     * // Count the number of MemberReferees
     * const count = await prisma.memberReferee.count({
     *   where: {
     *     // ... the filter for the MemberReferees we want to count
     *   }
     * })
    **/
    count<T extends MemberRefereeCountArgs>(
      args?: Subset<T, MemberRefereeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberRefereeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberReferee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberRefereeAggregateArgs>(args: Subset<T, MemberRefereeAggregateArgs>): Prisma.PrismaPromise<GetMemberRefereeAggregateType<T>>

    /**
     * Group by MemberReferee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRefereeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberRefereeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberRefereeGroupByArgs['orderBy'] }
        : { orderBy?: MemberRefereeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberRefereeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberRefereeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberReferee model
   */
  readonly fields: MemberRefereeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberReferee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberRefereeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberReferee model
   */
  interface MemberRefereeFieldRefs {
    readonly id: FieldRef<"MemberReferee", 'Decimal'>
    readonly personId: FieldRef<"MemberReferee", 'Decimal'>
    readonly licenseNumber: FieldRef<"MemberReferee", 'String'>
    readonly licenseLevel: FieldRef<"MemberReferee", 'String'>
    readonly certification: FieldRef<"MemberReferee", 'String'>
    readonly refereeType: FieldRef<"MemberReferee", 'String'>
    readonly specialization: FieldRef<"MemberReferee", 'String'>
    readonly languages: FieldRef<"MemberReferee", 'String'>
    readonly matchFee: FieldRef<"MemberReferee", 'Decimal'>
    readonly emergencyContactName: FieldRef<"MemberReferee", 'String'>
    readonly emergencyContactPhone: FieldRef<"MemberReferee", 'String'>
    readonly status: FieldRef<"MemberReferee", 'String'>
    readonly bio: FieldRef<"MemberReferee", 'String'>
    readonly ord: FieldRef<"MemberReferee", 'Int'>
    readonly createdAt: FieldRef<"MemberReferee", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberReferee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberReferee findUnique
   */
  export type MemberRefereeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * Filter, which MemberReferee to fetch.
     */
    where: MemberRefereeWhereUniqueInput
  }

  /**
   * MemberReferee findUniqueOrThrow
   */
  export type MemberRefereeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * Filter, which MemberReferee to fetch.
     */
    where: MemberRefereeWhereUniqueInput
  }

  /**
   * MemberReferee findFirst
   */
  export type MemberRefereeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * Filter, which MemberReferee to fetch.
     */
    where?: MemberRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberReferees to fetch.
     */
    orderBy?: MemberRefereeOrderByWithRelationInput | MemberRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberReferees.
     */
    cursor?: MemberRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberReferees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberReferees.
     */
    distinct?: MemberRefereeScalarFieldEnum | MemberRefereeScalarFieldEnum[]
  }

  /**
   * MemberReferee findFirstOrThrow
   */
  export type MemberRefereeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * Filter, which MemberReferee to fetch.
     */
    where?: MemberRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberReferees to fetch.
     */
    orderBy?: MemberRefereeOrderByWithRelationInput | MemberRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberReferees.
     */
    cursor?: MemberRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberReferees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberReferees.
     */
    distinct?: MemberRefereeScalarFieldEnum | MemberRefereeScalarFieldEnum[]
  }

  /**
   * MemberReferee findMany
   */
  export type MemberRefereeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * Filter, which MemberReferees to fetch.
     */
    where?: MemberRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberReferees to fetch.
     */
    orderBy?: MemberRefereeOrderByWithRelationInput | MemberRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberReferees.
     */
    cursor?: MemberRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberReferees.
     */
    skip?: number
    distinct?: MemberRefereeScalarFieldEnum | MemberRefereeScalarFieldEnum[]
  }

  /**
   * MemberReferee create
   */
  export type MemberRefereeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberReferee.
     */
    data: XOR<MemberRefereeCreateInput, MemberRefereeUncheckedCreateInput>
  }

  /**
   * MemberReferee createMany
   */
  export type MemberRefereeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberReferees.
     */
    data: MemberRefereeCreateManyInput | MemberRefereeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberReferee createManyAndReturn
   */
  export type MemberRefereeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * The data used to create many MemberReferees.
     */
    data: MemberRefereeCreateManyInput | MemberRefereeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberReferee update
   */
  export type MemberRefereeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberReferee.
     */
    data: XOR<MemberRefereeUpdateInput, MemberRefereeUncheckedUpdateInput>
    /**
     * Choose, which MemberReferee to update.
     */
    where: MemberRefereeWhereUniqueInput
  }

  /**
   * MemberReferee updateMany
   */
  export type MemberRefereeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberReferees.
     */
    data: XOR<MemberRefereeUpdateManyMutationInput, MemberRefereeUncheckedUpdateManyInput>
    /**
     * Filter which MemberReferees to update
     */
    where?: MemberRefereeWhereInput
    /**
     * Limit how many MemberReferees to update.
     */
    limit?: number
  }

  /**
   * MemberReferee updateManyAndReturn
   */
  export type MemberRefereeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * The data used to update MemberReferees.
     */
    data: XOR<MemberRefereeUpdateManyMutationInput, MemberRefereeUncheckedUpdateManyInput>
    /**
     * Filter which MemberReferees to update
     */
    where?: MemberRefereeWhereInput
    /**
     * Limit how many MemberReferees to update.
     */
    limit?: number
  }

  /**
   * MemberReferee upsert
   */
  export type MemberRefereeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberReferee to update in case it exists.
     */
    where: MemberRefereeWhereUniqueInput
    /**
     * In case the MemberReferee found by the `where` argument doesn't exist, create a new MemberReferee with this data.
     */
    create: XOR<MemberRefereeCreateInput, MemberRefereeUncheckedCreateInput>
    /**
     * In case the MemberReferee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberRefereeUpdateInput, MemberRefereeUncheckedUpdateInput>
  }

  /**
   * MemberReferee delete
   */
  export type MemberRefereeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
    /**
     * Filter which MemberReferee to delete.
     */
    where: MemberRefereeWhereUniqueInput
  }

  /**
   * MemberReferee deleteMany
   */
  export type MemberRefereeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberReferees to delete
     */
    where?: MemberRefereeWhereInput
    /**
     * Limit how many MemberReferees to delete.
     */
    limit?: number
  }

  /**
   * MemberReferee without action
   */
  export type MemberRefereeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberReferee
     */
    select?: MemberRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberReferee
     */
    omit?: MemberRefereeOmit<ExtArgs> | null
  }


  /**
   * Model MemberSponsor
   */

  export type AggregateMemberSponsor = {
    _count: MemberSponsorCountAggregateOutputType | null
    _avg: MemberSponsorAvgAggregateOutputType | null
    _sum: MemberSponsorSumAggregateOutputType | null
    _min: MemberSponsorMinAggregateOutputType | null
    _max: MemberSponsorMaxAggregateOutputType | null
  }

  export type MemberSponsorAvgAggregateOutputType = {
    id: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type MemberSponsorSumAggregateOutputType = {
    id: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type MemberSponsorMinAggregateOutputType = {
    id: Decimal | null
    companyName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    website: string | null
    sponsorLevel: string | null
    sponsorshipAmount: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    benefits: string | null
    logoPath: string | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberSponsorMaxAggregateOutputType = {
    id: Decimal | null
    companyName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    website: string | null
    sponsorLevel: string | null
    sponsorshipAmount: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    benefits: string | null
    logoPath: string | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberSponsorCountAggregateOutputType = {
    id: number
    companyName: number
    contactPerson: number
    email: number
    phone: number
    website: number
    sponsorLevel: number
    sponsorshipAmount: number
    contractStart: number
    contractEnd: number
    benefits: number
    logoPath: number
    status: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberSponsorAvgAggregateInputType = {
    id?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type MemberSponsorSumAggregateInputType = {
    id?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type MemberSponsorMinAggregateInputType = {
    id?: true
    companyName?: true
    contactPerson?: true
    email?: true
    phone?: true
    website?: true
    sponsorLevel?: true
    sponsorshipAmount?: true
    contractStart?: true
    contractEnd?: true
    benefits?: true
    logoPath?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberSponsorMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactPerson?: true
    email?: true
    phone?: true
    website?: true
    sponsorLevel?: true
    sponsorshipAmount?: true
    contractStart?: true
    contractEnd?: true
    benefits?: true
    logoPath?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberSponsorCountAggregateInputType = {
    id?: true
    companyName?: true
    contactPerson?: true
    email?: true
    phone?: true
    website?: true
    sponsorLevel?: true
    sponsorshipAmount?: true
    contractStart?: true
    contractEnd?: true
    benefits?: true
    logoPath?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberSponsorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberSponsor to aggregate.
     */
    where?: MemberSponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSponsors to fetch.
     */
    orderBy?: MemberSponsorOrderByWithRelationInput | MemberSponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberSponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberSponsors
    **/
    _count?: true | MemberSponsorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberSponsorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSponsorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberSponsorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberSponsorMaxAggregateInputType
  }

  export type GetMemberSponsorAggregateType<T extends MemberSponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberSponsor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberSponsor[P]>
      : GetScalarType<T[P], AggregateMemberSponsor[P]>
  }




  export type MemberSponsorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberSponsorWhereInput
    orderBy?: MemberSponsorOrderByWithAggregationInput | MemberSponsorOrderByWithAggregationInput[]
    by: MemberSponsorScalarFieldEnum[] | MemberSponsorScalarFieldEnum
    having?: MemberSponsorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberSponsorCountAggregateInputType | true
    _avg?: MemberSponsorAvgAggregateInputType
    _sum?: MemberSponsorSumAggregateInputType
    _min?: MemberSponsorMinAggregateInputType
    _max?: MemberSponsorMaxAggregateInputType
  }

  export type MemberSponsorGroupByOutputType = {
    id: Decimal
    companyName: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    website: string | null
    sponsorLevel: string | null
    sponsorshipAmount: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    benefits: string | null
    logoPath: string | null
    status: string
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberSponsorCountAggregateOutputType | null
    _avg: MemberSponsorAvgAggregateOutputType | null
    _sum: MemberSponsorSumAggregateOutputType | null
    _min: MemberSponsorMinAggregateOutputType | null
    _max: MemberSponsorMaxAggregateOutputType | null
  }

  type GetMemberSponsorGroupByPayload<T extends MemberSponsorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberSponsorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberSponsorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberSponsorGroupByOutputType[P]>
            : GetScalarType<T[P], MemberSponsorGroupByOutputType[P]>
        }
      >
    >


  export type MemberSponsorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    sponsorLevel?: boolean
    sponsorshipAmount?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    benefits?: boolean
    logoPath?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberSponsor"]>

  export type MemberSponsorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    sponsorLevel?: boolean
    sponsorshipAmount?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    benefits?: boolean
    logoPath?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberSponsor"]>

  export type MemberSponsorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    sponsorLevel?: boolean
    sponsorshipAmount?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    benefits?: boolean
    logoPath?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberSponsor"]>

  export type MemberSponsorSelectScalar = {
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    sponsorLevel?: boolean
    sponsorshipAmount?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    benefits?: boolean
    logoPath?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberSponsorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "contactPerson" | "email" | "phone" | "website" | "sponsorLevel" | "sponsorshipAmount" | "contractStart" | "contractEnd" | "benefits" | "logoPath" | "status" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberSponsor"]>

  export type $MemberSponsorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberSponsor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      companyName: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      website: string | null
      sponsorLevel: string | null
      sponsorshipAmount: Prisma.Decimal | null
      contractStart: Date | null
      contractEnd: Date | null
      benefits: string | null
      logoPath: string | null
      status: string
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberSponsor"]>
    composites: {}
  }

  type MemberSponsorGetPayload<S extends boolean | null | undefined | MemberSponsorDefaultArgs> = $Result.GetResult<Prisma.$MemberSponsorPayload, S>

  type MemberSponsorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberSponsorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberSponsorCountAggregateInputType | true
    }

  export interface MemberSponsorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberSponsor'], meta: { name: 'MemberSponsor' } }
    /**
     * Find zero or one MemberSponsor that matches the filter.
     * @param {MemberSponsorFindUniqueArgs} args - Arguments to find a MemberSponsor
     * @example
     * // Get one MemberSponsor
     * const memberSponsor = await prisma.memberSponsor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberSponsorFindUniqueArgs>(args: SelectSubset<T, MemberSponsorFindUniqueArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberSponsor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberSponsorFindUniqueOrThrowArgs} args - Arguments to find a MemberSponsor
     * @example
     * // Get one MemberSponsor
     * const memberSponsor = await prisma.memberSponsor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberSponsorFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberSponsorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberSponsor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorFindFirstArgs} args - Arguments to find a MemberSponsor
     * @example
     * // Get one MemberSponsor
     * const memberSponsor = await prisma.memberSponsor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberSponsorFindFirstArgs>(args?: SelectSubset<T, MemberSponsorFindFirstArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberSponsor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorFindFirstOrThrowArgs} args - Arguments to find a MemberSponsor
     * @example
     * // Get one MemberSponsor
     * const memberSponsor = await prisma.memberSponsor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberSponsorFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberSponsorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberSponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberSponsors
     * const memberSponsors = await prisma.memberSponsor.findMany()
     * 
     * // Get first 10 MemberSponsors
     * const memberSponsors = await prisma.memberSponsor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberSponsorWithIdOnly = await prisma.memberSponsor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberSponsorFindManyArgs>(args?: SelectSubset<T, MemberSponsorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberSponsor.
     * @param {MemberSponsorCreateArgs} args - Arguments to create a MemberSponsor.
     * @example
     * // Create one MemberSponsor
     * const MemberSponsor = await prisma.memberSponsor.create({
     *   data: {
     *     // ... data to create a MemberSponsor
     *   }
     * })
     * 
     */
    create<T extends MemberSponsorCreateArgs>(args: SelectSubset<T, MemberSponsorCreateArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberSponsors.
     * @param {MemberSponsorCreateManyArgs} args - Arguments to create many MemberSponsors.
     * @example
     * // Create many MemberSponsors
     * const memberSponsor = await prisma.memberSponsor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberSponsorCreateManyArgs>(args?: SelectSubset<T, MemberSponsorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberSponsors and returns the data saved in the database.
     * @param {MemberSponsorCreateManyAndReturnArgs} args - Arguments to create many MemberSponsors.
     * @example
     * // Create many MemberSponsors
     * const memberSponsor = await prisma.memberSponsor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberSponsors and only return the `id`
     * const memberSponsorWithIdOnly = await prisma.memberSponsor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberSponsorCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberSponsorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberSponsor.
     * @param {MemberSponsorDeleteArgs} args - Arguments to delete one MemberSponsor.
     * @example
     * // Delete one MemberSponsor
     * const MemberSponsor = await prisma.memberSponsor.delete({
     *   where: {
     *     // ... filter to delete one MemberSponsor
     *   }
     * })
     * 
     */
    delete<T extends MemberSponsorDeleteArgs>(args: SelectSubset<T, MemberSponsorDeleteArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberSponsor.
     * @param {MemberSponsorUpdateArgs} args - Arguments to update one MemberSponsor.
     * @example
     * // Update one MemberSponsor
     * const memberSponsor = await prisma.memberSponsor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberSponsorUpdateArgs>(args: SelectSubset<T, MemberSponsorUpdateArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberSponsors.
     * @param {MemberSponsorDeleteManyArgs} args - Arguments to filter MemberSponsors to delete.
     * @example
     * // Delete a few MemberSponsors
     * const { count } = await prisma.memberSponsor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberSponsorDeleteManyArgs>(args?: SelectSubset<T, MemberSponsorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberSponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberSponsors
     * const memberSponsor = await prisma.memberSponsor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberSponsorUpdateManyArgs>(args: SelectSubset<T, MemberSponsorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberSponsors and returns the data updated in the database.
     * @param {MemberSponsorUpdateManyAndReturnArgs} args - Arguments to update many MemberSponsors.
     * @example
     * // Update many MemberSponsors
     * const memberSponsor = await prisma.memberSponsor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberSponsors and only return the `id`
     * const memberSponsorWithIdOnly = await prisma.memberSponsor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberSponsorUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberSponsorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberSponsor.
     * @param {MemberSponsorUpsertArgs} args - Arguments to update or create a MemberSponsor.
     * @example
     * // Update or create a MemberSponsor
     * const memberSponsor = await prisma.memberSponsor.upsert({
     *   create: {
     *     // ... data to create a MemberSponsor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberSponsor we want to update
     *   }
     * })
     */
    upsert<T extends MemberSponsorUpsertArgs>(args: SelectSubset<T, MemberSponsorUpsertArgs<ExtArgs>>): Prisma__MemberSponsorClient<$Result.GetResult<Prisma.$MemberSponsorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberSponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorCountArgs} args - Arguments to filter MemberSponsors to count.
     * @example
     * // Count the number of MemberSponsors
     * const count = await prisma.memberSponsor.count({
     *   where: {
     *     // ... the filter for the MemberSponsors we want to count
     *   }
     * })
    **/
    count<T extends MemberSponsorCountArgs>(
      args?: Subset<T, MemberSponsorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberSponsorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberSponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberSponsorAggregateArgs>(args: Subset<T, MemberSponsorAggregateArgs>): Prisma.PrismaPromise<GetMemberSponsorAggregateType<T>>

    /**
     * Group by MemberSponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSponsorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberSponsorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberSponsorGroupByArgs['orderBy'] }
        : { orderBy?: MemberSponsorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberSponsorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberSponsorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberSponsor model
   */
  readonly fields: MemberSponsorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberSponsor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberSponsorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberSponsor model
   */
  interface MemberSponsorFieldRefs {
    readonly id: FieldRef<"MemberSponsor", 'Decimal'>
    readonly companyName: FieldRef<"MemberSponsor", 'String'>
    readonly contactPerson: FieldRef<"MemberSponsor", 'String'>
    readonly email: FieldRef<"MemberSponsor", 'String'>
    readonly phone: FieldRef<"MemberSponsor", 'String'>
    readonly website: FieldRef<"MemberSponsor", 'String'>
    readonly sponsorLevel: FieldRef<"MemberSponsor", 'String'>
    readonly sponsorshipAmount: FieldRef<"MemberSponsor", 'Decimal'>
    readonly contractStart: FieldRef<"MemberSponsor", 'DateTime'>
    readonly contractEnd: FieldRef<"MemberSponsor", 'DateTime'>
    readonly benefits: FieldRef<"MemberSponsor", 'String'>
    readonly logoPath: FieldRef<"MemberSponsor", 'String'>
    readonly status: FieldRef<"MemberSponsor", 'String'>
    readonly notes: FieldRef<"MemberSponsor", 'String'>
    readonly ord: FieldRef<"MemberSponsor", 'Int'>
    readonly createdAt: FieldRef<"MemberSponsor", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberSponsor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberSponsor findUnique
   */
  export type MemberSponsorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * Filter, which MemberSponsor to fetch.
     */
    where: MemberSponsorWhereUniqueInput
  }

  /**
   * MemberSponsor findUniqueOrThrow
   */
  export type MemberSponsorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * Filter, which MemberSponsor to fetch.
     */
    where: MemberSponsorWhereUniqueInput
  }

  /**
   * MemberSponsor findFirst
   */
  export type MemberSponsorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * Filter, which MemberSponsor to fetch.
     */
    where?: MemberSponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSponsors to fetch.
     */
    orderBy?: MemberSponsorOrderByWithRelationInput | MemberSponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberSponsors.
     */
    cursor?: MemberSponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberSponsors.
     */
    distinct?: MemberSponsorScalarFieldEnum | MemberSponsorScalarFieldEnum[]
  }

  /**
   * MemberSponsor findFirstOrThrow
   */
  export type MemberSponsorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * Filter, which MemberSponsor to fetch.
     */
    where?: MemberSponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSponsors to fetch.
     */
    orderBy?: MemberSponsorOrderByWithRelationInput | MemberSponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberSponsors.
     */
    cursor?: MemberSponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberSponsors.
     */
    distinct?: MemberSponsorScalarFieldEnum | MemberSponsorScalarFieldEnum[]
  }

  /**
   * MemberSponsor findMany
   */
  export type MemberSponsorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * Filter, which MemberSponsors to fetch.
     */
    where?: MemberSponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSponsors to fetch.
     */
    orderBy?: MemberSponsorOrderByWithRelationInput | MemberSponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberSponsors.
     */
    cursor?: MemberSponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSponsors.
     */
    skip?: number
    distinct?: MemberSponsorScalarFieldEnum | MemberSponsorScalarFieldEnum[]
  }

  /**
   * MemberSponsor create
   */
  export type MemberSponsorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberSponsor.
     */
    data: XOR<MemberSponsorCreateInput, MemberSponsorUncheckedCreateInput>
  }

  /**
   * MemberSponsor createMany
   */
  export type MemberSponsorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberSponsors.
     */
    data: MemberSponsorCreateManyInput | MemberSponsorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberSponsor createManyAndReturn
   */
  export type MemberSponsorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * The data used to create many MemberSponsors.
     */
    data: MemberSponsorCreateManyInput | MemberSponsorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberSponsor update
   */
  export type MemberSponsorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberSponsor.
     */
    data: XOR<MemberSponsorUpdateInput, MemberSponsorUncheckedUpdateInput>
    /**
     * Choose, which MemberSponsor to update.
     */
    where: MemberSponsorWhereUniqueInput
  }

  /**
   * MemberSponsor updateMany
   */
  export type MemberSponsorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberSponsors.
     */
    data: XOR<MemberSponsorUpdateManyMutationInput, MemberSponsorUncheckedUpdateManyInput>
    /**
     * Filter which MemberSponsors to update
     */
    where?: MemberSponsorWhereInput
    /**
     * Limit how many MemberSponsors to update.
     */
    limit?: number
  }

  /**
   * MemberSponsor updateManyAndReturn
   */
  export type MemberSponsorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * The data used to update MemberSponsors.
     */
    data: XOR<MemberSponsorUpdateManyMutationInput, MemberSponsorUncheckedUpdateManyInput>
    /**
     * Filter which MemberSponsors to update
     */
    where?: MemberSponsorWhereInput
    /**
     * Limit how many MemberSponsors to update.
     */
    limit?: number
  }

  /**
   * MemberSponsor upsert
   */
  export type MemberSponsorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberSponsor to update in case it exists.
     */
    where: MemberSponsorWhereUniqueInput
    /**
     * In case the MemberSponsor found by the `where` argument doesn't exist, create a new MemberSponsor with this data.
     */
    create: XOR<MemberSponsorCreateInput, MemberSponsorUncheckedCreateInput>
    /**
     * In case the MemberSponsor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberSponsorUpdateInput, MemberSponsorUncheckedUpdateInput>
  }

  /**
   * MemberSponsor delete
   */
  export type MemberSponsorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
    /**
     * Filter which MemberSponsor to delete.
     */
    where: MemberSponsorWhereUniqueInput
  }

  /**
   * MemberSponsor deleteMany
   */
  export type MemberSponsorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberSponsors to delete
     */
    where?: MemberSponsorWhereInput
    /**
     * Limit how many MemberSponsors to delete.
     */
    limit?: number
  }

  /**
   * MemberSponsor without action
   */
  export type MemberSponsorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSponsor
     */
    select?: MemberSponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberSponsor
     */
    omit?: MemberSponsorOmit<ExtArgs> | null
  }


  /**
   * Model MemberTeamManager
   */

  export type AggregateMemberTeamManager = {
    _count: MemberTeamManagerCountAggregateOutputType | null
    _avg: MemberTeamManagerAvgAggregateOutputType | null
    _sum: MemberTeamManagerSumAggregateOutputType | null
    _min: MemberTeamManagerMinAggregateOutputType | null
    _max: MemberTeamManagerMaxAggregateOutputType | null
  }

  export type MemberTeamManagerAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    ord: number | null
  }

  export type MemberTeamManagerSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    ord: number | null
  }

  export type MemberTeamManagerMinAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    appointedDate: Date | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberTeamManagerMaxAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
    appointedDate: Date | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    bio: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberTeamManagerCountAggregateOutputType = {
    id: number
    personId: number
    appointedDate: number
    emergencyContactName: number
    emergencyContactPhone: number
    status: number
    bio: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberTeamManagerAvgAggregateInputType = {
    id?: true
    personId?: true
    ord?: true
  }

  export type MemberTeamManagerSumAggregateInputType = {
    id?: true
    personId?: true
    ord?: true
  }

  export type MemberTeamManagerMinAggregateInputType = {
    id?: true
    personId?: true
    appointedDate?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberTeamManagerMaxAggregateInputType = {
    id?: true
    personId?: true
    appointedDate?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberTeamManagerCountAggregateInputType = {
    id?: true
    personId?: true
    appointedDate?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    bio?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberTeamManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTeamManager to aggregate.
     */
    where?: MemberTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTeamManagers to fetch.
     */
    orderBy?: MemberTeamManagerOrderByWithRelationInput | MemberTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberTeamManagers
    **/
    _count?: true | MemberTeamManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberTeamManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberTeamManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberTeamManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberTeamManagerMaxAggregateInputType
  }

  export type GetMemberTeamManagerAggregateType<T extends MemberTeamManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberTeamManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberTeamManager[P]>
      : GetScalarType<T[P], AggregateMemberTeamManager[P]>
  }




  export type MemberTeamManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberTeamManagerWhereInput
    orderBy?: MemberTeamManagerOrderByWithAggregationInput | MemberTeamManagerOrderByWithAggregationInput[]
    by: MemberTeamManagerScalarFieldEnum[] | MemberTeamManagerScalarFieldEnum
    having?: MemberTeamManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberTeamManagerCountAggregateInputType | true
    _avg?: MemberTeamManagerAvgAggregateInputType
    _sum?: MemberTeamManagerSumAggregateInputType
    _min?: MemberTeamManagerMinAggregateInputType
    _max?: MemberTeamManagerMaxAggregateInputType
  }

  export type MemberTeamManagerGroupByOutputType = {
    id: Decimal
    personId: Decimal
    appointedDate: Date | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string
    bio: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: MemberTeamManagerCountAggregateOutputType | null
    _avg: MemberTeamManagerAvgAggregateOutputType | null
    _sum: MemberTeamManagerSumAggregateOutputType | null
    _min: MemberTeamManagerMinAggregateOutputType | null
    _max: MemberTeamManagerMaxAggregateOutputType | null
  }

  type GetMemberTeamManagerGroupByPayload<T extends MemberTeamManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberTeamManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberTeamManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberTeamManagerGroupByOutputType[P]>
            : GetScalarType<T[P], MemberTeamManagerGroupByOutputType[P]>
        }
      >
    >


  export type MemberTeamManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    appointedDate?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberTeamManager"]>

  export type MemberTeamManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    appointedDate?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberTeamManager"]>

  export type MemberTeamManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personId?: boolean
    appointedDate?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["memberTeamManager"]>

  export type MemberTeamManagerSelectScalar = {
    id?: boolean
    personId?: boolean
    appointedDate?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    bio?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberTeamManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personId" | "appointedDate" | "emergencyContactName" | "emergencyContactPhone" | "status" | "bio" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["memberTeamManager"]>

  export type $MemberTeamManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberTeamManager"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      personId: Prisma.Decimal
      appointedDate: Date | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      status: string
      bio: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["memberTeamManager"]>
    composites: {}
  }

  type MemberTeamManagerGetPayload<S extends boolean | null | undefined | MemberTeamManagerDefaultArgs> = $Result.GetResult<Prisma.$MemberTeamManagerPayload, S>

  type MemberTeamManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberTeamManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberTeamManagerCountAggregateInputType | true
    }

  export interface MemberTeamManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberTeamManager'], meta: { name: 'MemberTeamManager' } }
    /**
     * Find zero or one MemberTeamManager that matches the filter.
     * @param {MemberTeamManagerFindUniqueArgs} args - Arguments to find a MemberTeamManager
     * @example
     * // Get one MemberTeamManager
     * const memberTeamManager = await prisma.memberTeamManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberTeamManagerFindUniqueArgs>(args: SelectSubset<T, MemberTeamManagerFindUniqueArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MemberTeamManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberTeamManagerFindUniqueOrThrowArgs} args - Arguments to find a MemberTeamManager
     * @example
     * // Get one MemberTeamManager
     * const memberTeamManager = await prisma.memberTeamManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberTeamManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberTeamManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberTeamManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerFindFirstArgs} args - Arguments to find a MemberTeamManager
     * @example
     * // Get one MemberTeamManager
     * const memberTeamManager = await prisma.memberTeamManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberTeamManagerFindFirstArgs>(args?: SelectSubset<T, MemberTeamManagerFindFirstArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MemberTeamManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerFindFirstOrThrowArgs} args - Arguments to find a MemberTeamManager
     * @example
     * // Get one MemberTeamManager
     * const memberTeamManager = await prisma.memberTeamManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberTeamManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberTeamManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MemberTeamManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberTeamManagers
     * const memberTeamManagers = await prisma.memberTeamManager.findMany()
     * 
     * // Get first 10 MemberTeamManagers
     * const memberTeamManagers = await prisma.memberTeamManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberTeamManagerWithIdOnly = await prisma.memberTeamManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberTeamManagerFindManyArgs>(args?: SelectSubset<T, MemberTeamManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MemberTeamManager.
     * @param {MemberTeamManagerCreateArgs} args - Arguments to create a MemberTeamManager.
     * @example
     * // Create one MemberTeamManager
     * const MemberTeamManager = await prisma.memberTeamManager.create({
     *   data: {
     *     // ... data to create a MemberTeamManager
     *   }
     * })
     * 
     */
    create<T extends MemberTeamManagerCreateArgs>(args: SelectSubset<T, MemberTeamManagerCreateArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MemberTeamManagers.
     * @param {MemberTeamManagerCreateManyArgs} args - Arguments to create many MemberTeamManagers.
     * @example
     * // Create many MemberTeamManagers
     * const memberTeamManager = await prisma.memberTeamManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberTeamManagerCreateManyArgs>(args?: SelectSubset<T, MemberTeamManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MemberTeamManagers and returns the data saved in the database.
     * @param {MemberTeamManagerCreateManyAndReturnArgs} args - Arguments to create many MemberTeamManagers.
     * @example
     * // Create many MemberTeamManagers
     * const memberTeamManager = await prisma.memberTeamManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MemberTeamManagers and only return the `id`
     * const memberTeamManagerWithIdOnly = await prisma.memberTeamManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberTeamManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberTeamManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MemberTeamManager.
     * @param {MemberTeamManagerDeleteArgs} args - Arguments to delete one MemberTeamManager.
     * @example
     * // Delete one MemberTeamManager
     * const MemberTeamManager = await prisma.memberTeamManager.delete({
     *   where: {
     *     // ... filter to delete one MemberTeamManager
     *   }
     * })
     * 
     */
    delete<T extends MemberTeamManagerDeleteArgs>(args: SelectSubset<T, MemberTeamManagerDeleteArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MemberTeamManager.
     * @param {MemberTeamManagerUpdateArgs} args - Arguments to update one MemberTeamManager.
     * @example
     * // Update one MemberTeamManager
     * const memberTeamManager = await prisma.memberTeamManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberTeamManagerUpdateArgs>(args: SelectSubset<T, MemberTeamManagerUpdateArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MemberTeamManagers.
     * @param {MemberTeamManagerDeleteManyArgs} args - Arguments to filter MemberTeamManagers to delete.
     * @example
     * // Delete a few MemberTeamManagers
     * const { count } = await prisma.memberTeamManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberTeamManagerDeleteManyArgs>(args?: SelectSubset<T, MemberTeamManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberTeamManagers
     * const memberTeamManager = await prisma.memberTeamManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberTeamManagerUpdateManyArgs>(args: SelectSubset<T, MemberTeamManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberTeamManagers and returns the data updated in the database.
     * @param {MemberTeamManagerUpdateManyAndReturnArgs} args - Arguments to update many MemberTeamManagers.
     * @example
     * // Update many MemberTeamManagers
     * const memberTeamManager = await prisma.memberTeamManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MemberTeamManagers and only return the `id`
     * const memberTeamManagerWithIdOnly = await prisma.memberTeamManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberTeamManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberTeamManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MemberTeamManager.
     * @param {MemberTeamManagerUpsertArgs} args - Arguments to update or create a MemberTeamManager.
     * @example
     * // Update or create a MemberTeamManager
     * const memberTeamManager = await prisma.memberTeamManager.upsert({
     *   create: {
     *     // ... data to create a MemberTeamManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberTeamManager we want to update
     *   }
     * })
     */
    upsert<T extends MemberTeamManagerUpsertArgs>(args: SelectSubset<T, MemberTeamManagerUpsertArgs<ExtArgs>>): Prisma__MemberTeamManagerClient<$Result.GetResult<Prisma.$MemberTeamManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MemberTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerCountArgs} args - Arguments to filter MemberTeamManagers to count.
     * @example
     * // Count the number of MemberTeamManagers
     * const count = await prisma.memberTeamManager.count({
     *   where: {
     *     // ... the filter for the MemberTeamManagers we want to count
     *   }
     * })
    **/
    count<T extends MemberTeamManagerCountArgs>(
      args?: Subset<T, MemberTeamManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberTeamManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberTeamManagerAggregateArgs>(args: Subset<T, MemberTeamManagerAggregateArgs>): Prisma.PrismaPromise<GetMemberTeamManagerAggregateType<T>>

    /**
     * Group by MemberTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberTeamManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberTeamManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberTeamManagerGroupByArgs['orderBy'] }
        : { orderBy?: MemberTeamManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberTeamManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberTeamManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberTeamManager model
   */
  readonly fields: MemberTeamManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberTeamManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberTeamManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberTeamManager model
   */
  interface MemberTeamManagerFieldRefs {
    readonly id: FieldRef<"MemberTeamManager", 'Decimal'>
    readonly personId: FieldRef<"MemberTeamManager", 'Decimal'>
    readonly appointedDate: FieldRef<"MemberTeamManager", 'DateTime'>
    readonly emergencyContactName: FieldRef<"MemberTeamManager", 'String'>
    readonly emergencyContactPhone: FieldRef<"MemberTeamManager", 'String'>
    readonly status: FieldRef<"MemberTeamManager", 'String'>
    readonly bio: FieldRef<"MemberTeamManager", 'String'>
    readonly ord: FieldRef<"MemberTeamManager", 'Int'>
    readonly createdAt: FieldRef<"MemberTeamManager", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberTeamManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MemberTeamManager findUnique
   */
  export type MemberTeamManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MemberTeamManager to fetch.
     */
    where: MemberTeamManagerWhereUniqueInput
  }

  /**
   * MemberTeamManager findUniqueOrThrow
   */
  export type MemberTeamManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MemberTeamManager to fetch.
     */
    where: MemberTeamManagerWhereUniqueInput
  }

  /**
   * MemberTeamManager findFirst
   */
  export type MemberTeamManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MemberTeamManager to fetch.
     */
    where?: MemberTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTeamManagers to fetch.
     */
    orderBy?: MemberTeamManagerOrderByWithRelationInput | MemberTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTeamManagers.
     */
    cursor?: MemberTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTeamManagers.
     */
    distinct?: MemberTeamManagerScalarFieldEnum | MemberTeamManagerScalarFieldEnum[]
  }

  /**
   * MemberTeamManager findFirstOrThrow
   */
  export type MemberTeamManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MemberTeamManager to fetch.
     */
    where?: MemberTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTeamManagers to fetch.
     */
    orderBy?: MemberTeamManagerOrderByWithRelationInput | MemberTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberTeamManagers.
     */
    cursor?: MemberTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberTeamManagers.
     */
    distinct?: MemberTeamManagerScalarFieldEnum | MemberTeamManagerScalarFieldEnum[]
  }

  /**
   * MemberTeamManager findMany
   */
  export type MemberTeamManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MemberTeamManagers to fetch.
     */
    where?: MemberTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberTeamManagers to fetch.
     */
    orderBy?: MemberTeamManagerOrderByWithRelationInput | MemberTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberTeamManagers.
     */
    cursor?: MemberTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberTeamManagers.
     */
    skip?: number
    distinct?: MemberTeamManagerScalarFieldEnum | MemberTeamManagerScalarFieldEnum[]
  }

  /**
   * MemberTeamManager create
   */
  export type MemberTeamManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to create a MemberTeamManager.
     */
    data: XOR<MemberTeamManagerCreateInput, MemberTeamManagerUncheckedCreateInput>
  }

  /**
   * MemberTeamManager createMany
   */
  export type MemberTeamManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberTeamManagers.
     */
    data: MemberTeamManagerCreateManyInput | MemberTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberTeamManager createManyAndReturn
   */
  export type MemberTeamManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to create many MemberTeamManagers.
     */
    data: MemberTeamManagerCreateManyInput | MemberTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberTeamManager update
   */
  export type MemberTeamManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to update a MemberTeamManager.
     */
    data: XOR<MemberTeamManagerUpdateInput, MemberTeamManagerUncheckedUpdateInput>
    /**
     * Choose, which MemberTeamManager to update.
     */
    where: MemberTeamManagerWhereUniqueInput
  }

  /**
   * MemberTeamManager updateMany
   */
  export type MemberTeamManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberTeamManagers.
     */
    data: XOR<MemberTeamManagerUpdateManyMutationInput, MemberTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which MemberTeamManagers to update
     */
    where?: MemberTeamManagerWhereInput
    /**
     * Limit how many MemberTeamManagers to update.
     */
    limit?: number
  }

  /**
   * MemberTeamManager updateManyAndReturn
   */
  export type MemberTeamManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to update MemberTeamManagers.
     */
    data: XOR<MemberTeamManagerUpdateManyMutationInput, MemberTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which MemberTeamManagers to update
     */
    where?: MemberTeamManagerWhereInput
    /**
     * Limit how many MemberTeamManagers to update.
     */
    limit?: number
  }

  /**
   * MemberTeamManager upsert
   */
  export type MemberTeamManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * The filter to search for the MemberTeamManager to update in case it exists.
     */
    where: MemberTeamManagerWhereUniqueInput
    /**
     * In case the MemberTeamManager found by the `where` argument doesn't exist, create a new MemberTeamManager with this data.
     */
    create: XOR<MemberTeamManagerCreateInput, MemberTeamManagerUncheckedCreateInput>
    /**
     * In case the MemberTeamManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberTeamManagerUpdateInput, MemberTeamManagerUncheckedUpdateInput>
  }

  /**
   * MemberTeamManager delete
   */
  export type MemberTeamManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
    /**
     * Filter which MemberTeamManager to delete.
     */
    where: MemberTeamManagerWhereUniqueInput
  }

  /**
   * MemberTeamManager deleteMany
   */
  export type MemberTeamManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberTeamManagers to delete
     */
    where?: MemberTeamManagerWhereInput
    /**
     * Limit how many MemberTeamManagers to delete.
     */
    limit?: number
  }

  /**
   * MemberTeamManager without action
   */
  export type MemberTeamManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberTeamManager
     */
    select?: MemberTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MemberTeamManager
     */
    omit?: MemberTeamManagerOmit<ExtArgs> | null
  }


  /**
   * Model OrgClub
   */

  export type AggregateOrgClub = {
    _count: OrgClubCountAggregateOutputType | null
    _avg: OrgClubAvgAggregateOutputType | null
    _sum: OrgClubSumAggregateOutputType | null
    _min: OrgClubMinAggregateOutputType | null
    _max: OrgClubMaxAggregateOutputType | null
  }

  export type OrgClubAvgAggregateOutputType = {
    id: Decimal | null
    ord: number | null
  }

  export type OrgClubSumAggregateOutputType = {
    id: Decimal | null
    ord: number | null
  }

  export type OrgClubMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    description: string | null
    foundedDate: Date | null
    address: string | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    status: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrgClubMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    description: string | null
    foundedDate: Date | null
    address: string | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    status: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrgClubCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    description: number
    foundedDate: number
    address: number
    contactEmail: number
    contactPhone: number
    website: number
    status: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrgClubAvgAggregateInputType = {
    id?: true
    ord?: true
  }

  export type OrgClubSumAggregateInputType = {
    id?: true
    ord?: true
  }

  export type OrgClubMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    description?: true
    foundedDate?: true
    address?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrgClubMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    description?: true
    foundedDate?: true
    address?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrgClubCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    description?: true
    foundedDate?: true
    address?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrgClubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgClub to aggregate.
     */
    where?: OrgClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgClubs to fetch.
     */
    orderBy?: OrgClubOrderByWithRelationInput | OrgClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgClubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrgClubs
    **/
    _count?: true | OrgClubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrgClubAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrgClubSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgClubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgClubMaxAggregateInputType
  }

  export type GetOrgClubAggregateType<T extends OrgClubAggregateArgs> = {
        [P in keyof T & keyof AggregateOrgClub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgClub[P]>
      : GetScalarType<T[P], AggregateOrgClub[P]>
  }




  export type OrgClubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgClubWhereInput
    orderBy?: OrgClubOrderByWithAggregationInput | OrgClubOrderByWithAggregationInput[]
    by: OrgClubScalarFieldEnum[] | OrgClubScalarFieldEnum
    having?: OrgClubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgClubCountAggregateInputType | true
    _avg?: OrgClubAvgAggregateInputType
    _sum?: OrgClubSumAggregateInputType
    _min?: OrgClubMinAggregateInputType
    _max?: OrgClubMaxAggregateInputType
  }

  export type OrgClubGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string | null
    description: string | null
    foundedDate: Date | null
    address: string | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    status: string
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: OrgClubCountAggregateOutputType | null
    _avg: OrgClubAvgAggregateOutputType | null
    _sum: OrgClubSumAggregateOutputType | null
    _min: OrgClubMinAggregateOutputType | null
    _max: OrgClubMaxAggregateOutputType | null
  }

  type GetOrgClubGroupByPayload<T extends OrgClubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgClubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgClubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgClubGroupByOutputType[P]>
            : GetScalarType<T[P], OrgClubGroupByOutputType[P]>
        }
      >
    >


  export type OrgClubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    foundedDate?: boolean
    address?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgClub"]>

  export type OrgClubSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    foundedDate?: boolean
    address?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgClub"]>

  export type OrgClubSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    foundedDate?: boolean
    address?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgClub"]>

  export type OrgClubSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    foundedDate?: boolean
    address?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrgClubOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "description" | "foundedDate" | "address" | "contactEmail" | "contactPhone" | "website" | "status" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["orgClub"]>

  export type $OrgClubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrgClub"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string | null
      description: string | null
      foundedDate: Date | null
      address: string | null
      contactEmail: string | null
      contactPhone: string | null
      website: string | null
      status: string
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["orgClub"]>
    composites: {}
  }

  type OrgClubGetPayload<S extends boolean | null | undefined | OrgClubDefaultArgs> = $Result.GetResult<Prisma.$OrgClubPayload, S>

  type OrgClubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrgClubFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrgClubCountAggregateInputType | true
    }

  export interface OrgClubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrgClub'], meta: { name: 'OrgClub' } }
    /**
     * Find zero or one OrgClub that matches the filter.
     * @param {OrgClubFindUniqueArgs} args - Arguments to find a OrgClub
     * @example
     * // Get one OrgClub
     * const orgClub = await prisma.orgClub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgClubFindUniqueArgs>(args: SelectSubset<T, OrgClubFindUniqueArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrgClub that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgClubFindUniqueOrThrowArgs} args - Arguments to find a OrgClub
     * @example
     * // Get one OrgClub
     * const orgClub = await prisma.orgClub.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgClubFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgClubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgClub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubFindFirstArgs} args - Arguments to find a OrgClub
     * @example
     * // Get one OrgClub
     * const orgClub = await prisma.orgClub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgClubFindFirstArgs>(args?: SelectSubset<T, OrgClubFindFirstArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgClub that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubFindFirstOrThrowArgs} args - Arguments to find a OrgClub
     * @example
     * // Get one OrgClub
     * const orgClub = await prisma.orgClub.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgClubFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgClubFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrgClubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgClubs
     * const orgClubs = await prisma.orgClub.findMany()
     * 
     * // Get first 10 OrgClubs
     * const orgClubs = await prisma.orgClub.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgClubWithIdOnly = await prisma.orgClub.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgClubFindManyArgs>(args?: SelectSubset<T, OrgClubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrgClub.
     * @param {OrgClubCreateArgs} args - Arguments to create a OrgClub.
     * @example
     * // Create one OrgClub
     * const OrgClub = await prisma.orgClub.create({
     *   data: {
     *     // ... data to create a OrgClub
     *   }
     * })
     * 
     */
    create<T extends OrgClubCreateArgs>(args: SelectSubset<T, OrgClubCreateArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrgClubs.
     * @param {OrgClubCreateManyArgs} args - Arguments to create many OrgClubs.
     * @example
     * // Create many OrgClubs
     * const orgClub = await prisma.orgClub.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgClubCreateManyArgs>(args?: SelectSubset<T, OrgClubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrgClubs and returns the data saved in the database.
     * @param {OrgClubCreateManyAndReturnArgs} args - Arguments to create many OrgClubs.
     * @example
     * // Create many OrgClubs
     * const orgClub = await prisma.orgClub.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrgClubs and only return the `id`
     * const orgClubWithIdOnly = await prisma.orgClub.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgClubCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgClubCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrgClub.
     * @param {OrgClubDeleteArgs} args - Arguments to delete one OrgClub.
     * @example
     * // Delete one OrgClub
     * const OrgClub = await prisma.orgClub.delete({
     *   where: {
     *     // ... filter to delete one OrgClub
     *   }
     * })
     * 
     */
    delete<T extends OrgClubDeleteArgs>(args: SelectSubset<T, OrgClubDeleteArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrgClub.
     * @param {OrgClubUpdateArgs} args - Arguments to update one OrgClub.
     * @example
     * // Update one OrgClub
     * const orgClub = await prisma.orgClub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgClubUpdateArgs>(args: SelectSubset<T, OrgClubUpdateArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrgClubs.
     * @param {OrgClubDeleteManyArgs} args - Arguments to filter OrgClubs to delete.
     * @example
     * // Delete a few OrgClubs
     * const { count } = await prisma.orgClub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgClubDeleteManyArgs>(args?: SelectSubset<T, OrgClubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgClubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgClubs
     * const orgClub = await prisma.orgClub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgClubUpdateManyArgs>(args: SelectSubset<T, OrgClubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgClubs and returns the data updated in the database.
     * @param {OrgClubUpdateManyAndReturnArgs} args - Arguments to update many OrgClubs.
     * @example
     * // Update many OrgClubs
     * const orgClub = await prisma.orgClub.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrgClubs and only return the `id`
     * const orgClubWithIdOnly = await prisma.orgClub.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrgClubUpdateManyAndReturnArgs>(args: SelectSubset<T, OrgClubUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrgClub.
     * @param {OrgClubUpsertArgs} args - Arguments to update or create a OrgClub.
     * @example
     * // Update or create a OrgClub
     * const orgClub = await prisma.orgClub.upsert({
     *   create: {
     *     // ... data to create a OrgClub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgClub we want to update
     *   }
     * })
     */
    upsert<T extends OrgClubUpsertArgs>(args: SelectSubset<T, OrgClubUpsertArgs<ExtArgs>>): Prisma__OrgClubClient<$Result.GetResult<Prisma.$OrgClubPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrgClubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubCountArgs} args - Arguments to filter OrgClubs to count.
     * @example
     * // Count the number of OrgClubs
     * const count = await prisma.orgClub.count({
     *   where: {
     *     // ... the filter for the OrgClubs we want to count
     *   }
     * })
    **/
    count<T extends OrgClubCountArgs>(
      args?: Subset<T, OrgClubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgClubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrgClub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgClubAggregateArgs>(args: Subset<T, OrgClubAggregateArgs>): Prisma.PrismaPromise<GetOrgClubAggregateType<T>>

    /**
     * Group by OrgClub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgClubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgClubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgClubGroupByArgs['orderBy'] }
        : { orderBy?: OrgClubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgClubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgClubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrgClub model
   */
  readonly fields: OrgClubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgClub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgClubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrgClub model
   */
  interface OrgClubFieldRefs {
    readonly id: FieldRef<"OrgClub", 'Decimal'>
    readonly name: FieldRef<"OrgClub", 'String'>
    readonly abbr: FieldRef<"OrgClub", 'String'>
    readonly description: FieldRef<"OrgClub", 'String'>
    readonly foundedDate: FieldRef<"OrgClub", 'DateTime'>
    readonly address: FieldRef<"OrgClub", 'String'>
    readonly contactEmail: FieldRef<"OrgClub", 'String'>
    readonly contactPhone: FieldRef<"OrgClub", 'String'>
    readonly website: FieldRef<"OrgClub", 'String'>
    readonly status: FieldRef<"OrgClub", 'String'>
    readonly ord: FieldRef<"OrgClub", 'Int'>
    readonly createdAt: FieldRef<"OrgClub", 'DateTime'>
    readonly updatedAt: FieldRef<"OrgClub", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrgClub findUnique
   */
  export type OrgClubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * Filter, which OrgClub to fetch.
     */
    where: OrgClubWhereUniqueInput
  }

  /**
   * OrgClub findUniqueOrThrow
   */
  export type OrgClubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * Filter, which OrgClub to fetch.
     */
    where: OrgClubWhereUniqueInput
  }

  /**
   * OrgClub findFirst
   */
  export type OrgClubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * Filter, which OrgClub to fetch.
     */
    where?: OrgClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgClubs to fetch.
     */
    orderBy?: OrgClubOrderByWithRelationInput | OrgClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgClubs.
     */
    cursor?: OrgClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgClubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgClubs.
     */
    distinct?: OrgClubScalarFieldEnum | OrgClubScalarFieldEnum[]
  }

  /**
   * OrgClub findFirstOrThrow
   */
  export type OrgClubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * Filter, which OrgClub to fetch.
     */
    where?: OrgClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgClubs to fetch.
     */
    orderBy?: OrgClubOrderByWithRelationInput | OrgClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgClubs.
     */
    cursor?: OrgClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgClubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgClubs.
     */
    distinct?: OrgClubScalarFieldEnum | OrgClubScalarFieldEnum[]
  }

  /**
   * OrgClub findMany
   */
  export type OrgClubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * Filter, which OrgClubs to fetch.
     */
    where?: OrgClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgClubs to fetch.
     */
    orderBy?: OrgClubOrderByWithRelationInput | OrgClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrgClubs.
     */
    cursor?: OrgClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgClubs.
     */
    skip?: number
    distinct?: OrgClubScalarFieldEnum | OrgClubScalarFieldEnum[]
  }

  /**
   * OrgClub create
   */
  export type OrgClubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * The data needed to create a OrgClub.
     */
    data: XOR<OrgClubCreateInput, OrgClubUncheckedCreateInput>
  }

  /**
   * OrgClub createMany
   */
  export type OrgClubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrgClubs.
     */
    data: OrgClubCreateManyInput | OrgClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgClub createManyAndReturn
   */
  export type OrgClubCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * The data used to create many OrgClubs.
     */
    data: OrgClubCreateManyInput | OrgClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgClub update
   */
  export type OrgClubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * The data needed to update a OrgClub.
     */
    data: XOR<OrgClubUpdateInput, OrgClubUncheckedUpdateInput>
    /**
     * Choose, which OrgClub to update.
     */
    where: OrgClubWhereUniqueInput
  }

  /**
   * OrgClub updateMany
   */
  export type OrgClubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrgClubs.
     */
    data: XOR<OrgClubUpdateManyMutationInput, OrgClubUncheckedUpdateManyInput>
    /**
     * Filter which OrgClubs to update
     */
    where?: OrgClubWhereInput
    /**
     * Limit how many OrgClubs to update.
     */
    limit?: number
  }

  /**
   * OrgClub updateManyAndReturn
   */
  export type OrgClubUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * The data used to update OrgClubs.
     */
    data: XOR<OrgClubUpdateManyMutationInput, OrgClubUncheckedUpdateManyInput>
    /**
     * Filter which OrgClubs to update
     */
    where?: OrgClubWhereInput
    /**
     * Limit how many OrgClubs to update.
     */
    limit?: number
  }

  /**
   * OrgClub upsert
   */
  export type OrgClubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * The filter to search for the OrgClub to update in case it exists.
     */
    where: OrgClubWhereUniqueInput
    /**
     * In case the OrgClub found by the `where` argument doesn't exist, create a new OrgClub with this data.
     */
    create: XOR<OrgClubCreateInput, OrgClubUncheckedCreateInput>
    /**
     * In case the OrgClub was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgClubUpdateInput, OrgClubUncheckedUpdateInput>
  }

  /**
   * OrgClub delete
   */
  export type OrgClubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
    /**
     * Filter which OrgClub to delete.
     */
    where: OrgClubWhereUniqueInput
  }

  /**
   * OrgClub deleteMany
   */
  export type OrgClubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgClubs to delete
     */
    where?: OrgClubWhereInput
    /**
     * Limit how many OrgClubs to delete.
     */
    limit?: number
  }

  /**
   * OrgClub without action
   */
  export type OrgClubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgClub
     */
    select?: OrgClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgClub
     */
    omit?: OrgClubOmit<ExtArgs> | null
  }


  /**
   * Model OrgLeague
   */

  export type AggregateOrgLeague = {
    _count: OrgLeagueCountAggregateOutputType | null
    _avg: OrgLeagueAvgAggregateOutputType | null
    _sum: OrgLeagueSumAggregateOutputType | null
    _min: OrgLeagueMinAggregateOutputType | null
    _max: OrgLeagueMaxAggregateOutputType | null
  }

  export type OrgLeagueAvgAggregateOutputType = {
    id: Decimal | null
    gameModeId: Decimal | null
    groupLevelId: Decimal | null
    maxTeams: number | null
    entryFee: Decimal | null
    ord: number | null
  }

  export type OrgLeagueSumAggregateOutputType = {
    id: Decimal | null
    gameModeId: Decimal | null
    groupLevelId: Decimal | null
    maxTeams: number | null
    entryFee: Decimal | null
    ord: number | null
  }

  export type OrgLeagueMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    description: string | null
    gameModeId: Decimal | null
    groupLevelId: Decimal | null
    season: string | null
    startDate: Date | null
    endDate: Date | null
    registrationDeadline: Date | null
    maxTeams: number | null
    entryFee: Decimal | null
    subscribeEmail: string | null
    rules: string | null
    status: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrgLeagueMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    description: string | null
    gameModeId: Decimal | null
    groupLevelId: Decimal | null
    season: string | null
    startDate: Date | null
    endDate: Date | null
    registrationDeadline: Date | null
    maxTeams: number | null
    entryFee: Decimal | null
    subscribeEmail: string | null
    rules: string | null
    status: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrgLeagueCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    description: number
    gameModeId: number
    groupLevelId: number
    season: number
    startDate: number
    endDate: number
    registrationDeadline: number
    maxTeams: number
    entryFee: number
    subscribeEmail: number
    rules: number
    status: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrgLeagueAvgAggregateInputType = {
    id?: true
    gameModeId?: true
    groupLevelId?: true
    maxTeams?: true
    entryFee?: true
    ord?: true
  }

  export type OrgLeagueSumAggregateInputType = {
    id?: true
    gameModeId?: true
    groupLevelId?: true
    maxTeams?: true
    entryFee?: true
    ord?: true
  }

  export type OrgLeagueMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    description?: true
    gameModeId?: true
    groupLevelId?: true
    season?: true
    startDate?: true
    endDate?: true
    registrationDeadline?: true
    maxTeams?: true
    entryFee?: true
    subscribeEmail?: true
    rules?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrgLeagueMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    description?: true
    gameModeId?: true
    groupLevelId?: true
    season?: true
    startDate?: true
    endDate?: true
    registrationDeadline?: true
    maxTeams?: true
    entryFee?: true
    subscribeEmail?: true
    rules?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrgLeagueCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    description?: true
    gameModeId?: true
    groupLevelId?: true
    season?: true
    startDate?: true
    endDate?: true
    registrationDeadline?: true
    maxTeams?: true
    entryFee?: true
    subscribeEmail?: true
    rules?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrgLeagueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgLeague to aggregate.
     */
    where?: OrgLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgLeagues to fetch.
     */
    orderBy?: OrgLeagueOrderByWithRelationInput | OrgLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgLeagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrgLeagues
    **/
    _count?: true | OrgLeagueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrgLeagueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrgLeagueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgLeagueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgLeagueMaxAggregateInputType
  }

  export type GetOrgLeagueAggregateType<T extends OrgLeagueAggregateArgs> = {
        [P in keyof T & keyof AggregateOrgLeague]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgLeague[P]>
      : GetScalarType<T[P], AggregateOrgLeague[P]>
  }




  export type OrgLeagueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgLeagueWhereInput
    orderBy?: OrgLeagueOrderByWithAggregationInput | OrgLeagueOrderByWithAggregationInput[]
    by: OrgLeagueScalarFieldEnum[] | OrgLeagueScalarFieldEnum
    having?: OrgLeagueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgLeagueCountAggregateInputType | true
    _avg?: OrgLeagueAvgAggregateInputType
    _sum?: OrgLeagueSumAggregateInputType
    _min?: OrgLeagueMinAggregateInputType
    _max?: OrgLeagueMaxAggregateInputType
  }

  export type OrgLeagueGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string | null
    description: string | null
    gameModeId: Decimal | null
    groupLevelId: Decimal | null
    season: string | null
    startDate: Date | null
    endDate: Date | null
    registrationDeadline: Date | null
    maxTeams: number | null
    entryFee: Decimal | null
    subscribeEmail: string | null
    rules: string | null
    status: string
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: OrgLeagueCountAggregateOutputType | null
    _avg: OrgLeagueAvgAggregateOutputType | null
    _sum: OrgLeagueSumAggregateOutputType | null
    _min: OrgLeagueMinAggregateOutputType | null
    _max: OrgLeagueMaxAggregateOutputType | null
  }

  type GetOrgLeagueGroupByPayload<T extends OrgLeagueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgLeagueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgLeagueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgLeagueGroupByOutputType[P]>
            : GetScalarType<T[P], OrgLeagueGroupByOutputType[P]>
        }
      >
    >


  export type OrgLeagueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    gameModeId?: boolean
    groupLevelId?: boolean
    season?: boolean
    startDate?: boolean
    endDate?: boolean
    registrationDeadline?: boolean
    maxTeams?: boolean
    entryFee?: boolean
    subscribeEmail?: boolean
    rules?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgLeague"]>

  export type OrgLeagueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    gameModeId?: boolean
    groupLevelId?: boolean
    season?: boolean
    startDate?: boolean
    endDate?: boolean
    registrationDeadline?: boolean
    maxTeams?: boolean
    entryFee?: boolean
    subscribeEmail?: boolean
    rules?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgLeague"]>

  export type OrgLeagueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    gameModeId?: boolean
    groupLevelId?: boolean
    season?: boolean
    startDate?: boolean
    endDate?: boolean
    registrationDeadline?: boolean
    maxTeams?: boolean
    entryFee?: boolean
    subscribeEmail?: boolean
    rules?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgLeague"]>

  export type OrgLeagueSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    description?: boolean
    gameModeId?: boolean
    groupLevelId?: boolean
    season?: boolean
    startDate?: boolean
    endDate?: boolean
    registrationDeadline?: boolean
    maxTeams?: boolean
    entryFee?: boolean
    subscribeEmail?: boolean
    rules?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrgLeagueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "description" | "gameModeId" | "groupLevelId" | "season" | "startDate" | "endDate" | "registrationDeadline" | "maxTeams" | "entryFee" | "subscribeEmail" | "rules" | "status" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["orgLeague"]>

  export type $OrgLeaguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrgLeague"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string | null
      description: string | null
      gameModeId: Prisma.Decimal | null
      groupLevelId: Prisma.Decimal | null
      season: string | null
      startDate: Date | null
      endDate: Date | null
      registrationDeadline: Date | null
      maxTeams: number | null
      entryFee: Prisma.Decimal | null
      subscribeEmail: string | null
      rules: string | null
      status: string
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["orgLeague"]>
    composites: {}
  }

  type OrgLeagueGetPayload<S extends boolean | null | undefined | OrgLeagueDefaultArgs> = $Result.GetResult<Prisma.$OrgLeaguePayload, S>

  type OrgLeagueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrgLeagueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrgLeagueCountAggregateInputType | true
    }

  export interface OrgLeagueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrgLeague'], meta: { name: 'OrgLeague' } }
    /**
     * Find zero or one OrgLeague that matches the filter.
     * @param {OrgLeagueFindUniqueArgs} args - Arguments to find a OrgLeague
     * @example
     * // Get one OrgLeague
     * const orgLeague = await prisma.orgLeague.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgLeagueFindUniqueArgs>(args: SelectSubset<T, OrgLeagueFindUniqueArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrgLeague that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgLeagueFindUniqueOrThrowArgs} args - Arguments to find a OrgLeague
     * @example
     * // Get one OrgLeague
     * const orgLeague = await prisma.orgLeague.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgLeagueFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgLeagueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgLeague that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueFindFirstArgs} args - Arguments to find a OrgLeague
     * @example
     * // Get one OrgLeague
     * const orgLeague = await prisma.orgLeague.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgLeagueFindFirstArgs>(args?: SelectSubset<T, OrgLeagueFindFirstArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgLeague that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueFindFirstOrThrowArgs} args - Arguments to find a OrgLeague
     * @example
     * // Get one OrgLeague
     * const orgLeague = await prisma.orgLeague.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgLeagueFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgLeagueFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrgLeagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgLeagues
     * const orgLeagues = await prisma.orgLeague.findMany()
     * 
     * // Get first 10 OrgLeagues
     * const orgLeagues = await prisma.orgLeague.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgLeagueWithIdOnly = await prisma.orgLeague.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgLeagueFindManyArgs>(args?: SelectSubset<T, OrgLeagueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrgLeague.
     * @param {OrgLeagueCreateArgs} args - Arguments to create a OrgLeague.
     * @example
     * // Create one OrgLeague
     * const OrgLeague = await prisma.orgLeague.create({
     *   data: {
     *     // ... data to create a OrgLeague
     *   }
     * })
     * 
     */
    create<T extends OrgLeagueCreateArgs>(args: SelectSubset<T, OrgLeagueCreateArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrgLeagues.
     * @param {OrgLeagueCreateManyArgs} args - Arguments to create many OrgLeagues.
     * @example
     * // Create many OrgLeagues
     * const orgLeague = await prisma.orgLeague.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgLeagueCreateManyArgs>(args?: SelectSubset<T, OrgLeagueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrgLeagues and returns the data saved in the database.
     * @param {OrgLeagueCreateManyAndReturnArgs} args - Arguments to create many OrgLeagues.
     * @example
     * // Create many OrgLeagues
     * const orgLeague = await prisma.orgLeague.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrgLeagues and only return the `id`
     * const orgLeagueWithIdOnly = await prisma.orgLeague.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgLeagueCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgLeagueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrgLeague.
     * @param {OrgLeagueDeleteArgs} args - Arguments to delete one OrgLeague.
     * @example
     * // Delete one OrgLeague
     * const OrgLeague = await prisma.orgLeague.delete({
     *   where: {
     *     // ... filter to delete one OrgLeague
     *   }
     * })
     * 
     */
    delete<T extends OrgLeagueDeleteArgs>(args: SelectSubset<T, OrgLeagueDeleteArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrgLeague.
     * @param {OrgLeagueUpdateArgs} args - Arguments to update one OrgLeague.
     * @example
     * // Update one OrgLeague
     * const orgLeague = await prisma.orgLeague.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgLeagueUpdateArgs>(args: SelectSubset<T, OrgLeagueUpdateArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrgLeagues.
     * @param {OrgLeagueDeleteManyArgs} args - Arguments to filter OrgLeagues to delete.
     * @example
     * // Delete a few OrgLeagues
     * const { count } = await prisma.orgLeague.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgLeagueDeleteManyArgs>(args?: SelectSubset<T, OrgLeagueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgLeagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgLeagues
     * const orgLeague = await prisma.orgLeague.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgLeagueUpdateManyArgs>(args: SelectSubset<T, OrgLeagueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgLeagues and returns the data updated in the database.
     * @param {OrgLeagueUpdateManyAndReturnArgs} args - Arguments to update many OrgLeagues.
     * @example
     * // Update many OrgLeagues
     * const orgLeague = await prisma.orgLeague.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrgLeagues and only return the `id`
     * const orgLeagueWithIdOnly = await prisma.orgLeague.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrgLeagueUpdateManyAndReturnArgs>(args: SelectSubset<T, OrgLeagueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrgLeague.
     * @param {OrgLeagueUpsertArgs} args - Arguments to update or create a OrgLeague.
     * @example
     * // Update or create a OrgLeague
     * const orgLeague = await prisma.orgLeague.upsert({
     *   create: {
     *     // ... data to create a OrgLeague
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgLeague we want to update
     *   }
     * })
     */
    upsert<T extends OrgLeagueUpsertArgs>(args: SelectSubset<T, OrgLeagueUpsertArgs<ExtArgs>>): Prisma__OrgLeagueClient<$Result.GetResult<Prisma.$OrgLeaguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrgLeagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueCountArgs} args - Arguments to filter OrgLeagues to count.
     * @example
     * // Count the number of OrgLeagues
     * const count = await prisma.orgLeague.count({
     *   where: {
     *     // ... the filter for the OrgLeagues we want to count
     *   }
     * })
    **/
    count<T extends OrgLeagueCountArgs>(
      args?: Subset<T, OrgLeagueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgLeagueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrgLeague.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgLeagueAggregateArgs>(args: Subset<T, OrgLeagueAggregateArgs>): Prisma.PrismaPromise<GetOrgLeagueAggregateType<T>>

    /**
     * Group by OrgLeague.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgLeagueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgLeagueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgLeagueGroupByArgs['orderBy'] }
        : { orderBy?: OrgLeagueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgLeagueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgLeagueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrgLeague model
   */
  readonly fields: OrgLeagueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgLeague.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgLeagueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrgLeague model
   */
  interface OrgLeagueFieldRefs {
    readonly id: FieldRef<"OrgLeague", 'Decimal'>
    readonly name: FieldRef<"OrgLeague", 'String'>
    readonly abbr: FieldRef<"OrgLeague", 'String'>
    readonly description: FieldRef<"OrgLeague", 'String'>
    readonly gameModeId: FieldRef<"OrgLeague", 'Decimal'>
    readonly groupLevelId: FieldRef<"OrgLeague", 'Decimal'>
    readonly season: FieldRef<"OrgLeague", 'String'>
    readonly startDate: FieldRef<"OrgLeague", 'DateTime'>
    readonly endDate: FieldRef<"OrgLeague", 'DateTime'>
    readonly registrationDeadline: FieldRef<"OrgLeague", 'DateTime'>
    readonly maxTeams: FieldRef<"OrgLeague", 'Int'>
    readonly entryFee: FieldRef<"OrgLeague", 'Decimal'>
    readonly subscribeEmail: FieldRef<"OrgLeague", 'String'>
    readonly rules: FieldRef<"OrgLeague", 'String'>
    readonly status: FieldRef<"OrgLeague", 'String'>
    readonly ord: FieldRef<"OrgLeague", 'Int'>
    readonly createdAt: FieldRef<"OrgLeague", 'DateTime'>
    readonly updatedAt: FieldRef<"OrgLeague", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrgLeague findUnique
   */
  export type OrgLeagueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * Filter, which OrgLeague to fetch.
     */
    where: OrgLeagueWhereUniqueInput
  }

  /**
   * OrgLeague findUniqueOrThrow
   */
  export type OrgLeagueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * Filter, which OrgLeague to fetch.
     */
    where: OrgLeagueWhereUniqueInput
  }

  /**
   * OrgLeague findFirst
   */
  export type OrgLeagueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * Filter, which OrgLeague to fetch.
     */
    where?: OrgLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgLeagues to fetch.
     */
    orderBy?: OrgLeagueOrderByWithRelationInput | OrgLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgLeagues.
     */
    cursor?: OrgLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgLeagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgLeagues.
     */
    distinct?: OrgLeagueScalarFieldEnum | OrgLeagueScalarFieldEnum[]
  }

  /**
   * OrgLeague findFirstOrThrow
   */
  export type OrgLeagueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * Filter, which OrgLeague to fetch.
     */
    where?: OrgLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgLeagues to fetch.
     */
    orderBy?: OrgLeagueOrderByWithRelationInput | OrgLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgLeagues.
     */
    cursor?: OrgLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgLeagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgLeagues.
     */
    distinct?: OrgLeagueScalarFieldEnum | OrgLeagueScalarFieldEnum[]
  }

  /**
   * OrgLeague findMany
   */
  export type OrgLeagueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * Filter, which OrgLeagues to fetch.
     */
    where?: OrgLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgLeagues to fetch.
     */
    orderBy?: OrgLeagueOrderByWithRelationInput | OrgLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrgLeagues.
     */
    cursor?: OrgLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgLeagues.
     */
    skip?: number
    distinct?: OrgLeagueScalarFieldEnum | OrgLeagueScalarFieldEnum[]
  }

  /**
   * OrgLeague create
   */
  export type OrgLeagueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * The data needed to create a OrgLeague.
     */
    data: XOR<OrgLeagueCreateInput, OrgLeagueUncheckedCreateInput>
  }

  /**
   * OrgLeague createMany
   */
  export type OrgLeagueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrgLeagues.
     */
    data: OrgLeagueCreateManyInput | OrgLeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgLeague createManyAndReturn
   */
  export type OrgLeagueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * The data used to create many OrgLeagues.
     */
    data: OrgLeagueCreateManyInput | OrgLeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgLeague update
   */
  export type OrgLeagueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * The data needed to update a OrgLeague.
     */
    data: XOR<OrgLeagueUpdateInput, OrgLeagueUncheckedUpdateInput>
    /**
     * Choose, which OrgLeague to update.
     */
    where: OrgLeagueWhereUniqueInput
  }

  /**
   * OrgLeague updateMany
   */
  export type OrgLeagueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrgLeagues.
     */
    data: XOR<OrgLeagueUpdateManyMutationInput, OrgLeagueUncheckedUpdateManyInput>
    /**
     * Filter which OrgLeagues to update
     */
    where?: OrgLeagueWhereInput
    /**
     * Limit how many OrgLeagues to update.
     */
    limit?: number
  }

  /**
   * OrgLeague updateManyAndReturn
   */
  export type OrgLeagueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * The data used to update OrgLeagues.
     */
    data: XOR<OrgLeagueUpdateManyMutationInput, OrgLeagueUncheckedUpdateManyInput>
    /**
     * Filter which OrgLeagues to update
     */
    where?: OrgLeagueWhereInput
    /**
     * Limit how many OrgLeagues to update.
     */
    limit?: number
  }

  /**
   * OrgLeague upsert
   */
  export type OrgLeagueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * The filter to search for the OrgLeague to update in case it exists.
     */
    where: OrgLeagueWhereUniqueInput
    /**
     * In case the OrgLeague found by the `where` argument doesn't exist, create a new OrgLeague with this data.
     */
    create: XOR<OrgLeagueCreateInput, OrgLeagueUncheckedCreateInput>
    /**
     * In case the OrgLeague was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgLeagueUpdateInput, OrgLeagueUncheckedUpdateInput>
  }

  /**
   * OrgLeague delete
   */
  export type OrgLeagueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
    /**
     * Filter which OrgLeague to delete.
     */
    where: OrgLeagueWhereUniqueInput
  }

  /**
   * OrgLeague deleteMany
   */
  export type OrgLeagueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgLeagues to delete
     */
    where?: OrgLeagueWhereInput
    /**
     * Limit how many OrgLeagues to delete.
     */
    limit?: number
  }

  /**
   * OrgLeague without action
   */
  export type OrgLeagueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgLeague
     */
    select?: OrgLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgLeague
     */
    omit?: OrgLeagueOmit<ExtArgs> | null
  }


  /**
   * Model OrgTeam
   */

  export type AggregateOrgTeam = {
    _count: OrgTeamCountAggregateOutputType | null
    _avg: OrgTeamAvgAggregateOutputType | null
    _sum: OrgTeamSumAggregateOutputType | null
    _min: OrgTeamMinAggregateOutputType | null
    _max: OrgTeamMaxAggregateOutputType | null
  }

  export type OrgTeamAvgAggregateOutputType = {
    id: Decimal | null
    clubId: Decimal | null
    sportId: Decimal | null
    leagueId: Decimal | null
    gender: number | null
    maxPlayers: number | null
    status: number | null
    ord: number | null
  }

  export type OrgTeamSumAggregateOutputType = {
    id: Decimal | null
    clubId: Decimal | null
    sportId: Decimal | null
    leagueId: Decimal | null
    gender: number | null
    maxPlayers: number | null
    status: number | null
    ord: number | null
  }

  export type OrgTeamMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    note: string | null
    clubId: Decimal | null
    sportId: Decimal | null
    leagueId: Decimal | null
    ageGroup: string | null
    gender: number | null
    skillLevel: string | null
    color1: string | null
    color2: string | null
    maxPlayers: number | null
    status: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrgTeamMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    note: string | null
    clubId: Decimal | null
    sportId: Decimal | null
    leagueId: Decimal | null
    ageGroup: string | null
    gender: number | null
    skillLevel: string | null
    color1: string | null
    color2: string | null
    maxPlayers: number | null
    status: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrgTeamCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    note: number
    clubId: number
    sportId: number
    leagueId: number
    ageGroup: number
    gender: number
    skillLevel: number
    color1: number
    color2: number
    maxPlayers: number
    status: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrgTeamAvgAggregateInputType = {
    id?: true
    clubId?: true
    sportId?: true
    leagueId?: true
    gender?: true
    maxPlayers?: true
    status?: true
    ord?: true
  }

  export type OrgTeamSumAggregateInputType = {
    id?: true
    clubId?: true
    sportId?: true
    leagueId?: true
    gender?: true
    maxPlayers?: true
    status?: true
    ord?: true
  }

  export type OrgTeamMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    clubId?: true
    sportId?: true
    leagueId?: true
    ageGroup?: true
    gender?: true
    skillLevel?: true
    color1?: true
    color2?: true
    maxPlayers?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrgTeamMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    clubId?: true
    sportId?: true
    leagueId?: true
    ageGroup?: true
    gender?: true
    skillLevel?: true
    color1?: true
    color2?: true
    maxPlayers?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrgTeamCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    clubId?: true
    sportId?: true
    leagueId?: true
    ageGroup?: true
    gender?: true
    skillLevel?: true
    color1?: true
    color2?: true
    maxPlayers?: true
    status?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrgTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgTeam to aggregate.
     */
    where?: OrgTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgTeams to fetch.
     */
    orderBy?: OrgTeamOrderByWithRelationInput | OrgTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrgTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrgTeams
    **/
    _count?: true | OrgTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrgTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrgTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrgTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrgTeamMaxAggregateInputType
  }

  export type GetOrgTeamAggregateType<T extends OrgTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateOrgTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgTeam[P]>
      : GetScalarType<T[P], AggregateOrgTeam[P]>
  }




  export type OrgTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrgTeamWhereInput
    orderBy?: OrgTeamOrderByWithAggregationInput | OrgTeamOrderByWithAggregationInput[]
    by: OrgTeamScalarFieldEnum[] | OrgTeamScalarFieldEnum
    having?: OrgTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrgTeamCountAggregateInputType | true
    _avg?: OrgTeamAvgAggregateInputType
    _sum?: OrgTeamSumAggregateInputType
    _min?: OrgTeamMinAggregateInputType
    _max?: OrgTeamMaxAggregateInputType
  }

  export type OrgTeamGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string | null
    note: string | null
    clubId: Decimal | null
    sportId: Decimal | null
    leagueId: Decimal | null
    ageGroup: string | null
    gender: number | null
    skillLevel: string | null
    color1: string | null
    color2: string | null
    maxPlayers: number | null
    status: number
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: OrgTeamCountAggregateOutputType | null
    _avg: OrgTeamAvgAggregateOutputType | null
    _sum: OrgTeamSumAggregateOutputType | null
    _min: OrgTeamMinAggregateOutputType | null
    _max: OrgTeamMaxAggregateOutputType | null
  }

  type GetOrgTeamGroupByPayload<T extends OrgTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrgTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrgTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgTeamGroupByOutputType[P]>
            : GetScalarType<T[P], OrgTeamGroupByOutputType[P]>
        }
      >
    >


  export type OrgTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    clubId?: boolean
    sportId?: boolean
    leagueId?: boolean
    ageGroup?: boolean
    gender?: boolean
    skillLevel?: boolean
    color1?: boolean
    color2?: boolean
    maxPlayers?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgTeam"]>

  export type OrgTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    clubId?: boolean
    sportId?: boolean
    leagueId?: boolean
    ageGroup?: boolean
    gender?: boolean
    skillLevel?: boolean
    color1?: boolean
    color2?: boolean
    maxPlayers?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgTeam"]>

  export type OrgTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    clubId?: boolean
    sportId?: boolean
    leagueId?: boolean
    ageGroup?: boolean
    gender?: boolean
    skillLevel?: boolean
    color1?: boolean
    color2?: boolean
    maxPlayers?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orgTeam"]>

  export type OrgTeamSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    clubId?: boolean
    sportId?: boolean
    leagueId?: boolean
    ageGroup?: boolean
    gender?: boolean
    skillLevel?: boolean
    color1?: boolean
    color2?: boolean
    maxPlayers?: boolean
    status?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrgTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "note" | "clubId" | "sportId" | "leagueId" | "ageGroup" | "gender" | "skillLevel" | "color1" | "color2" | "maxPlayers" | "status" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["orgTeam"]>

  export type $OrgTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrgTeam"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string | null
      note: string | null
      clubId: Prisma.Decimal | null
      sportId: Prisma.Decimal | null
      leagueId: Prisma.Decimal | null
      ageGroup: string | null
      gender: number | null
      skillLevel: string | null
      color1: string | null
      color2: string | null
      maxPlayers: number | null
      status: number
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["orgTeam"]>
    composites: {}
  }

  type OrgTeamGetPayload<S extends boolean | null | undefined | OrgTeamDefaultArgs> = $Result.GetResult<Prisma.$OrgTeamPayload, S>

  type OrgTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrgTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrgTeamCountAggregateInputType | true
    }

  export interface OrgTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrgTeam'], meta: { name: 'OrgTeam' } }
    /**
     * Find zero or one OrgTeam that matches the filter.
     * @param {OrgTeamFindUniqueArgs} args - Arguments to find a OrgTeam
     * @example
     * // Get one OrgTeam
     * const orgTeam = await prisma.orgTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgTeamFindUniqueArgs>(args: SelectSubset<T, OrgTeamFindUniqueArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrgTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgTeamFindUniqueOrThrowArgs} args - Arguments to find a OrgTeam
     * @example
     * // Get one OrgTeam
     * const orgTeam = await prisma.orgTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, OrgTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamFindFirstArgs} args - Arguments to find a OrgTeam
     * @example
     * // Get one OrgTeam
     * const orgTeam = await prisma.orgTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgTeamFindFirstArgs>(args?: SelectSubset<T, OrgTeamFindFirstArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrgTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamFindFirstOrThrowArgs} args - Arguments to find a OrgTeam
     * @example
     * // Get one OrgTeam
     * const orgTeam = await prisma.orgTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, OrgTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrgTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgTeams
     * const orgTeams = await prisma.orgTeam.findMany()
     * 
     * // Get first 10 OrgTeams
     * const orgTeams = await prisma.orgTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orgTeamWithIdOnly = await prisma.orgTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrgTeamFindManyArgs>(args?: SelectSubset<T, OrgTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrgTeam.
     * @param {OrgTeamCreateArgs} args - Arguments to create a OrgTeam.
     * @example
     * // Create one OrgTeam
     * const OrgTeam = await prisma.orgTeam.create({
     *   data: {
     *     // ... data to create a OrgTeam
     *   }
     * })
     * 
     */
    create<T extends OrgTeamCreateArgs>(args: SelectSubset<T, OrgTeamCreateArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrgTeams.
     * @param {OrgTeamCreateManyArgs} args - Arguments to create many OrgTeams.
     * @example
     * // Create many OrgTeams
     * const orgTeam = await prisma.orgTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrgTeamCreateManyArgs>(args?: SelectSubset<T, OrgTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrgTeams and returns the data saved in the database.
     * @param {OrgTeamCreateManyAndReturnArgs} args - Arguments to create many OrgTeams.
     * @example
     * // Create many OrgTeams
     * const orgTeam = await prisma.orgTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrgTeams and only return the `id`
     * const orgTeamWithIdOnly = await prisma.orgTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrgTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, OrgTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrgTeam.
     * @param {OrgTeamDeleteArgs} args - Arguments to delete one OrgTeam.
     * @example
     * // Delete one OrgTeam
     * const OrgTeam = await prisma.orgTeam.delete({
     *   where: {
     *     // ... filter to delete one OrgTeam
     *   }
     * })
     * 
     */
    delete<T extends OrgTeamDeleteArgs>(args: SelectSubset<T, OrgTeamDeleteArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrgTeam.
     * @param {OrgTeamUpdateArgs} args - Arguments to update one OrgTeam.
     * @example
     * // Update one OrgTeam
     * const orgTeam = await prisma.orgTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrgTeamUpdateArgs>(args: SelectSubset<T, OrgTeamUpdateArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrgTeams.
     * @param {OrgTeamDeleteManyArgs} args - Arguments to filter OrgTeams to delete.
     * @example
     * // Delete a few OrgTeams
     * const { count } = await prisma.orgTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrgTeamDeleteManyArgs>(args?: SelectSubset<T, OrgTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgTeams
     * const orgTeam = await prisma.orgTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrgTeamUpdateManyArgs>(args: SelectSubset<T, OrgTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrgTeams and returns the data updated in the database.
     * @param {OrgTeamUpdateManyAndReturnArgs} args - Arguments to update many OrgTeams.
     * @example
     * // Update many OrgTeams
     * const orgTeam = await prisma.orgTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrgTeams and only return the `id`
     * const orgTeamWithIdOnly = await prisma.orgTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrgTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, OrgTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrgTeam.
     * @param {OrgTeamUpsertArgs} args - Arguments to update or create a OrgTeam.
     * @example
     * // Update or create a OrgTeam
     * const orgTeam = await prisma.orgTeam.upsert({
     *   create: {
     *     // ... data to create a OrgTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgTeam we want to update
     *   }
     * })
     */
    upsert<T extends OrgTeamUpsertArgs>(args: SelectSubset<T, OrgTeamUpsertArgs<ExtArgs>>): Prisma__OrgTeamClient<$Result.GetResult<Prisma.$OrgTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrgTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamCountArgs} args - Arguments to filter OrgTeams to count.
     * @example
     * // Count the number of OrgTeams
     * const count = await prisma.orgTeam.count({
     *   where: {
     *     // ... the filter for the OrgTeams we want to count
     *   }
     * })
    **/
    count<T extends OrgTeamCountArgs>(
      args?: Subset<T, OrgTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrgTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrgTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrgTeamAggregateArgs>(args: Subset<T, OrgTeamAggregateArgs>): Prisma.PrismaPromise<GetOrgTeamAggregateType<T>>

    /**
     * Group by OrgTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrgTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgTeamGroupByArgs['orderBy'] }
        : { orderBy?: OrgTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrgTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrgTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrgTeam model
   */
  readonly fields: OrgTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrgTeam model
   */
  interface OrgTeamFieldRefs {
    readonly id: FieldRef<"OrgTeam", 'Decimal'>
    readonly name: FieldRef<"OrgTeam", 'String'>
    readonly abbr: FieldRef<"OrgTeam", 'String'>
    readonly note: FieldRef<"OrgTeam", 'String'>
    readonly clubId: FieldRef<"OrgTeam", 'Decimal'>
    readonly sportId: FieldRef<"OrgTeam", 'Decimal'>
    readonly leagueId: FieldRef<"OrgTeam", 'Decimal'>
    readonly ageGroup: FieldRef<"OrgTeam", 'String'>
    readonly gender: FieldRef<"OrgTeam", 'Int'>
    readonly skillLevel: FieldRef<"OrgTeam", 'String'>
    readonly color1: FieldRef<"OrgTeam", 'String'>
    readonly color2: FieldRef<"OrgTeam", 'String'>
    readonly maxPlayers: FieldRef<"OrgTeam", 'Int'>
    readonly status: FieldRef<"OrgTeam", 'Int'>
    readonly ord: FieldRef<"OrgTeam", 'Int'>
    readonly createdAt: FieldRef<"OrgTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"OrgTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrgTeam findUnique
   */
  export type OrgTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * Filter, which OrgTeam to fetch.
     */
    where: OrgTeamWhereUniqueInput
  }

  /**
   * OrgTeam findUniqueOrThrow
   */
  export type OrgTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * Filter, which OrgTeam to fetch.
     */
    where: OrgTeamWhereUniqueInput
  }

  /**
   * OrgTeam findFirst
   */
  export type OrgTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * Filter, which OrgTeam to fetch.
     */
    where?: OrgTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgTeams to fetch.
     */
    orderBy?: OrgTeamOrderByWithRelationInput | OrgTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgTeams.
     */
    cursor?: OrgTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgTeams.
     */
    distinct?: OrgTeamScalarFieldEnum | OrgTeamScalarFieldEnum[]
  }

  /**
   * OrgTeam findFirstOrThrow
   */
  export type OrgTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * Filter, which OrgTeam to fetch.
     */
    where?: OrgTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgTeams to fetch.
     */
    orderBy?: OrgTeamOrderByWithRelationInput | OrgTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrgTeams.
     */
    cursor?: OrgTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrgTeams.
     */
    distinct?: OrgTeamScalarFieldEnum | OrgTeamScalarFieldEnum[]
  }

  /**
   * OrgTeam findMany
   */
  export type OrgTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * Filter, which OrgTeams to fetch.
     */
    where?: OrgTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrgTeams to fetch.
     */
    orderBy?: OrgTeamOrderByWithRelationInput | OrgTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrgTeams.
     */
    cursor?: OrgTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrgTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrgTeams.
     */
    skip?: number
    distinct?: OrgTeamScalarFieldEnum | OrgTeamScalarFieldEnum[]
  }

  /**
   * OrgTeam create
   */
  export type OrgTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * The data needed to create a OrgTeam.
     */
    data: XOR<OrgTeamCreateInput, OrgTeamUncheckedCreateInput>
  }

  /**
   * OrgTeam createMany
   */
  export type OrgTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrgTeams.
     */
    data: OrgTeamCreateManyInput | OrgTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgTeam createManyAndReturn
   */
  export type OrgTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * The data used to create many OrgTeams.
     */
    data: OrgTeamCreateManyInput | OrgTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrgTeam update
   */
  export type OrgTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * The data needed to update a OrgTeam.
     */
    data: XOR<OrgTeamUpdateInput, OrgTeamUncheckedUpdateInput>
    /**
     * Choose, which OrgTeam to update.
     */
    where: OrgTeamWhereUniqueInput
  }

  /**
   * OrgTeam updateMany
   */
  export type OrgTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrgTeams.
     */
    data: XOR<OrgTeamUpdateManyMutationInput, OrgTeamUncheckedUpdateManyInput>
    /**
     * Filter which OrgTeams to update
     */
    where?: OrgTeamWhereInput
    /**
     * Limit how many OrgTeams to update.
     */
    limit?: number
  }

  /**
   * OrgTeam updateManyAndReturn
   */
  export type OrgTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * The data used to update OrgTeams.
     */
    data: XOR<OrgTeamUpdateManyMutationInput, OrgTeamUncheckedUpdateManyInput>
    /**
     * Filter which OrgTeams to update
     */
    where?: OrgTeamWhereInput
    /**
     * Limit how many OrgTeams to update.
     */
    limit?: number
  }

  /**
   * OrgTeam upsert
   */
  export type OrgTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * The filter to search for the OrgTeam to update in case it exists.
     */
    where: OrgTeamWhereUniqueInput
    /**
     * In case the OrgTeam found by the `where` argument doesn't exist, create a new OrgTeam with this data.
     */
    create: XOR<OrgTeamCreateInput, OrgTeamUncheckedCreateInput>
    /**
     * In case the OrgTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgTeamUpdateInput, OrgTeamUncheckedUpdateInput>
  }

  /**
   * OrgTeam delete
   */
  export type OrgTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
    /**
     * Filter which OrgTeam to delete.
     */
    where: OrgTeamWhereUniqueInput
  }

  /**
   * OrgTeam deleteMany
   */
  export type OrgTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrgTeams to delete
     */
    where?: OrgTeamWhereInput
    /**
     * Limit how many OrgTeams to delete.
     */
    limit?: number
  }

  /**
   * OrgTeam without action
   */
  export type OrgTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrgTeam
     */
    select?: OrgTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrgTeam
     */
    omit?: OrgTeamOmit<ExtArgs> | null
  }


  /**
   * Model PlanGame
   */

  export type AggregatePlanGame = {
    _count: PlanGameCountAggregateOutputType | null
    _avg: PlanGameAvgAggregateOutputType | null
    _sum: PlanGameSumAggregateOutputType | null
    _min: PlanGameMinAggregateOutputType | null
    _max: PlanGameMaxAggregateOutputType | null
  }

  export type PlanGameAvgAggregateOutputType = {
    id: Decimal | null
    leagueId: Decimal | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    duration: number | null
    locationId: Decimal | null
    isScrimmage: number | null
    createdBy: Decimal | null
  }

  export type PlanGameSumAggregateOutputType = {
    id: Decimal | null
    leagueId: Decimal | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    duration: number | null
    locationId: Decimal | null
    isScrimmage: number | null
    createdBy: Decimal | null
  }

  export type PlanGameMinAggregateOutputType = {
    id: Decimal | null
    leagueId: Decimal | null
    gameName: string | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    startDatetime: Date | null
    endDatetime: Date | null
    duration: number | null
    uniform: string | null
    locationId: Decimal | null
    isScrimmage: number | null
    status: string | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanGameMaxAggregateOutputType = {
    id: Decimal | null
    leagueId: Decimal | null
    gameName: string | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    startDatetime: Date | null
    endDatetime: Date | null
    duration: number | null
    uniform: string | null
    locationId: Decimal | null
    isScrimmage: number | null
    status: string | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanGameCountAggregateOutputType = {
    id: number
    leagueId: number
    gameName: number
    homeTeamId: number
    awayTeamId: number
    startDatetime: number
    endDatetime: number
    duration: number
    uniform: number
    locationId: number
    isScrimmage: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanGameAvgAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    duration?: true
    locationId?: true
    isScrimmage?: true
    createdBy?: true
  }

  export type PlanGameSumAggregateInputType = {
    id?: true
    leagueId?: true
    homeTeamId?: true
    awayTeamId?: true
    duration?: true
    locationId?: true
    isScrimmage?: true
    createdBy?: true
  }

  export type PlanGameMinAggregateInputType = {
    id?: true
    leagueId?: true
    gameName?: true
    homeTeamId?: true
    awayTeamId?: true
    startDatetime?: true
    endDatetime?: true
    duration?: true
    uniform?: true
    locationId?: true
    isScrimmage?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanGameMaxAggregateInputType = {
    id?: true
    leagueId?: true
    gameName?: true
    homeTeamId?: true
    awayTeamId?: true
    startDatetime?: true
    endDatetime?: true
    duration?: true
    uniform?: true
    locationId?: true
    isScrimmage?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanGameCountAggregateInputType = {
    id?: true
    leagueId?: true
    gameName?: true
    homeTeamId?: true
    awayTeamId?: true
    startDatetime?: true
    endDatetime?: true
    duration?: true
    uniform?: true
    locationId?: true
    isScrimmage?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanGameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanGame to aggregate.
     */
    where?: PlanGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanGames to fetch.
     */
    orderBy?: PlanGameOrderByWithRelationInput | PlanGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanGames
    **/
    _count?: true | PlanGameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanGameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanGameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanGameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanGameMaxAggregateInputType
  }

  export type GetPlanGameAggregateType<T extends PlanGameAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanGame[P]>
      : GetScalarType<T[P], AggregatePlanGame[P]>
  }




  export type PlanGameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanGameWhereInput
    orderBy?: PlanGameOrderByWithAggregationInput | PlanGameOrderByWithAggregationInput[]
    by: PlanGameScalarFieldEnum[] | PlanGameScalarFieldEnum
    having?: PlanGameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanGameCountAggregateInputType | true
    _avg?: PlanGameAvgAggregateInputType
    _sum?: PlanGameSumAggregateInputType
    _min?: PlanGameMinAggregateInputType
    _max?: PlanGameMaxAggregateInputType
  }

  export type PlanGameGroupByOutputType = {
    id: Decimal
    leagueId: Decimal | null
    gameName: string | null
    homeTeamId: Decimal | null
    awayTeamId: Decimal | null
    startDatetime: Date
    endDatetime: Date
    duration: number | null
    uniform: string | null
    locationId: Decimal | null
    isScrimmage: number
    status: string
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: PlanGameCountAggregateOutputType | null
    _avg: PlanGameAvgAggregateOutputType | null
    _sum: PlanGameSumAggregateOutputType | null
    _min: PlanGameMinAggregateOutputType | null
    _max: PlanGameMaxAggregateOutputType | null
  }

  type GetPlanGameGroupByPayload<T extends PlanGameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGameGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGameGroupByOutputType[P]>
        }
      >
    >


  export type PlanGameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    gameName?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    duration?: boolean
    uniform?: boolean
    locationId?: boolean
    isScrimmage?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planGame"]>

  export type PlanGameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    gameName?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    duration?: boolean
    uniform?: boolean
    locationId?: boolean
    isScrimmage?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planGame"]>

  export type PlanGameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leagueId?: boolean
    gameName?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    duration?: boolean
    uniform?: boolean
    locationId?: boolean
    isScrimmage?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planGame"]>

  export type PlanGameSelectScalar = {
    id?: boolean
    leagueId?: boolean
    gameName?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    duration?: boolean
    uniform?: boolean
    locationId?: boolean
    isScrimmage?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanGameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leagueId" | "gameName" | "homeTeamId" | "awayTeamId" | "startDatetime" | "endDatetime" | "duration" | "uniform" | "locationId" | "isScrimmage" | "status" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["planGame"]>

  export type $PlanGamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanGame"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      leagueId: Prisma.Decimal | null
      gameName: string | null
      homeTeamId: Prisma.Decimal | null
      awayTeamId: Prisma.Decimal | null
      startDatetime: Date
      endDatetime: Date
      duration: number | null
      uniform: string | null
      locationId: Prisma.Decimal | null
      isScrimmage: number
      status: string
      createdBy: Prisma.Decimal | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["planGame"]>
    composites: {}
  }

  type PlanGameGetPayload<S extends boolean | null | undefined | PlanGameDefaultArgs> = $Result.GetResult<Prisma.$PlanGamePayload, S>

  type PlanGameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanGameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanGameCountAggregateInputType | true
    }

  export interface PlanGameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanGame'], meta: { name: 'PlanGame' } }
    /**
     * Find zero or one PlanGame that matches the filter.
     * @param {PlanGameFindUniqueArgs} args - Arguments to find a PlanGame
     * @example
     * // Get one PlanGame
     * const planGame = await prisma.planGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanGameFindUniqueArgs>(args: SelectSubset<T, PlanGameFindUniqueArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanGame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanGameFindUniqueOrThrowArgs} args - Arguments to find a PlanGame
     * @example
     * // Get one PlanGame
     * const planGame = await prisma.planGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanGameFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanGameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameFindFirstArgs} args - Arguments to find a PlanGame
     * @example
     * // Get one PlanGame
     * const planGame = await prisma.planGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanGameFindFirstArgs>(args?: SelectSubset<T, PlanGameFindFirstArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameFindFirstOrThrowArgs} args - Arguments to find a PlanGame
     * @example
     * // Get one PlanGame
     * const planGame = await prisma.planGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanGameFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanGameFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanGames
     * const planGames = await prisma.planGame.findMany()
     * 
     * // Get first 10 PlanGames
     * const planGames = await prisma.planGame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planGameWithIdOnly = await prisma.planGame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanGameFindManyArgs>(args?: SelectSubset<T, PlanGameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanGame.
     * @param {PlanGameCreateArgs} args - Arguments to create a PlanGame.
     * @example
     * // Create one PlanGame
     * const PlanGame = await prisma.planGame.create({
     *   data: {
     *     // ... data to create a PlanGame
     *   }
     * })
     * 
     */
    create<T extends PlanGameCreateArgs>(args: SelectSubset<T, PlanGameCreateArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanGames.
     * @param {PlanGameCreateManyArgs} args - Arguments to create many PlanGames.
     * @example
     * // Create many PlanGames
     * const planGame = await prisma.planGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanGameCreateManyArgs>(args?: SelectSubset<T, PlanGameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanGames and returns the data saved in the database.
     * @param {PlanGameCreateManyAndReturnArgs} args - Arguments to create many PlanGames.
     * @example
     * // Create many PlanGames
     * const planGame = await prisma.planGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanGames and only return the `id`
     * const planGameWithIdOnly = await prisma.planGame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanGameCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanGameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanGame.
     * @param {PlanGameDeleteArgs} args - Arguments to delete one PlanGame.
     * @example
     * // Delete one PlanGame
     * const PlanGame = await prisma.planGame.delete({
     *   where: {
     *     // ... filter to delete one PlanGame
     *   }
     * })
     * 
     */
    delete<T extends PlanGameDeleteArgs>(args: SelectSubset<T, PlanGameDeleteArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanGame.
     * @param {PlanGameUpdateArgs} args - Arguments to update one PlanGame.
     * @example
     * // Update one PlanGame
     * const planGame = await prisma.planGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanGameUpdateArgs>(args: SelectSubset<T, PlanGameUpdateArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanGames.
     * @param {PlanGameDeleteManyArgs} args - Arguments to filter PlanGames to delete.
     * @example
     * // Delete a few PlanGames
     * const { count } = await prisma.planGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanGameDeleteManyArgs>(args?: SelectSubset<T, PlanGameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanGames
     * const planGame = await prisma.planGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanGameUpdateManyArgs>(args: SelectSubset<T, PlanGameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanGames and returns the data updated in the database.
     * @param {PlanGameUpdateManyAndReturnArgs} args - Arguments to update many PlanGames.
     * @example
     * // Update many PlanGames
     * const planGame = await prisma.planGame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanGames and only return the `id`
     * const planGameWithIdOnly = await prisma.planGame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanGameUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanGameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanGame.
     * @param {PlanGameUpsertArgs} args - Arguments to update or create a PlanGame.
     * @example
     * // Update or create a PlanGame
     * const planGame = await prisma.planGame.upsert({
     *   create: {
     *     // ... data to create a PlanGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanGame we want to update
     *   }
     * })
     */
    upsert<T extends PlanGameUpsertArgs>(args: SelectSubset<T, PlanGameUpsertArgs<ExtArgs>>): Prisma__PlanGameClient<$Result.GetResult<Prisma.$PlanGamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameCountArgs} args - Arguments to filter PlanGames to count.
     * @example
     * // Count the number of PlanGames
     * const count = await prisma.planGame.count({
     *   where: {
     *     // ... the filter for the PlanGames we want to count
     *   }
     * })
    **/
    count<T extends PlanGameCountArgs>(
      args?: Subset<T, PlanGameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanGameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanGameAggregateArgs>(args: Subset<T, PlanGameAggregateArgs>): Prisma.PrismaPromise<GetPlanGameAggregateType<T>>

    /**
     * Group by PlanGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGameGroupByArgs['orderBy'] }
        : { orderBy?: PlanGameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanGame model
   */
  readonly fields: PlanGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanGameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanGame model
   */
  interface PlanGameFieldRefs {
    readonly id: FieldRef<"PlanGame", 'Decimal'>
    readonly leagueId: FieldRef<"PlanGame", 'Decimal'>
    readonly gameName: FieldRef<"PlanGame", 'String'>
    readonly homeTeamId: FieldRef<"PlanGame", 'Decimal'>
    readonly awayTeamId: FieldRef<"PlanGame", 'Decimal'>
    readonly startDatetime: FieldRef<"PlanGame", 'DateTime'>
    readonly endDatetime: FieldRef<"PlanGame", 'DateTime'>
    readonly duration: FieldRef<"PlanGame", 'Int'>
    readonly uniform: FieldRef<"PlanGame", 'String'>
    readonly locationId: FieldRef<"PlanGame", 'Decimal'>
    readonly isScrimmage: FieldRef<"PlanGame", 'Int'>
    readonly status: FieldRef<"PlanGame", 'String'>
    readonly createdBy: FieldRef<"PlanGame", 'Decimal'>
    readonly createdAt: FieldRef<"PlanGame", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanGame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanGame findUnique
   */
  export type PlanGameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * Filter, which PlanGame to fetch.
     */
    where: PlanGameWhereUniqueInput
  }

  /**
   * PlanGame findUniqueOrThrow
   */
  export type PlanGameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * Filter, which PlanGame to fetch.
     */
    where: PlanGameWhereUniqueInput
  }

  /**
   * PlanGame findFirst
   */
  export type PlanGameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * Filter, which PlanGame to fetch.
     */
    where?: PlanGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanGames to fetch.
     */
    orderBy?: PlanGameOrderByWithRelationInput | PlanGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanGames.
     */
    cursor?: PlanGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanGames.
     */
    distinct?: PlanGameScalarFieldEnum | PlanGameScalarFieldEnum[]
  }

  /**
   * PlanGame findFirstOrThrow
   */
  export type PlanGameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * Filter, which PlanGame to fetch.
     */
    where?: PlanGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanGames to fetch.
     */
    orderBy?: PlanGameOrderByWithRelationInput | PlanGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanGames.
     */
    cursor?: PlanGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanGames.
     */
    distinct?: PlanGameScalarFieldEnum | PlanGameScalarFieldEnum[]
  }

  /**
   * PlanGame findMany
   */
  export type PlanGameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * Filter, which PlanGames to fetch.
     */
    where?: PlanGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanGames to fetch.
     */
    orderBy?: PlanGameOrderByWithRelationInput | PlanGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanGames.
     */
    cursor?: PlanGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanGames.
     */
    skip?: number
    distinct?: PlanGameScalarFieldEnum | PlanGameScalarFieldEnum[]
  }

  /**
   * PlanGame create
   */
  export type PlanGameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * The data needed to create a PlanGame.
     */
    data: XOR<PlanGameCreateInput, PlanGameUncheckedCreateInput>
  }

  /**
   * PlanGame createMany
   */
  export type PlanGameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanGames.
     */
    data: PlanGameCreateManyInput | PlanGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanGame createManyAndReturn
   */
  export type PlanGameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * The data used to create many PlanGames.
     */
    data: PlanGameCreateManyInput | PlanGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanGame update
   */
  export type PlanGameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * The data needed to update a PlanGame.
     */
    data: XOR<PlanGameUpdateInput, PlanGameUncheckedUpdateInput>
    /**
     * Choose, which PlanGame to update.
     */
    where: PlanGameWhereUniqueInput
  }

  /**
   * PlanGame updateMany
   */
  export type PlanGameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanGames.
     */
    data: XOR<PlanGameUpdateManyMutationInput, PlanGameUncheckedUpdateManyInput>
    /**
     * Filter which PlanGames to update
     */
    where?: PlanGameWhereInput
    /**
     * Limit how many PlanGames to update.
     */
    limit?: number
  }

  /**
   * PlanGame updateManyAndReturn
   */
  export type PlanGameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * The data used to update PlanGames.
     */
    data: XOR<PlanGameUpdateManyMutationInput, PlanGameUncheckedUpdateManyInput>
    /**
     * Filter which PlanGames to update
     */
    where?: PlanGameWhereInput
    /**
     * Limit how many PlanGames to update.
     */
    limit?: number
  }

  /**
   * PlanGame upsert
   */
  export type PlanGameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * The filter to search for the PlanGame to update in case it exists.
     */
    where: PlanGameWhereUniqueInput
    /**
     * In case the PlanGame found by the `where` argument doesn't exist, create a new PlanGame with this data.
     */
    create: XOR<PlanGameCreateInput, PlanGameUncheckedCreateInput>
    /**
     * In case the PlanGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanGameUpdateInput, PlanGameUncheckedUpdateInput>
  }

  /**
   * PlanGame delete
   */
  export type PlanGameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
    /**
     * Filter which PlanGame to delete.
     */
    where: PlanGameWhereUniqueInput
  }

  /**
   * PlanGame deleteMany
   */
  export type PlanGameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanGames to delete
     */
    where?: PlanGameWhereInput
    /**
     * Limit how many PlanGames to delete.
     */
    limit?: number
  }

  /**
   * PlanGame without action
   */
  export type PlanGameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanGame
     */
    select?: PlanGameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanGame
     */
    omit?: PlanGameOmit<ExtArgs> | null
  }


  /**
   * Model PlanMeeting
   */

  export type AggregatePlanMeeting = {
    _count: PlanMeetingCountAggregateOutputType | null
    _avg: PlanMeetingAvgAggregateOutputType | null
    _sum: PlanMeetingSumAggregateOutputType | null
    _min: PlanMeetingMinAggregateOutputType | null
    _max: PlanMeetingMaxAggregateOutputType | null
  }

  export type PlanMeetingAvgAggregateOutputType = {
    id: Decimal | null
    meetingCategory: number | null
    teamId: Decimal | null
    locationId: Decimal | null
    status: number | null
    createdBy: Decimal | null
  }

  export type PlanMeetingSumAggregateOutputType = {
    id: Decimal | null
    meetingCategory: number | null
    teamId: Decimal | null
    locationId: Decimal | null
    status: number | null
    createdBy: Decimal | null
  }

  export type PlanMeetingMinAggregateOutputType = {
    id: Decimal | null
    meetingCategory: number | null
    teamId: Decimal | null
    startDatetime: Date | null
    endDatetime: Date | null
    title: string | null
    content: string | null
    locationId: Decimal | null
    status: number | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMeetingMaxAggregateOutputType = {
    id: Decimal | null
    meetingCategory: number | null
    teamId: Decimal | null
    startDatetime: Date | null
    endDatetime: Date | null
    title: string | null
    content: string | null
    locationId: Decimal | null
    status: number | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMeetingCountAggregateOutputType = {
    id: number
    meetingCategory: number
    teamId: number
    startDatetime: number
    endDatetime: number
    title: number
    content: number
    locationId: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanMeetingAvgAggregateInputType = {
    id?: true
    meetingCategory?: true
    teamId?: true
    locationId?: true
    status?: true
    createdBy?: true
  }

  export type PlanMeetingSumAggregateInputType = {
    id?: true
    meetingCategory?: true
    teamId?: true
    locationId?: true
    status?: true
    createdBy?: true
  }

  export type PlanMeetingMinAggregateInputType = {
    id?: true
    meetingCategory?: true
    teamId?: true
    startDatetime?: true
    endDatetime?: true
    title?: true
    content?: true
    locationId?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMeetingMaxAggregateInputType = {
    id?: true
    meetingCategory?: true
    teamId?: true
    startDatetime?: true
    endDatetime?: true
    title?: true
    content?: true
    locationId?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMeetingCountAggregateInputType = {
    id?: true
    meetingCategory?: true
    teamId?: true
    startDatetime?: true
    endDatetime?: true
    title?: true
    content?: true
    locationId?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanMeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanMeeting to aggregate.
     */
    where?: PlanMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMeetings to fetch.
     */
    orderBy?: PlanMeetingOrderByWithRelationInput | PlanMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanMeetings
    **/
    _count?: true | PlanMeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanMeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanMeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMeetingMaxAggregateInputType
  }

  export type GetPlanMeetingAggregateType<T extends PlanMeetingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanMeeting[P]>
      : GetScalarType<T[P], AggregatePlanMeeting[P]>
  }




  export type PlanMeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanMeetingWhereInput
    orderBy?: PlanMeetingOrderByWithAggregationInput | PlanMeetingOrderByWithAggregationInput[]
    by: PlanMeetingScalarFieldEnum[] | PlanMeetingScalarFieldEnum
    having?: PlanMeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanMeetingCountAggregateInputType | true
    _avg?: PlanMeetingAvgAggregateInputType
    _sum?: PlanMeetingSumAggregateInputType
    _min?: PlanMeetingMinAggregateInputType
    _max?: PlanMeetingMaxAggregateInputType
  }

  export type PlanMeetingGroupByOutputType = {
    id: Decimal
    meetingCategory: number | null
    teamId: Decimal | null
    startDatetime: Date
    endDatetime: Date
    title: string | null
    content: string | null
    locationId: Decimal | null
    status: number | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: PlanMeetingCountAggregateOutputType | null
    _avg: PlanMeetingAvgAggregateOutputType | null
    _sum: PlanMeetingSumAggregateOutputType | null
    _min: PlanMeetingMinAggregateOutputType | null
    _max: PlanMeetingMaxAggregateOutputType | null
  }

  type GetPlanMeetingGroupByPayload<T extends PlanMeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanMeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanMeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanMeetingGroupByOutputType[P]>
            : GetScalarType<T[P], PlanMeetingGroupByOutputType[P]>
        }
      >
    >


  export type PlanMeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingCategory?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    title?: boolean
    content?: boolean
    locationId?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planMeeting"]>

  export type PlanMeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingCategory?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    title?: boolean
    content?: boolean
    locationId?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planMeeting"]>

  export type PlanMeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingCategory?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    title?: boolean
    content?: boolean
    locationId?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planMeeting"]>

  export type PlanMeetingSelectScalar = {
    id?: boolean
    meetingCategory?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    title?: boolean
    content?: boolean
    locationId?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanMeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meetingCategory" | "teamId" | "startDatetime" | "endDatetime" | "title" | "content" | "locationId" | "status" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["planMeeting"]>

  export type $PlanMeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanMeeting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      meetingCategory: number | null
      teamId: Prisma.Decimal | null
      startDatetime: Date
      endDatetime: Date
      title: string | null
      content: string | null
      locationId: Prisma.Decimal | null
      status: number | null
      createdBy: Prisma.Decimal | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["planMeeting"]>
    composites: {}
  }

  type PlanMeetingGetPayload<S extends boolean | null | undefined | PlanMeetingDefaultArgs> = $Result.GetResult<Prisma.$PlanMeetingPayload, S>

  type PlanMeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanMeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanMeetingCountAggregateInputType | true
    }

  export interface PlanMeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanMeeting'], meta: { name: 'PlanMeeting' } }
    /**
     * Find zero or one PlanMeeting that matches the filter.
     * @param {PlanMeetingFindUniqueArgs} args - Arguments to find a PlanMeeting
     * @example
     * // Get one PlanMeeting
     * const planMeeting = await prisma.planMeeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanMeetingFindUniqueArgs>(args: SelectSubset<T, PlanMeetingFindUniqueArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanMeeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanMeetingFindUniqueOrThrowArgs} args - Arguments to find a PlanMeeting
     * @example
     * // Get one PlanMeeting
     * const planMeeting = await prisma.planMeeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanMeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanMeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanMeeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingFindFirstArgs} args - Arguments to find a PlanMeeting
     * @example
     * // Get one PlanMeeting
     * const planMeeting = await prisma.planMeeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanMeetingFindFirstArgs>(args?: SelectSubset<T, PlanMeetingFindFirstArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanMeeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingFindFirstOrThrowArgs} args - Arguments to find a PlanMeeting
     * @example
     * // Get one PlanMeeting
     * const planMeeting = await prisma.planMeeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanMeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanMeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanMeetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanMeetings
     * const planMeetings = await prisma.planMeeting.findMany()
     * 
     * // Get first 10 PlanMeetings
     * const planMeetings = await prisma.planMeeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planMeetingWithIdOnly = await prisma.planMeeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanMeetingFindManyArgs>(args?: SelectSubset<T, PlanMeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanMeeting.
     * @param {PlanMeetingCreateArgs} args - Arguments to create a PlanMeeting.
     * @example
     * // Create one PlanMeeting
     * const PlanMeeting = await prisma.planMeeting.create({
     *   data: {
     *     // ... data to create a PlanMeeting
     *   }
     * })
     * 
     */
    create<T extends PlanMeetingCreateArgs>(args: SelectSubset<T, PlanMeetingCreateArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanMeetings.
     * @param {PlanMeetingCreateManyArgs} args - Arguments to create many PlanMeetings.
     * @example
     * // Create many PlanMeetings
     * const planMeeting = await prisma.planMeeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanMeetingCreateManyArgs>(args?: SelectSubset<T, PlanMeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanMeetings and returns the data saved in the database.
     * @param {PlanMeetingCreateManyAndReturnArgs} args - Arguments to create many PlanMeetings.
     * @example
     * // Create many PlanMeetings
     * const planMeeting = await prisma.planMeeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanMeetings and only return the `id`
     * const planMeetingWithIdOnly = await prisma.planMeeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanMeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanMeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanMeeting.
     * @param {PlanMeetingDeleteArgs} args - Arguments to delete one PlanMeeting.
     * @example
     * // Delete one PlanMeeting
     * const PlanMeeting = await prisma.planMeeting.delete({
     *   where: {
     *     // ... filter to delete one PlanMeeting
     *   }
     * })
     * 
     */
    delete<T extends PlanMeetingDeleteArgs>(args: SelectSubset<T, PlanMeetingDeleteArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanMeeting.
     * @param {PlanMeetingUpdateArgs} args - Arguments to update one PlanMeeting.
     * @example
     * // Update one PlanMeeting
     * const planMeeting = await prisma.planMeeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanMeetingUpdateArgs>(args: SelectSubset<T, PlanMeetingUpdateArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanMeetings.
     * @param {PlanMeetingDeleteManyArgs} args - Arguments to filter PlanMeetings to delete.
     * @example
     * // Delete a few PlanMeetings
     * const { count } = await prisma.planMeeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanMeetingDeleteManyArgs>(args?: SelectSubset<T, PlanMeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanMeetings
     * const planMeeting = await prisma.planMeeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanMeetingUpdateManyArgs>(args: SelectSubset<T, PlanMeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanMeetings and returns the data updated in the database.
     * @param {PlanMeetingUpdateManyAndReturnArgs} args - Arguments to update many PlanMeetings.
     * @example
     * // Update many PlanMeetings
     * const planMeeting = await prisma.planMeeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanMeetings and only return the `id`
     * const planMeetingWithIdOnly = await prisma.planMeeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanMeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanMeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanMeeting.
     * @param {PlanMeetingUpsertArgs} args - Arguments to update or create a PlanMeeting.
     * @example
     * // Update or create a PlanMeeting
     * const planMeeting = await prisma.planMeeting.upsert({
     *   create: {
     *     // ... data to create a PlanMeeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanMeeting we want to update
     *   }
     * })
     */
    upsert<T extends PlanMeetingUpsertArgs>(args: SelectSubset<T, PlanMeetingUpsertArgs<ExtArgs>>): Prisma__PlanMeetingClient<$Result.GetResult<Prisma.$PlanMeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingCountArgs} args - Arguments to filter PlanMeetings to count.
     * @example
     * // Count the number of PlanMeetings
     * const count = await prisma.planMeeting.count({
     *   where: {
     *     // ... the filter for the PlanMeetings we want to count
     *   }
     * })
    **/
    count<T extends PlanMeetingCountArgs>(
      args?: Subset<T, PlanMeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanMeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanMeetingAggregateArgs>(args: Subset<T, PlanMeetingAggregateArgs>): Prisma.PrismaPromise<GetPlanMeetingAggregateType<T>>

    /**
     * Group by PlanMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanMeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanMeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanMeetingGroupByArgs['orderBy'] }
        : { orderBy?: PlanMeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanMeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanMeeting model
   */
  readonly fields: PlanMeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanMeeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanMeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanMeeting model
   */
  interface PlanMeetingFieldRefs {
    readonly id: FieldRef<"PlanMeeting", 'Decimal'>
    readonly meetingCategory: FieldRef<"PlanMeeting", 'Int'>
    readonly teamId: FieldRef<"PlanMeeting", 'Decimal'>
    readonly startDatetime: FieldRef<"PlanMeeting", 'DateTime'>
    readonly endDatetime: FieldRef<"PlanMeeting", 'DateTime'>
    readonly title: FieldRef<"PlanMeeting", 'String'>
    readonly content: FieldRef<"PlanMeeting", 'String'>
    readonly locationId: FieldRef<"PlanMeeting", 'Decimal'>
    readonly status: FieldRef<"PlanMeeting", 'Int'>
    readonly createdBy: FieldRef<"PlanMeeting", 'Decimal'>
    readonly createdAt: FieldRef<"PlanMeeting", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanMeeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanMeeting findUnique
   */
  export type PlanMeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * Filter, which PlanMeeting to fetch.
     */
    where: PlanMeetingWhereUniqueInput
  }

  /**
   * PlanMeeting findUniqueOrThrow
   */
  export type PlanMeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * Filter, which PlanMeeting to fetch.
     */
    where: PlanMeetingWhereUniqueInput
  }

  /**
   * PlanMeeting findFirst
   */
  export type PlanMeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * Filter, which PlanMeeting to fetch.
     */
    where?: PlanMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMeetings to fetch.
     */
    orderBy?: PlanMeetingOrderByWithRelationInput | PlanMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanMeetings.
     */
    cursor?: PlanMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanMeetings.
     */
    distinct?: PlanMeetingScalarFieldEnum | PlanMeetingScalarFieldEnum[]
  }

  /**
   * PlanMeeting findFirstOrThrow
   */
  export type PlanMeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * Filter, which PlanMeeting to fetch.
     */
    where?: PlanMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMeetings to fetch.
     */
    orderBy?: PlanMeetingOrderByWithRelationInput | PlanMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanMeetings.
     */
    cursor?: PlanMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanMeetings.
     */
    distinct?: PlanMeetingScalarFieldEnum | PlanMeetingScalarFieldEnum[]
  }

  /**
   * PlanMeeting findMany
   */
  export type PlanMeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * Filter, which PlanMeetings to fetch.
     */
    where?: PlanMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanMeetings to fetch.
     */
    orderBy?: PlanMeetingOrderByWithRelationInput | PlanMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanMeetings.
     */
    cursor?: PlanMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanMeetings.
     */
    skip?: number
    distinct?: PlanMeetingScalarFieldEnum | PlanMeetingScalarFieldEnum[]
  }

  /**
   * PlanMeeting create
   */
  export type PlanMeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * The data needed to create a PlanMeeting.
     */
    data: XOR<PlanMeetingCreateInput, PlanMeetingUncheckedCreateInput>
  }

  /**
   * PlanMeeting createMany
   */
  export type PlanMeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanMeetings.
     */
    data: PlanMeetingCreateManyInput | PlanMeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanMeeting createManyAndReturn
   */
  export type PlanMeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * The data used to create many PlanMeetings.
     */
    data: PlanMeetingCreateManyInput | PlanMeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanMeeting update
   */
  export type PlanMeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * The data needed to update a PlanMeeting.
     */
    data: XOR<PlanMeetingUpdateInput, PlanMeetingUncheckedUpdateInput>
    /**
     * Choose, which PlanMeeting to update.
     */
    where: PlanMeetingWhereUniqueInput
  }

  /**
   * PlanMeeting updateMany
   */
  export type PlanMeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanMeetings.
     */
    data: XOR<PlanMeetingUpdateManyMutationInput, PlanMeetingUncheckedUpdateManyInput>
    /**
     * Filter which PlanMeetings to update
     */
    where?: PlanMeetingWhereInput
    /**
     * Limit how many PlanMeetings to update.
     */
    limit?: number
  }

  /**
   * PlanMeeting updateManyAndReturn
   */
  export type PlanMeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * The data used to update PlanMeetings.
     */
    data: XOR<PlanMeetingUpdateManyMutationInput, PlanMeetingUncheckedUpdateManyInput>
    /**
     * Filter which PlanMeetings to update
     */
    where?: PlanMeetingWhereInput
    /**
     * Limit how many PlanMeetings to update.
     */
    limit?: number
  }

  /**
   * PlanMeeting upsert
   */
  export type PlanMeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * The filter to search for the PlanMeeting to update in case it exists.
     */
    where: PlanMeetingWhereUniqueInput
    /**
     * In case the PlanMeeting found by the `where` argument doesn't exist, create a new PlanMeeting with this data.
     */
    create: XOR<PlanMeetingCreateInput, PlanMeetingUncheckedCreateInput>
    /**
     * In case the PlanMeeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanMeetingUpdateInput, PlanMeetingUncheckedUpdateInput>
  }

  /**
   * PlanMeeting delete
   */
  export type PlanMeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
    /**
     * Filter which PlanMeeting to delete.
     */
    where: PlanMeetingWhereUniqueInput
  }

  /**
   * PlanMeeting deleteMany
   */
  export type PlanMeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanMeetings to delete
     */
    where?: PlanMeetingWhereInput
    /**
     * Limit how many PlanMeetings to delete.
     */
    limit?: number
  }

  /**
   * PlanMeeting without action
   */
  export type PlanMeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanMeeting
     */
    select?: PlanMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanMeeting
     */
    omit?: PlanMeetingOmit<ExtArgs> | null
  }


  /**
   * Model PlanTraining
   */

  export type AggregatePlanTraining = {
    _count: PlanTrainingCountAggregateOutputType | null
    _avg: PlanTrainingAvgAggregateOutputType | null
    _sum: PlanTrainingSumAggregateOutputType | null
    _min: PlanTrainingMinAggregateOutputType | null
    _max: PlanTrainingMaxAggregateOutputType | null
  }

  export type PlanTrainingAvgAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    isAllMembers: number | null
    locationId: Decimal | null
    recurringType: number | null
    createdBy: Decimal | null
  }

  export type PlanTrainingSumAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    isAllMembers: number | null
    locationId: Decimal | null
    recurringType: number | null
    createdBy: Decimal | null
  }

  export type PlanTrainingMinAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    startDatetime: Date | null
    endDatetime: Date | null
    trainingContent: string | null
    isAllMembers: number | null
    locationId: Decimal | null
    recurringType: number | null
    status: string | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanTrainingMaxAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    startDatetime: Date | null
    endDatetime: Date | null
    trainingContent: string | null
    isAllMembers: number | null
    locationId: Decimal | null
    recurringType: number | null
    status: string | null
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanTrainingCountAggregateOutputType = {
    id: number
    teamId: number
    startDatetime: number
    endDatetime: number
    trainingContent: number
    isAllMembers: number
    locationId: number
    recurringType: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanTrainingAvgAggregateInputType = {
    id?: true
    teamId?: true
    isAllMembers?: true
    locationId?: true
    recurringType?: true
    createdBy?: true
  }

  export type PlanTrainingSumAggregateInputType = {
    id?: true
    teamId?: true
    isAllMembers?: true
    locationId?: true
    recurringType?: true
    createdBy?: true
  }

  export type PlanTrainingMinAggregateInputType = {
    id?: true
    teamId?: true
    startDatetime?: true
    endDatetime?: true
    trainingContent?: true
    isAllMembers?: true
    locationId?: true
    recurringType?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanTrainingMaxAggregateInputType = {
    id?: true
    teamId?: true
    startDatetime?: true
    endDatetime?: true
    trainingContent?: true
    isAllMembers?: true
    locationId?: true
    recurringType?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanTrainingCountAggregateInputType = {
    id?: true
    teamId?: true
    startDatetime?: true
    endDatetime?: true
    trainingContent?: true
    isAllMembers?: true
    locationId?: true
    recurringType?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanTrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanTraining to aggregate.
     */
    where?: PlanTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTrainings to fetch.
     */
    orderBy?: PlanTrainingOrderByWithRelationInput | PlanTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanTrainings
    **/
    _count?: true | PlanTrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanTrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanTrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanTrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanTrainingMaxAggregateInputType
  }

  export type GetPlanTrainingAggregateType<T extends PlanTrainingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanTraining[P]>
      : GetScalarType<T[P], AggregatePlanTraining[P]>
  }




  export type PlanTrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanTrainingWhereInput
    orderBy?: PlanTrainingOrderByWithAggregationInput | PlanTrainingOrderByWithAggregationInput[]
    by: PlanTrainingScalarFieldEnum[] | PlanTrainingScalarFieldEnum
    having?: PlanTrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanTrainingCountAggregateInputType | true
    _avg?: PlanTrainingAvgAggregateInputType
    _sum?: PlanTrainingSumAggregateInputType
    _min?: PlanTrainingMinAggregateInputType
    _max?: PlanTrainingMaxAggregateInputType
  }

  export type PlanTrainingGroupByOutputType = {
    id: Decimal
    teamId: Decimal | null
    startDatetime: Date
    endDatetime: Date
    trainingContent: string | null
    isAllMembers: number
    locationId: Decimal | null
    recurringType: number
    status: string
    createdBy: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: PlanTrainingCountAggregateOutputType | null
    _avg: PlanTrainingAvgAggregateOutputType | null
    _sum: PlanTrainingSumAggregateOutputType | null
    _min: PlanTrainingMinAggregateOutputType | null
    _max: PlanTrainingMaxAggregateOutputType | null
  }

  type GetPlanTrainingGroupByPayload<T extends PlanTrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanTrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanTrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanTrainingGroupByOutputType[P]>
            : GetScalarType<T[P], PlanTrainingGroupByOutputType[P]>
        }
      >
    >


  export type PlanTrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    trainingContent?: boolean
    isAllMembers?: boolean
    locationId?: boolean
    recurringType?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planTraining"]>

  export type PlanTrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    trainingContent?: boolean
    isAllMembers?: boolean
    locationId?: boolean
    recurringType?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planTraining"]>

  export type PlanTrainingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    trainingContent?: boolean
    isAllMembers?: boolean
    locationId?: boolean
    recurringType?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["planTraining"]>

  export type PlanTrainingSelectScalar = {
    id?: boolean
    teamId?: boolean
    startDatetime?: boolean
    endDatetime?: boolean
    trainingContent?: boolean
    isAllMembers?: boolean
    locationId?: boolean
    recurringType?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanTrainingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "startDatetime" | "endDatetime" | "trainingContent" | "isAllMembers" | "locationId" | "recurringType" | "status" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["planTraining"]>

  export type $PlanTrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanTraining"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      teamId: Prisma.Decimal | null
      startDatetime: Date
      endDatetime: Date
      trainingContent: string | null
      isAllMembers: number
      locationId: Prisma.Decimal | null
      recurringType: number
      status: string
      createdBy: Prisma.Decimal | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["planTraining"]>
    composites: {}
  }

  type PlanTrainingGetPayload<S extends boolean | null | undefined | PlanTrainingDefaultArgs> = $Result.GetResult<Prisma.$PlanTrainingPayload, S>

  type PlanTrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanTrainingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanTrainingCountAggregateInputType | true
    }

  export interface PlanTrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanTraining'], meta: { name: 'PlanTraining' } }
    /**
     * Find zero or one PlanTraining that matches the filter.
     * @param {PlanTrainingFindUniqueArgs} args - Arguments to find a PlanTraining
     * @example
     * // Get one PlanTraining
     * const planTraining = await prisma.planTraining.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanTrainingFindUniqueArgs>(args: SelectSubset<T, PlanTrainingFindUniqueArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanTraining that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanTrainingFindUniqueOrThrowArgs} args - Arguments to find a PlanTraining
     * @example
     * // Get one PlanTraining
     * const planTraining = await prisma.planTraining.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanTrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanTrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanTraining that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingFindFirstArgs} args - Arguments to find a PlanTraining
     * @example
     * // Get one PlanTraining
     * const planTraining = await prisma.planTraining.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanTrainingFindFirstArgs>(args?: SelectSubset<T, PlanTrainingFindFirstArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanTraining that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingFindFirstOrThrowArgs} args - Arguments to find a PlanTraining
     * @example
     * // Get one PlanTraining
     * const planTraining = await prisma.planTraining.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanTrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanTrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanTrainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanTrainings
     * const planTrainings = await prisma.planTraining.findMany()
     * 
     * // Get first 10 PlanTrainings
     * const planTrainings = await prisma.planTraining.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planTrainingWithIdOnly = await prisma.planTraining.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanTrainingFindManyArgs>(args?: SelectSubset<T, PlanTrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanTraining.
     * @param {PlanTrainingCreateArgs} args - Arguments to create a PlanTraining.
     * @example
     * // Create one PlanTraining
     * const PlanTraining = await prisma.planTraining.create({
     *   data: {
     *     // ... data to create a PlanTraining
     *   }
     * })
     * 
     */
    create<T extends PlanTrainingCreateArgs>(args: SelectSubset<T, PlanTrainingCreateArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanTrainings.
     * @param {PlanTrainingCreateManyArgs} args - Arguments to create many PlanTrainings.
     * @example
     * // Create many PlanTrainings
     * const planTraining = await prisma.planTraining.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanTrainingCreateManyArgs>(args?: SelectSubset<T, PlanTrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanTrainings and returns the data saved in the database.
     * @param {PlanTrainingCreateManyAndReturnArgs} args - Arguments to create many PlanTrainings.
     * @example
     * // Create many PlanTrainings
     * const planTraining = await prisma.planTraining.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanTrainings and only return the `id`
     * const planTrainingWithIdOnly = await prisma.planTraining.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanTrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanTrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanTraining.
     * @param {PlanTrainingDeleteArgs} args - Arguments to delete one PlanTraining.
     * @example
     * // Delete one PlanTraining
     * const PlanTraining = await prisma.planTraining.delete({
     *   where: {
     *     // ... filter to delete one PlanTraining
     *   }
     * })
     * 
     */
    delete<T extends PlanTrainingDeleteArgs>(args: SelectSubset<T, PlanTrainingDeleteArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanTraining.
     * @param {PlanTrainingUpdateArgs} args - Arguments to update one PlanTraining.
     * @example
     * // Update one PlanTraining
     * const planTraining = await prisma.planTraining.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanTrainingUpdateArgs>(args: SelectSubset<T, PlanTrainingUpdateArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanTrainings.
     * @param {PlanTrainingDeleteManyArgs} args - Arguments to filter PlanTrainings to delete.
     * @example
     * // Delete a few PlanTrainings
     * const { count } = await prisma.planTraining.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanTrainingDeleteManyArgs>(args?: SelectSubset<T, PlanTrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanTrainings
     * const planTraining = await prisma.planTraining.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanTrainingUpdateManyArgs>(args: SelectSubset<T, PlanTrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanTrainings and returns the data updated in the database.
     * @param {PlanTrainingUpdateManyAndReturnArgs} args - Arguments to update many PlanTrainings.
     * @example
     * // Update many PlanTrainings
     * const planTraining = await prisma.planTraining.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanTrainings and only return the `id`
     * const planTrainingWithIdOnly = await prisma.planTraining.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanTrainingUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanTrainingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanTraining.
     * @param {PlanTrainingUpsertArgs} args - Arguments to update or create a PlanTraining.
     * @example
     * // Update or create a PlanTraining
     * const planTraining = await prisma.planTraining.upsert({
     *   create: {
     *     // ... data to create a PlanTraining
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanTraining we want to update
     *   }
     * })
     */
    upsert<T extends PlanTrainingUpsertArgs>(args: SelectSubset<T, PlanTrainingUpsertArgs<ExtArgs>>): Prisma__PlanTrainingClient<$Result.GetResult<Prisma.$PlanTrainingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingCountArgs} args - Arguments to filter PlanTrainings to count.
     * @example
     * // Count the number of PlanTrainings
     * const count = await prisma.planTraining.count({
     *   where: {
     *     // ... the filter for the PlanTrainings we want to count
     *   }
     * })
    **/
    count<T extends PlanTrainingCountArgs>(
      args?: Subset<T, PlanTrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanTrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanTrainingAggregateArgs>(args: Subset<T, PlanTrainingAggregateArgs>): Prisma.PrismaPromise<GetPlanTrainingAggregateType<T>>

    /**
     * Group by PlanTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanTrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanTrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanTrainingGroupByArgs['orderBy'] }
        : { orderBy?: PlanTrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanTrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanTraining model
   */
  readonly fields: PlanTrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanTraining.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanTrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanTraining model
   */
  interface PlanTrainingFieldRefs {
    readonly id: FieldRef<"PlanTraining", 'Decimal'>
    readonly teamId: FieldRef<"PlanTraining", 'Decimal'>
    readonly startDatetime: FieldRef<"PlanTraining", 'DateTime'>
    readonly endDatetime: FieldRef<"PlanTraining", 'DateTime'>
    readonly trainingContent: FieldRef<"PlanTraining", 'String'>
    readonly isAllMembers: FieldRef<"PlanTraining", 'Int'>
    readonly locationId: FieldRef<"PlanTraining", 'Decimal'>
    readonly recurringType: FieldRef<"PlanTraining", 'Int'>
    readonly status: FieldRef<"PlanTraining", 'String'>
    readonly createdBy: FieldRef<"PlanTraining", 'Decimal'>
    readonly createdAt: FieldRef<"PlanTraining", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanTraining", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanTraining findUnique
   */
  export type PlanTrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * Filter, which PlanTraining to fetch.
     */
    where: PlanTrainingWhereUniqueInput
  }

  /**
   * PlanTraining findUniqueOrThrow
   */
  export type PlanTrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * Filter, which PlanTraining to fetch.
     */
    where: PlanTrainingWhereUniqueInput
  }

  /**
   * PlanTraining findFirst
   */
  export type PlanTrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * Filter, which PlanTraining to fetch.
     */
    where?: PlanTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTrainings to fetch.
     */
    orderBy?: PlanTrainingOrderByWithRelationInput | PlanTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanTrainings.
     */
    cursor?: PlanTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanTrainings.
     */
    distinct?: PlanTrainingScalarFieldEnum | PlanTrainingScalarFieldEnum[]
  }

  /**
   * PlanTraining findFirstOrThrow
   */
  export type PlanTrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * Filter, which PlanTraining to fetch.
     */
    where?: PlanTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTrainings to fetch.
     */
    orderBy?: PlanTrainingOrderByWithRelationInput | PlanTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanTrainings.
     */
    cursor?: PlanTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanTrainings.
     */
    distinct?: PlanTrainingScalarFieldEnum | PlanTrainingScalarFieldEnum[]
  }

  /**
   * PlanTraining findMany
   */
  export type PlanTrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * Filter, which PlanTrainings to fetch.
     */
    where?: PlanTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanTrainings to fetch.
     */
    orderBy?: PlanTrainingOrderByWithRelationInput | PlanTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanTrainings.
     */
    cursor?: PlanTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanTrainings.
     */
    skip?: number
    distinct?: PlanTrainingScalarFieldEnum | PlanTrainingScalarFieldEnum[]
  }

  /**
   * PlanTraining create
   */
  export type PlanTrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * The data needed to create a PlanTraining.
     */
    data: XOR<PlanTrainingCreateInput, PlanTrainingUncheckedCreateInput>
  }

  /**
   * PlanTraining createMany
   */
  export type PlanTrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanTrainings.
     */
    data: PlanTrainingCreateManyInput | PlanTrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanTraining createManyAndReturn
   */
  export type PlanTrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * The data used to create many PlanTrainings.
     */
    data: PlanTrainingCreateManyInput | PlanTrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanTraining update
   */
  export type PlanTrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * The data needed to update a PlanTraining.
     */
    data: XOR<PlanTrainingUpdateInput, PlanTrainingUncheckedUpdateInput>
    /**
     * Choose, which PlanTraining to update.
     */
    where: PlanTrainingWhereUniqueInput
  }

  /**
   * PlanTraining updateMany
   */
  export type PlanTrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanTrainings.
     */
    data: XOR<PlanTrainingUpdateManyMutationInput, PlanTrainingUncheckedUpdateManyInput>
    /**
     * Filter which PlanTrainings to update
     */
    where?: PlanTrainingWhereInput
    /**
     * Limit how many PlanTrainings to update.
     */
    limit?: number
  }

  /**
   * PlanTraining updateManyAndReturn
   */
  export type PlanTrainingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * The data used to update PlanTrainings.
     */
    data: XOR<PlanTrainingUpdateManyMutationInput, PlanTrainingUncheckedUpdateManyInput>
    /**
     * Filter which PlanTrainings to update
     */
    where?: PlanTrainingWhereInput
    /**
     * Limit how many PlanTrainings to update.
     */
    limit?: number
  }

  /**
   * PlanTraining upsert
   */
  export type PlanTrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * The filter to search for the PlanTraining to update in case it exists.
     */
    where: PlanTrainingWhereUniqueInput
    /**
     * In case the PlanTraining found by the `where` argument doesn't exist, create a new PlanTraining with this data.
     */
    create: XOR<PlanTrainingCreateInput, PlanTrainingUncheckedCreateInput>
    /**
     * In case the PlanTraining was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanTrainingUpdateInput, PlanTrainingUncheckedUpdateInput>
  }

  /**
   * PlanTraining delete
   */
  export type PlanTrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
    /**
     * Filter which PlanTraining to delete.
     */
    where: PlanTrainingWhereUniqueInput
  }

  /**
   * PlanTraining deleteMany
   */
  export type PlanTrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanTrainings to delete
     */
    where?: PlanTrainingWhereInput
    /**
     * Limit how many PlanTrainings to delete.
     */
    limit?: number
  }

  /**
   * PlanTraining without action
   */
  export type PlanTrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanTraining
     */
    select?: PlanTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanTraining
     */
    omit?: PlanTrainingOmit<ExtArgs> | null
  }


  /**
   * Model RelClubClubAdmin
   */

  export type AggregateRelClubClubAdmin = {
    _count: RelClubClubAdminCountAggregateOutputType | null
    _avg: RelClubClubAdminAvgAggregateOutputType | null
    _sum: RelClubClubAdminSumAggregateOutputType | null
    _min: RelClubClubAdminMinAggregateOutputType | null
    _max: RelClubClubAdminMaxAggregateOutputType | null
  }

  export type RelClubClubAdminAvgAggregateOutputType = {
    id: Decimal | null
    clubId: Decimal | null
    adminId: Decimal | null
    salary: Decimal | null
    ord: number | null
  }

  export type RelClubClubAdminSumAggregateOutputType = {
    id: Decimal | null
    clubId: Decimal | null
    adminId: Decimal | null
    salary: Decimal | null
    ord: number | null
  }

  export type RelClubClubAdminMinAggregateOutputType = {
    id: Decimal | null
    clubId: Decimal | null
    adminId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    role: string | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelClubClubAdminMaxAggregateOutputType = {
    id: Decimal | null
    clubId: Decimal | null
    adminId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    role: string | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelClubClubAdminCountAggregateOutputType = {
    id: number
    clubId: number
    adminId: number
    joinedAt: number
    leftAt: number
    status: number
    role: number
    salary: number
    contractStart: number
    contractEnd: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelClubClubAdminAvgAggregateInputType = {
    id?: true
    clubId?: true
    adminId?: true
    salary?: true
    ord?: true
  }

  export type RelClubClubAdminSumAggregateInputType = {
    id?: true
    clubId?: true
    adminId?: true
    salary?: true
    ord?: true
  }

  export type RelClubClubAdminMinAggregateInputType = {
    id?: true
    clubId?: true
    adminId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    role?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelClubClubAdminMaxAggregateInputType = {
    id?: true
    clubId?: true
    adminId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    role?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelClubClubAdminCountAggregateInputType = {
    id?: true
    clubId?: true
    adminId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    role?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelClubClubAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelClubClubAdmin to aggregate.
     */
    where?: RelClubClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelClubClubAdmins to fetch.
     */
    orderBy?: RelClubClubAdminOrderByWithRelationInput | RelClubClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelClubClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelClubClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelClubClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelClubClubAdmins
    **/
    _count?: true | RelClubClubAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelClubClubAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelClubClubAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelClubClubAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelClubClubAdminMaxAggregateInputType
  }

  export type GetRelClubClubAdminAggregateType<T extends RelClubClubAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateRelClubClubAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelClubClubAdmin[P]>
      : GetScalarType<T[P], AggregateRelClubClubAdmin[P]>
  }




  export type RelClubClubAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelClubClubAdminWhereInput
    orderBy?: RelClubClubAdminOrderByWithAggregationInput | RelClubClubAdminOrderByWithAggregationInput[]
    by: RelClubClubAdminScalarFieldEnum[] | RelClubClubAdminScalarFieldEnum
    having?: RelClubClubAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelClubClubAdminCountAggregateInputType | true
    _avg?: RelClubClubAdminAvgAggregateInputType
    _sum?: RelClubClubAdminSumAggregateInputType
    _min?: RelClubClubAdminMinAggregateInputType
    _max?: RelClubClubAdminMaxAggregateInputType
  }

  export type RelClubClubAdminGroupByOutputType = {
    id: Decimal
    clubId: Decimal
    adminId: Decimal
    joinedAt: Date | null
    leftAt: Date | null
    status: string
    role: string
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelClubClubAdminCountAggregateOutputType | null
    _avg: RelClubClubAdminAvgAggregateOutputType | null
    _sum: RelClubClubAdminSumAggregateOutputType | null
    _min: RelClubClubAdminMinAggregateOutputType | null
    _max: RelClubClubAdminMaxAggregateOutputType | null
  }

  type GetRelClubClubAdminGroupByPayload<T extends RelClubClubAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelClubClubAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelClubClubAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelClubClubAdminGroupByOutputType[P]>
            : GetScalarType<T[P], RelClubClubAdminGroupByOutputType[P]>
        }
      >
    >


  export type RelClubClubAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubId?: boolean
    adminId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    role?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relClubClubAdmin"]>

  export type RelClubClubAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubId?: boolean
    adminId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    role?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relClubClubAdmin"]>

  export type RelClubClubAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubId?: boolean
    adminId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    role?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relClubClubAdmin"]>

  export type RelClubClubAdminSelectScalar = {
    id?: boolean
    clubId?: boolean
    adminId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    role?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelClubClubAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clubId" | "adminId" | "joinedAt" | "leftAt" | "status" | "role" | "salary" | "contractStart" | "contractEnd" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relClubClubAdmin"]>

  export type $RelClubClubAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelClubClubAdmin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      clubId: Prisma.Decimal
      adminId: Prisma.Decimal
      joinedAt: Date | null
      leftAt: Date | null
      status: string
      role: string
      salary: Prisma.Decimal | null
      contractStart: Date | null
      contractEnd: Date | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relClubClubAdmin"]>
    composites: {}
  }

  type RelClubClubAdminGetPayload<S extends boolean | null | undefined | RelClubClubAdminDefaultArgs> = $Result.GetResult<Prisma.$RelClubClubAdminPayload, S>

  type RelClubClubAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelClubClubAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelClubClubAdminCountAggregateInputType | true
    }

  export interface RelClubClubAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelClubClubAdmin'], meta: { name: 'RelClubClubAdmin' } }
    /**
     * Find zero or one RelClubClubAdmin that matches the filter.
     * @param {RelClubClubAdminFindUniqueArgs} args - Arguments to find a RelClubClubAdmin
     * @example
     * // Get one RelClubClubAdmin
     * const relClubClubAdmin = await prisma.relClubClubAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelClubClubAdminFindUniqueArgs>(args: SelectSubset<T, RelClubClubAdminFindUniqueArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelClubClubAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelClubClubAdminFindUniqueOrThrowArgs} args - Arguments to find a RelClubClubAdmin
     * @example
     * // Get one RelClubClubAdmin
     * const relClubClubAdmin = await prisma.relClubClubAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelClubClubAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, RelClubClubAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelClubClubAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminFindFirstArgs} args - Arguments to find a RelClubClubAdmin
     * @example
     * // Get one RelClubClubAdmin
     * const relClubClubAdmin = await prisma.relClubClubAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelClubClubAdminFindFirstArgs>(args?: SelectSubset<T, RelClubClubAdminFindFirstArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelClubClubAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminFindFirstOrThrowArgs} args - Arguments to find a RelClubClubAdmin
     * @example
     * // Get one RelClubClubAdmin
     * const relClubClubAdmin = await prisma.relClubClubAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelClubClubAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, RelClubClubAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelClubClubAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelClubClubAdmins
     * const relClubClubAdmins = await prisma.relClubClubAdmin.findMany()
     * 
     * // Get first 10 RelClubClubAdmins
     * const relClubClubAdmins = await prisma.relClubClubAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relClubClubAdminWithIdOnly = await prisma.relClubClubAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelClubClubAdminFindManyArgs>(args?: SelectSubset<T, RelClubClubAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelClubClubAdmin.
     * @param {RelClubClubAdminCreateArgs} args - Arguments to create a RelClubClubAdmin.
     * @example
     * // Create one RelClubClubAdmin
     * const RelClubClubAdmin = await prisma.relClubClubAdmin.create({
     *   data: {
     *     // ... data to create a RelClubClubAdmin
     *   }
     * })
     * 
     */
    create<T extends RelClubClubAdminCreateArgs>(args: SelectSubset<T, RelClubClubAdminCreateArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelClubClubAdmins.
     * @param {RelClubClubAdminCreateManyArgs} args - Arguments to create many RelClubClubAdmins.
     * @example
     * // Create many RelClubClubAdmins
     * const relClubClubAdmin = await prisma.relClubClubAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelClubClubAdminCreateManyArgs>(args?: SelectSubset<T, RelClubClubAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelClubClubAdmins and returns the data saved in the database.
     * @param {RelClubClubAdminCreateManyAndReturnArgs} args - Arguments to create many RelClubClubAdmins.
     * @example
     * // Create many RelClubClubAdmins
     * const relClubClubAdmin = await prisma.relClubClubAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelClubClubAdmins and only return the `id`
     * const relClubClubAdminWithIdOnly = await prisma.relClubClubAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelClubClubAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, RelClubClubAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelClubClubAdmin.
     * @param {RelClubClubAdminDeleteArgs} args - Arguments to delete one RelClubClubAdmin.
     * @example
     * // Delete one RelClubClubAdmin
     * const RelClubClubAdmin = await prisma.relClubClubAdmin.delete({
     *   where: {
     *     // ... filter to delete one RelClubClubAdmin
     *   }
     * })
     * 
     */
    delete<T extends RelClubClubAdminDeleteArgs>(args: SelectSubset<T, RelClubClubAdminDeleteArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelClubClubAdmin.
     * @param {RelClubClubAdminUpdateArgs} args - Arguments to update one RelClubClubAdmin.
     * @example
     * // Update one RelClubClubAdmin
     * const relClubClubAdmin = await prisma.relClubClubAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelClubClubAdminUpdateArgs>(args: SelectSubset<T, RelClubClubAdminUpdateArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelClubClubAdmins.
     * @param {RelClubClubAdminDeleteManyArgs} args - Arguments to filter RelClubClubAdmins to delete.
     * @example
     * // Delete a few RelClubClubAdmins
     * const { count } = await prisma.relClubClubAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelClubClubAdminDeleteManyArgs>(args?: SelectSubset<T, RelClubClubAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelClubClubAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelClubClubAdmins
     * const relClubClubAdmin = await prisma.relClubClubAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelClubClubAdminUpdateManyArgs>(args: SelectSubset<T, RelClubClubAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelClubClubAdmins and returns the data updated in the database.
     * @param {RelClubClubAdminUpdateManyAndReturnArgs} args - Arguments to update many RelClubClubAdmins.
     * @example
     * // Update many RelClubClubAdmins
     * const relClubClubAdmin = await prisma.relClubClubAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelClubClubAdmins and only return the `id`
     * const relClubClubAdminWithIdOnly = await prisma.relClubClubAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelClubClubAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, RelClubClubAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelClubClubAdmin.
     * @param {RelClubClubAdminUpsertArgs} args - Arguments to update or create a RelClubClubAdmin.
     * @example
     * // Update or create a RelClubClubAdmin
     * const relClubClubAdmin = await prisma.relClubClubAdmin.upsert({
     *   create: {
     *     // ... data to create a RelClubClubAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelClubClubAdmin we want to update
     *   }
     * })
     */
    upsert<T extends RelClubClubAdminUpsertArgs>(args: SelectSubset<T, RelClubClubAdminUpsertArgs<ExtArgs>>): Prisma__RelClubClubAdminClient<$Result.GetResult<Prisma.$RelClubClubAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelClubClubAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminCountArgs} args - Arguments to filter RelClubClubAdmins to count.
     * @example
     * // Count the number of RelClubClubAdmins
     * const count = await prisma.relClubClubAdmin.count({
     *   where: {
     *     // ... the filter for the RelClubClubAdmins we want to count
     *   }
     * })
    **/
    count<T extends RelClubClubAdminCountArgs>(
      args?: Subset<T, RelClubClubAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelClubClubAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelClubClubAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelClubClubAdminAggregateArgs>(args: Subset<T, RelClubClubAdminAggregateArgs>): Prisma.PrismaPromise<GetRelClubClubAdminAggregateType<T>>

    /**
     * Group by RelClubClubAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelClubClubAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelClubClubAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelClubClubAdminGroupByArgs['orderBy'] }
        : { orderBy?: RelClubClubAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelClubClubAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelClubClubAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelClubClubAdmin model
   */
  readonly fields: RelClubClubAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelClubClubAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelClubClubAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelClubClubAdmin model
   */
  interface RelClubClubAdminFieldRefs {
    readonly id: FieldRef<"RelClubClubAdmin", 'Decimal'>
    readonly clubId: FieldRef<"RelClubClubAdmin", 'Decimal'>
    readonly adminId: FieldRef<"RelClubClubAdmin", 'Decimal'>
    readonly joinedAt: FieldRef<"RelClubClubAdmin", 'DateTime'>
    readonly leftAt: FieldRef<"RelClubClubAdmin", 'DateTime'>
    readonly status: FieldRef<"RelClubClubAdmin", 'String'>
    readonly role: FieldRef<"RelClubClubAdmin", 'String'>
    readonly salary: FieldRef<"RelClubClubAdmin", 'Decimal'>
    readonly contractStart: FieldRef<"RelClubClubAdmin", 'DateTime'>
    readonly contractEnd: FieldRef<"RelClubClubAdmin", 'DateTime'>
    readonly notes: FieldRef<"RelClubClubAdmin", 'String'>
    readonly ord: FieldRef<"RelClubClubAdmin", 'Int'>
    readonly createdAt: FieldRef<"RelClubClubAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"RelClubClubAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelClubClubAdmin findUnique
   */
  export type RelClubClubAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which RelClubClubAdmin to fetch.
     */
    where: RelClubClubAdminWhereUniqueInput
  }

  /**
   * RelClubClubAdmin findUniqueOrThrow
   */
  export type RelClubClubAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which RelClubClubAdmin to fetch.
     */
    where: RelClubClubAdminWhereUniqueInput
  }

  /**
   * RelClubClubAdmin findFirst
   */
  export type RelClubClubAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which RelClubClubAdmin to fetch.
     */
    where?: RelClubClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelClubClubAdmins to fetch.
     */
    orderBy?: RelClubClubAdminOrderByWithRelationInput | RelClubClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelClubClubAdmins.
     */
    cursor?: RelClubClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelClubClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelClubClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelClubClubAdmins.
     */
    distinct?: RelClubClubAdminScalarFieldEnum | RelClubClubAdminScalarFieldEnum[]
  }

  /**
   * RelClubClubAdmin findFirstOrThrow
   */
  export type RelClubClubAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which RelClubClubAdmin to fetch.
     */
    where?: RelClubClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelClubClubAdmins to fetch.
     */
    orderBy?: RelClubClubAdminOrderByWithRelationInput | RelClubClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelClubClubAdmins.
     */
    cursor?: RelClubClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelClubClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelClubClubAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelClubClubAdmins.
     */
    distinct?: RelClubClubAdminScalarFieldEnum | RelClubClubAdminScalarFieldEnum[]
  }

  /**
   * RelClubClubAdmin findMany
   */
  export type RelClubClubAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * Filter, which RelClubClubAdmins to fetch.
     */
    where?: RelClubClubAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelClubClubAdmins to fetch.
     */
    orderBy?: RelClubClubAdminOrderByWithRelationInput | RelClubClubAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelClubClubAdmins.
     */
    cursor?: RelClubClubAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelClubClubAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelClubClubAdmins.
     */
    skip?: number
    distinct?: RelClubClubAdminScalarFieldEnum | RelClubClubAdminScalarFieldEnum[]
  }

  /**
   * RelClubClubAdmin create
   */
  export type RelClubClubAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * The data needed to create a RelClubClubAdmin.
     */
    data: XOR<RelClubClubAdminCreateInput, RelClubClubAdminUncheckedCreateInput>
  }

  /**
   * RelClubClubAdmin createMany
   */
  export type RelClubClubAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelClubClubAdmins.
     */
    data: RelClubClubAdminCreateManyInput | RelClubClubAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelClubClubAdmin createManyAndReturn
   */
  export type RelClubClubAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * The data used to create many RelClubClubAdmins.
     */
    data: RelClubClubAdminCreateManyInput | RelClubClubAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelClubClubAdmin update
   */
  export type RelClubClubAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * The data needed to update a RelClubClubAdmin.
     */
    data: XOR<RelClubClubAdminUpdateInput, RelClubClubAdminUncheckedUpdateInput>
    /**
     * Choose, which RelClubClubAdmin to update.
     */
    where: RelClubClubAdminWhereUniqueInput
  }

  /**
   * RelClubClubAdmin updateMany
   */
  export type RelClubClubAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelClubClubAdmins.
     */
    data: XOR<RelClubClubAdminUpdateManyMutationInput, RelClubClubAdminUncheckedUpdateManyInput>
    /**
     * Filter which RelClubClubAdmins to update
     */
    where?: RelClubClubAdminWhereInput
    /**
     * Limit how many RelClubClubAdmins to update.
     */
    limit?: number
  }

  /**
   * RelClubClubAdmin updateManyAndReturn
   */
  export type RelClubClubAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * The data used to update RelClubClubAdmins.
     */
    data: XOR<RelClubClubAdminUpdateManyMutationInput, RelClubClubAdminUncheckedUpdateManyInput>
    /**
     * Filter which RelClubClubAdmins to update
     */
    where?: RelClubClubAdminWhereInput
    /**
     * Limit how many RelClubClubAdmins to update.
     */
    limit?: number
  }

  /**
   * RelClubClubAdmin upsert
   */
  export type RelClubClubAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * The filter to search for the RelClubClubAdmin to update in case it exists.
     */
    where: RelClubClubAdminWhereUniqueInput
    /**
     * In case the RelClubClubAdmin found by the `where` argument doesn't exist, create a new RelClubClubAdmin with this data.
     */
    create: XOR<RelClubClubAdminCreateInput, RelClubClubAdminUncheckedCreateInput>
    /**
     * In case the RelClubClubAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelClubClubAdminUpdateInput, RelClubClubAdminUncheckedUpdateInput>
  }

  /**
   * RelClubClubAdmin delete
   */
  export type RelClubClubAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
    /**
     * Filter which RelClubClubAdmin to delete.
     */
    where: RelClubClubAdminWhereUniqueInput
  }

  /**
   * RelClubClubAdmin deleteMany
   */
  export type RelClubClubAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelClubClubAdmins to delete
     */
    where?: RelClubClubAdminWhereInput
    /**
     * Limit how many RelClubClubAdmins to delete.
     */
    limit?: number
  }

  /**
   * RelClubClubAdmin without action
   */
  export type RelClubClubAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelClubClubAdmin
     */
    select?: RelClubClubAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelClubClubAdmin
     */
    omit?: RelClubClubAdminOmit<ExtArgs> | null
  }


  /**
   * Model RelCompetitionGroupLevel
   */

  export type AggregateRelCompetitionGroupLevel = {
    _count: RelCompetitionGroupLevelCountAggregateOutputType | null
    _avg: RelCompetitionGroupLevelAvgAggregateOutputType | null
    _sum: RelCompetitionGroupLevelSumAggregateOutputType | null
    _min: RelCompetitionGroupLevelMinAggregateOutputType | null
    _max: RelCompetitionGroupLevelMaxAggregateOutputType | null
  }

  export type RelCompetitionGroupLevelAvgAggregateOutputType = {
    id: Decimal | null
    competitionId: Decimal | null
    groupLevelId: Decimal | null
    isPrimary: number | null
    ord: number | null
  }

  export type RelCompetitionGroupLevelSumAggregateOutputType = {
    id: Decimal | null
    competitionId: Decimal | null
    groupLevelId: Decimal | null
    isPrimary: number | null
    ord: number | null
  }

  export type RelCompetitionGroupLevelMinAggregateOutputType = {
    id: Decimal | null
    competitionId: Decimal | null
    groupLevelId: Decimal | null
    isPrimary: number | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelCompetitionGroupLevelMaxAggregateOutputType = {
    id: Decimal | null
    competitionId: Decimal | null
    groupLevelId: Decimal | null
    isPrimary: number | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelCompetitionGroupLevelCountAggregateOutputType = {
    id: number
    competitionId: number
    groupLevelId: number
    isPrimary: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelCompetitionGroupLevelAvgAggregateInputType = {
    id?: true
    competitionId?: true
    groupLevelId?: true
    isPrimary?: true
    ord?: true
  }

  export type RelCompetitionGroupLevelSumAggregateInputType = {
    id?: true
    competitionId?: true
    groupLevelId?: true
    isPrimary?: true
    ord?: true
  }

  export type RelCompetitionGroupLevelMinAggregateInputType = {
    id?: true
    competitionId?: true
    groupLevelId?: true
    isPrimary?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelCompetitionGroupLevelMaxAggregateInputType = {
    id?: true
    competitionId?: true
    groupLevelId?: true
    isPrimary?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelCompetitionGroupLevelCountAggregateInputType = {
    id?: true
    competitionId?: true
    groupLevelId?: true
    isPrimary?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelCompetitionGroupLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelCompetitionGroupLevel to aggregate.
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelCompetitionGroupLevels to fetch.
     */
    orderBy?: RelCompetitionGroupLevelOrderByWithRelationInput | RelCompetitionGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelCompetitionGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelCompetitionGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelCompetitionGroupLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelCompetitionGroupLevels
    **/
    _count?: true | RelCompetitionGroupLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelCompetitionGroupLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelCompetitionGroupLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelCompetitionGroupLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelCompetitionGroupLevelMaxAggregateInputType
  }

  export type GetRelCompetitionGroupLevelAggregateType<T extends RelCompetitionGroupLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateRelCompetitionGroupLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelCompetitionGroupLevel[P]>
      : GetScalarType<T[P], AggregateRelCompetitionGroupLevel[P]>
  }




  export type RelCompetitionGroupLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelCompetitionGroupLevelWhereInput
    orderBy?: RelCompetitionGroupLevelOrderByWithAggregationInput | RelCompetitionGroupLevelOrderByWithAggregationInput[]
    by: RelCompetitionGroupLevelScalarFieldEnum[] | RelCompetitionGroupLevelScalarFieldEnum
    having?: RelCompetitionGroupLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelCompetitionGroupLevelCountAggregateInputType | true
    _avg?: RelCompetitionGroupLevelAvgAggregateInputType
    _sum?: RelCompetitionGroupLevelSumAggregateInputType
    _min?: RelCompetitionGroupLevelMinAggregateInputType
    _max?: RelCompetitionGroupLevelMaxAggregateInputType
  }

  export type RelCompetitionGroupLevelGroupByOutputType = {
    id: Decimal
    competitionId: Decimal
    groupLevelId: Decimal
    isPrimary: number
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelCompetitionGroupLevelCountAggregateOutputType | null
    _avg: RelCompetitionGroupLevelAvgAggregateOutputType | null
    _sum: RelCompetitionGroupLevelSumAggregateOutputType | null
    _min: RelCompetitionGroupLevelMinAggregateOutputType | null
    _max: RelCompetitionGroupLevelMaxAggregateOutputType | null
  }

  type GetRelCompetitionGroupLevelGroupByPayload<T extends RelCompetitionGroupLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelCompetitionGroupLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelCompetitionGroupLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelCompetitionGroupLevelGroupByOutputType[P]>
            : GetScalarType<T[P], RelCompetitionGroupLevelGroupByOutputType[P]>
        }
      >
    >


  export type RelCompetitionGroupLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competitionId?: boolean
    groupLevelId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relCompetitionGroupLevel"]>

  export type RelCompetitionGroupLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competitionId?: boolean
    groupLevelId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relCompetitionGroupLevel"]>

  export type RelCompetitionGroupLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    competitionId?: boolean
    groupLevelId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relCompetitionGroupLevel"]>

  export type RelCompetitionGroupLevelSelectScalar = {
    id?: boolean
    competitionId?: boolean
    groupLevelId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelCompetitionGroupLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "competitionId" | "groupLevelId" | "isPrimary" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relCompetitionGroupLevel"]>

  export type $RelCompetitionGroupLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelCompetitionGroupLevel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      competitionId: Prisma.Decimal
      groupLevelId: Prisma.Decimal
      isPrimary: number
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relCompetitionGroupLevel"]>
    composites: {}
  }

  type RelCompetitionGroupLevelGetPayload<S extends boolean | null | undefined | RelCompetitionGroupLevelDefaultArgs> = $Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload, S>

  type RelCompetitionGroupLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelCompetitionGroupLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelCompetitionGroupLevelCountAggregateInputType | true
    }

  export interface RelCompetitionGroupLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelCompetitionGroupLevel'], meta: { name: 'RelCompetitionGroupLevel' } }
    /**
     * Find zero or one RelCompetitionGroupLevel that matches the filter.
     * @param {RelCompetitionGroupLevelFindUniqueArgs} args - Arguments to find a RelCompetitionGroupLevel
     * @example
     * // Get one RelCompetitionGroupLevel
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelCompetitionGroupLevelFindUniqueArgs>(args: SelectSubset<T, RelCompetitionGroupLevelFindUniqueArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelCompetitionGroupLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelCompetitionGroupLevelFindUniqueOrThrowArgs} args - Arguments to find a RelCompetitionGroupLevel
     * @example
     * // Get one RelCompetitionGroupLevel
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelCompetitionGroupLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, RelCompetitionGroupLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelCompetitionGroupLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelFindFirstArgs} args - Arguments to find a RelCompetitionGroupLevel
     * @example
     * // Get one RelCompetitionGroupLevel
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelCompetitionGroupLevelFindFirstArgs>(args?: SelectSubset<T, RelCompetitionGroupLevelFindFirstArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelCompetitionGroupLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelFindFirstOrThrowArgs} args - Arguments to find a RelCompetitionGroupLevel
     * @example
     * // Get one RelCompetitionGroupLevel
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelCompetitionGroupLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, RelCompetitionGroupLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelCompetitionGroupLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelCompetitionGroupLevels
     * const relCompetitionGroupLevels = await prisma.relCompetitionGroupLevel.findMany()
     * 
     * // Get first 10 RelCompetitionGroupLevels
     * const relCompetitionGroupLevels = await prisma.relCompetitionGroupLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relCompetitionGroupLevelWithIdOnly = await prisma.relCompetitionGroupLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelCompetitionGroupLevelFindManyArgs>(args?: SelectSubset<T, RelCompetitionGroupLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelCompetitionGroupLevel.
     * @param {RelCompetitionGroupLevelCreateArgs} args - Arguments to create a RelCompetitionGroupLevel.
     * @example
     * // Create one RelCompetitionGroupLevel
     * const RelCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.create({
     *   data: {
     *     // ... data to create a RelCompetitionGroupLevel
     *   }
     * })
     * 
     */
    create<T extends RelCompetitionGroupLevelCreateArgs>(args: SelectSubset<T, RelCompetitionGroupLevelCreateArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelCompetitionGroupLevels.
     * @param {RelCompetitionGroupLevelCreateManyArgs} args - Arguments to create many RelCompetitionGroupLevels.
     * @example
     * // Create many RelCompetitionGroupLevels
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelCompetitionGroupLevelCreateManyArgs>(args?: SelectSubset<T, RelCompetitionGroupLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelCompetitionGroupLevels and returns the data saved in the database.
     * @param {RelCompetitionGroupLevelCreateManyAndReturnArgs} args - Arguments to create many RelCompetitionGroupLevels.
     * @example
     * // Create many RelCompetitionGroupLevels
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelCompetitionGroupLevels and only return the `id`
     * const relCompetitionGroupLevelWithIdOnly = await prisma.relCompetitionGroupLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelCompetitionGroupLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, RelCompetitionGroupLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelCompetitionGroupLevel.
     * @param {RelCompetitionGroupLevelDeleteArgs} args - Arguments to delete one RelCompetitionGroupLevel.
     * @example
     * // Delete one RelCompetitionGroupLevel
     * const RelCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.delete({
     *   where: {
     *     // ... filter to delete one RelCompetitionGroupLevel
     *   }
     * })
     * 
     */
    delete<T extends RelCompetitionGroupLevelDeleteArgs>(args: SelectSubset<T, RelCompetitionGroupLevelDeleteArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelCompetitionGroupLevel.
     * @param {RelCompetitionGroupLevelUpdateArgs} args - Arguments to update one RelCompetitionGroupLevel.
     * @example
     * // Update one RelCompetitionGroupLevel
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelCompetitionGroupLevelUpdateArgs>(args: SelectSubset<T, RelCompetitionGroupLevelUpdateArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelCompetitionGroupLevels.
     * @param {RelCompetitionGroupLevelDeleteManyArgs} args - Arguments to filter RelCompetitionGroupLevels to delete.
     * @example
     * // Delete a few RelCompetitionGroupLevels
     * const { count } = await prisma.relCompetitionGroupLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelCompetitionGroupLevelDeleteManyArgs>(args?: SelectSubset<T, RelCompetitionGroupLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelCompetitionGroupLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelCompetitionGroupLevels
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelCompetitionGroupLevelUpdateManyArgs>(args: SelectSubset<T, RelCompetitionGroupLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelCompetitionGroupLevels and returns the data updated in the database.
     * @param {RelCompetitionGroupLevelUpdateManyAndReturnArgs} args - Arguments to update many RelCompetitionGroupLevels.
     * @example
     * // Update many RelCompetitionGroupLevels
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelCompetitionGroupLevels and only return the `id`
     * const relCompetitionGroupLevelWithIdOnly = await prisma.relCompetitionGroupLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelCompetitionGroupLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, RelCompetitionGroupLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelCompetitionGroupLevel.
     * @param {RelCompetitionGroupLevelUpsertArgs} args - Arguments to update or create a RelCompetitionGroupLevel.
     * @example
     * // Update or create a RelCompetitionGroupLevel
     * const relCompetitionGroupLevel = await prisma.relCompetitionGroupLevel.upsert({
     *   create: {
     *     // ... data to create a RelCompetitionGroupLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelCompetitionGroupLevel we want to update
     *   }
     * })
     */
    upsert<T extends RelCompetitionGroupLevelUpsertArgs>(args: SelectSubset<T, RelCompetitionGroupLevelUpsertArgs<ExtArgs>>): Prisma__RelCompetitionGroupLevelClient<$Result.GetResult<Prisma.$RelCompetitionGroupLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelCompetitionGroupLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelCountArgs} args - Arguments to filter RelCompetitionGroupLevels to count.
     * @example
     * // Count the number of RelCompetitionGroupLevels
     * const count = await prisma.relCompetitionGroupLevel.count({
     *   where: {
     *     // ... the filter for the RelCompetitionGroupLevels we want to count
     *   }
     * })
    **/
    count<T extends RelCompetitionGroupLevelCountArgs>(
      args?: Subset<T, RelCompetitionGroupLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelCompetitionGroupLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelCompetitionGroupLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelCompetitionGroupLevelAggregateArgs>(args: Subset<T, RelCompetitionGroupLevelAggregateArgs>): Prisma.PrismaPromise<GetRelCompetitionGroupLevelAggregateType<T>>

    /**
     * Group by RelCompetitionGroupLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelCompetitionGroupLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelCompetitionGroupLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelCompetitionGroupLevelGroupByArgs['orderBy'] }
        : { orderBy?: RelCompetitionGroupLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelCompetitionGroupLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelCompetitionGroupLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelCompetitionGroupLevel model
   */
  readonly fields: RelCompetitionGroupLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelCompetitionGroupLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelCompetitionGroupLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelCompetitionGroupLevel model
   */
  interface RelCompetitionGroupLevelFieldRefs {
    readonly id: FieldRef<"RelCompetitionGroupLevel", 'Decimal'>
    readonly competitionId: FieldRef<"RelCompetitionGroupLevel", 'Decimal'>
    readonly groupLevelId: FieldRef<"RelCompetitionGroupLevel", 'Decimal'>
    readonly isPrimary: FieldRef<"RelCompetitionGroupLevel", 'Int'>
    readonly notes: FieldRef<"RelCompetitionGroupLevel", 'String'>
    readonly ord: FieldRef<"RelCompetitionGroupLevel", 'Int'>
    readonly createdAt: FieldRef<"RelCompetitionGroupLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"RelCompetitionGroupLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelCompetitionGroupLevel findUnique
   */
  export type RelCompetitionGroupLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which RelCompetitionGroupLevel to fetch.
     */
    where: RelCompetitionGroupLevelWhereUniqueInput
  }

  /**
   * RelCompetitionGroupLevel findUniqueOrThrow
   */
  export type RelCompetitionGroupLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which RelCompetitionGroupLevel to fetch.
     */
    where: RelCompetitionGroupLevelWhereUniqueInput
  }

  /**
   * RelCompetitionGroupLevel findFirst
   */
  export type RelCompetitionGroupLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which RelCompetitionGroupLevel to fetch.
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelCompetitionGroupLevels to fetch.
     */
    orderBy?: RelCompetitionGroupLevelOrderByWithRelationInput | RelCompetitionGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelCompetitionGroupLevels.
     */
    cursor?: RelCompetitionGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelCompetitionGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelCompetitionGroupLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelCompetitionGroupLevels.
     */
    distinct?: RelCompetitionGroupLevelScalarFieldEnum | RelCompetitionGroupLevelScalarFieldEnum[]
  }

  /**
   * RelCompetitionGroupLevel findFirstOrThrow
   */
  export type RelCompetitionGroupLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which RelCompetitionGroupLevel to fetch.
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelCompetitionGroupLevels to fetch.
     */
    orderBy?: RelCompetitionGroupLevelOrderByWithRelationInput | RelCompetitionGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelCompetitionGroupLevels.
     */
    cursor?: RelCompetitionGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelCompetitionGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelCompetitionGroupLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelCompetitionGroupLevels.
     */
    distinct?: RelCompetitionGroupLevelScalarFieldEnum | RelCompetitionGroupLevelScalarFieldEnum[]
  }

  /**
   * RelCompetitionGroupLevel findMany
   */
  export type RelCompetitionGroupLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * Filter, which RelCompetitionGroupLevels to fetch.
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelCompetitionGroupLevels to fetch.
     */
    orderBy?: RelCompetitionGroupLevelOrderByWithRelationInput | RelCompetitionGroupLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelCompetitionGroupLevels.
     */
    cursor?: RelCompetitionGroupLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelCompetitionGroupLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelCompetitionGroupLevels.
     */
    skip?: number
    distinct?: RelCompetitionGroupLevelScalarFieldEnum | RelCompetitionGroupLevelScalarFieldEnum[]
  }

  /**
   * RelCompetitionGroupLevel create
   */
  export type RelCompetitionGroupLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * The data needed to create a RelCompetitionGroupLevel.
     */
    data: XOR<RelCompetitionGroupLevelCreateInput, RelCompetitionGroupLevelUncheckedCreateInput>
  }

  /**
   * RelCompetitionGroupLevel createMany
   */
  export type RelCompetitionGroupLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelCompetitionGroupLevels.
     */
    data: RelCompetitionGroupLevelCreateManyInput | RelCompetitionGroupLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelCompetitionGroupLevel createManyAndReturn
   */
  export type RelCompetitionGroupLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * The data used to create many RelCompetitionGroupLevels.
     */
    data: RelCompetitionGroupLevelCreateManyInput | RelCompetitionGroupLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelCompetitionGroupLevel update
   */
  export type RelCompetitionGroupLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * The data needed to update a RelCompetitionGroupLevel.
     */
    data: XOR<RelCompetitionGroupLevelUpdateInput, RelCompetitionGroupLevelUncheckedUpdateInput>
    /**
     * Choose, which RelCompetitionGroupLevel to update.
     */
    where: RelCompetitionGroupLevelWhereUniqueInput
  }

  /**
   * RelCompetitionGroupLevel updateMany
   */
  export type RelCompetitionGroupLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelCompetitionGroupLevels.
     */
    data: XOR<RelCompetitionGroupLevelUpdateManyMutationInput, RelCompetitionGroupLevelUncheckedUpdateManyInput>
    /**
     * Filter which RelCompetitionGroupLevels to update
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * Limit how many RelCompetitionGroupLevels to update.
     */
    limit?: number
  }

  /**
   * RelCompetitionGroupLevel updateManyAndReturn
   */
  export type RelCompetitionGroupLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * The data used to update RelCompetitionGroupLevels.
     */
    data: XOR<RelCompetitionGroupLevelUpdateManyMutationInput, RelCompetitionGroupLevelUncheckedUpdateManyInput>
    /**
     * Filter which RelCompetitionGroupLevels to update
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * Limit how many RelCompetitionGroupLevels to update.
     */
    limit?: number
  }

  /**
   * RelCompetitionGroupLevel upsert
   */
  export type RelCompetitionGroupLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * The filter to search for the RelCompetitionGroupLevel to update in case it exists.
     */
    where: RelCompetitionGroupLevelWhereUniqueInput
    /**
     * In case the RelCompetitionGroupLevel found by the `where` argument doesn't exist, create a new RelCompetitionGroupLevel with this data.
     */
    create: XOR<RelCompetitionGroupLevelCreateInput, RelCompetitionGroupLevelUncheckedCreateInput>
    /**
     * In case the RelCompetitionGroupLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelCompetitionGroupLevelUpdateInput, RelCompetitionGroupLevelUncheckedUpdateInput>
  }

  /**
   * RelCompetitionGroupLevel delete
   */
  export type RelCompetitionGroupLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
    /**
     * Filter which RelCompetitionGroupLevel to delete.
     */
    where: RelCompetitionGroupLevelWhereUniqueInput
  }

  /**
   * RelCompetitionGroupLevel deleteMany
   */
  export type RelCompetitionGroupLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelCompetitionGroupLevels to delete
     */
    where?: RelCompetitionGroupLevelWhereInput
    /**
     * Limit how many RelCompetitionGroupLevels to delete.
     */
    limit?: number
  }

  /**
   * RelCompetitionGroupLevel without action
   */
  export type RelCompetitionGroupLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelCompetitionGroupLevel
     */
    select?: RelCompetitionGroupLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelCompetitionGroupLevel
     */
    omit?: RelCompetitionGroupLevelOmit<ExtArgs> | null
  }


  /**
   * Model RelFieldSport
   */

  export type AggregateRelFieldSport = {
    _count: RelFieldSportCountAggregateOutputType | null
    _avg: RelFieldSportAvgAggregateOutputType | null
    _sum: RelFieldSportSumAggregateOutputType | null
    _min: RelFieldSportMinAggregateOutputType | null
    _max: RelFieldSportMaxAggregateOutputType | null
  }

  export type RelFieldSportAvgAggregateOutputType = {
    id: Decimal | null
    fieldId: Decimal | null
    sportId: Decimal | null
    isPrimary: number | null
    ord: number | null
  }

  export type RelFieldSportSumAggregateOutputType = {
    id: Decimal | null
    fieldId: Decimal | null
    sportId: Decimal | null
    isPrimary: number | null
    ord: number | null
  }

  export type RelFieldSportMinAggregateOutputType = {
    id: Decimal | null
    fieldId: Decimal | null
    sportId: Decimal | null
    isPrimary: number | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelFieldSportMaxAggregateOutputType = {
    id: Decimal | null
    fieldId: Decimal | null
    sportId: Decimal | null
    isPrimary: number | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelFieldSportCountAggregateOutputType = {
    id: number
    fieldId: number
    sportId: number
    isPrimary: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelFieldSportAvgAggregateInputType = {
    id?: true
    fieldId?: true
    sportId?: true
    isPrimary?: true
    ord?: true
  }

  export type RelFieldSportSumAggregateInputType = {
    id?: true
    fieldId?: true
    sportId?: true
    isPrimary?: true
    ord?: true
  }

  export type RelFieldSportMinAggregateInputType = {
    id?: true
    fieldId?: true
    sportId?: true
    isPrimary?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelFieldSportMaxAggregateInputType = {
    id?: true
    fieldId?: true
    sportId?: true
    isPrimary?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelFieldSportCountAggregateInputType = {
    id?: true
    fieldId?: true
    sportId?: true
    isPrimary?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelFieldSportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelFieldSport to aggregate.
     */
    where?: RelFieldSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelFieldSports to fetch.
     */
    orderBy?: RelFieldSportOrderByWithRelationInput | RelFieldSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelFieldSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelFieldSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelFieldSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelFieldSports
    **/
    _count?: true | RelFieldSportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelFieldSportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelFieldSportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelFieldSportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelFieldSportMaxAggregateInputType
  }

  export type GetRelFieldSportAggregateType<T extends RelFieldSportAggregateArgs> = {
        [P in keyof T & keyof AggregateRelFieldSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelFieldSport[P]>
      : GetScalarType<T[P], AggregateRelFieldSport[P]>
  }




  export type RelFieldSportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelFieldSportWhereInput
    orderBy?: RelFieldSportOrderByWithAggregationInput | RelFieldSportOrderByWithAggregationInput[]
    by: RelFieldSportScalarFieldEnum[] | RelFieldSportScalarFieldEnum
    having?: RelFieldSportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelFieldSportCountAggregateInputType | true
    _avg?: RelFieldSportAvgAggregateInputType
    _sum?: RelFieldSportSumAggregateInputType
    _min?: RelFieldSportMinAggregateInputType
    _max?: RelFieldSportMaxAggregateInputType
  }

  export type RelFieldSportGroupByOutputType = {
    id: Decimal
    fieldId: Decimal
    sportId: Decimal
    isPrimary: number
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelFieldSportCountAggregateOutputType | null
    _avg: RelFieldSportAvgAggregateOutputType | null
    _sum: RelFieldSportSumAggregateOutputType | null
    _min: RelFieldSportMinAggregateOutputType | null
    _max: RelFieldSportMaxAggregateOutputType | null
  }

  type GetRelFieldSportGroupByPayload<T extends RelFieldSportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelFieldSportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelFieldSportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelFieldSportGroupByOutputType[P]>
            : GetScalarType<T[P], RelFieldSportGroupByOutputType[P]>
        }
      >
    >


  export type RelFieldSportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    sportId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relFieldSport"]>

  export type RelFieldSportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    sportId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relFieldSport"]>

  export type RelFieldSportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    sportId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relFieldSport"]>

  export type RelFieldSportSelectScalar = {
    id?: boolean
    fieldId?: boolean
    sportId?: boolean
    isPrimary?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelFieldSportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldId" | "sportId" | "isPrimary" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relFieldSport"]>

  export type $RelFieldSportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelFieldSport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      fieldId: Prisma.Decimal
      sportId: Prisma.Decimal
      isPrimary: number
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relFieldSport"]>
    composites: {}
  }

  type RelFieldSportGetPayload<S extends boolean | null | undefined | RelFieldSportDefaultArgs> = $Result.GetResult<Prisma.$RelFieldSportPayload, S>

  type RelFieldSportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelFieldSportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelFieldSportCountAggregateInputType | true
    }

  export interface RelFieldSportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelFieldSport'], meta: { name: 'RelFieldSport' } }
    /**
     * Find zero or one RelFieldSport that matches the filter.
     * @param {RelFieldSportFindUniqueArgs} args - Arguments to find a RelFieldSport
     * @example
     * // Get one RelFieldSport
     * const relFieldSport = await prisma.relFieldSport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelFieldSportFindUniqueArgs>(args: SelectSubset<T, RelFieldSportFindUniqueArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelFieldSport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelFieldSportFindUniqueOrThrowArgs} args - Arguments to find a RelFieldSport
     * @example
     * // Get one RelFieldSport
     * const relFieldSport = await prisma.relFieldSport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelFieldSportFindUniqueOrThrowArgs>(args: SelectSubset<T, RelFieldSportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelFieldSport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportFindFirstArgs} args - Arguments to find a RelFieldSport
     * @example
     * // Get one RelFieldSport
     * const relFieldSport = await prisma.relFieldSport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelFieldSportFindFirstArgs>(args?: SelectSubset<T, RelFieldSportFindFirstArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelFieldSport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportFindFirstOrThrowArgs} args - Arguments to find a RelFieldSport
     * @example
     * // Get one RelFieldSport
     * const relFieldSport = await prisma.relFieldSport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelFieldSportFindFirstOrThrowArgs>(args?: SelectSubset<T, RelFieldSportFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelFieldSports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelFieldSports
     * const relFieldSports = await prisma.relFieldSport.findMany()
     * 
     * // Get first 10 RelFieldSports
     * const relFieldSports = await prisma.relFieldSport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relFieldSportWithIdOnly = await prisma.relFieldSport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelFieldSportFindManyArgs>(args?: SelectSubset<T, RelFieldSportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelFieldSport.
     * @param {RelFieldSportCreateArgs} args - Arguments to create a RelFieldSport.
     * @example
     * // Create one RelFieldSport
     * const RelFieldSport = await prisma.relFieldSport.create({
     *   data: {
     *     // ... data to create a RelFieldSport
     *   }
     * })
     * 
     */
    create<T extends RelFieldSportCreateArgs>(args: SelectSubset<T, RelFieldSportCreateArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelFieldSports.
     * @param {RelFieldSportCreateManyArgs} args - Arguments to create many RelFieldSports.
     * @example
     * // Create many RelFieldSports
     * const relFieldSport = await prisma.relFieldSport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelFieldSportCreateManyArgs>(args?: SelectSubset<T, RelFieldSportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelFieldSports and returns the data saved in the database.
     * @param {RelFieldSportCreateManyAndReturnArgs} args - Arguments to create many RelFieldSports.
     * @example
     * // Create many RelFieldSports
     * const relFieldSport = await prisma.relFieldSport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelFieldSports and only return the `id`
     * const relFieldSportWithIdOnly = await prisma.relFieldSport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelFieldSportCreateManyAndReturnArgs>(args?: SelectSubset<T, RelFieldSportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelFieldSport.
     * @param {RelFieldSportDeleteArgs} args - Arguments to delete one RelFieldSport.
     * @example
     * // Delete one RelFieldSport
     * const RelFieldSport = await prisma.relFieldSport.delete({
     *   where: {
     *     // ... filter to delete one RelFieldSport
     *   }
     * })
     * 
     */
    delete<T extends RelFieldSportDeleteArgs>(args: SelectSubset<T, RelFieldSportDeleteArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelFieldSport.
     * @param {RelFieldSportUpdateArgs} args - Arguments to update one RelFieldSport.
     * @example
     * // Update one RelFieldSport
     * const relFieldSport = await prisma.relFieldSport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelFieldSportUpdateArgs>(args: SelectSubset<T, RelFieldSportUpdateArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelFieldSports.
     * @param {RelFieldSportDeleteManyArgs} args - Arguments to filter RelFieldSports to delete.
     * @example
     * // Delete a few RelFieldSports
     * const { count } = await prisma.relFieldSport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelFieldSportDeleteManyArgs>(args?: SelectSubset<T, RelFieldSportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelFieldSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelFieldSports
     * const relFieldSport = await prisma.relFieldSport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelFieldSportUpdateManyArgs>(args: SelectSubset<T, RelFieldSportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelFieldSports and returns the data updated in the database.
     * @param {RelFieldSportUpdateManyAndReturnArgs} args - Arguments to update many RelFieldSports.
     * @example
     * // Update many RelFieldSports
     * const relFieldSport = await prisma.relFieldSport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelFieldSports and only return the `id`
     * const relFieldSportWithIdOnly = await prisma.relFieldSport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelFieldSportUpdateManyAndReturnArgs>(args: SelectSubset<T, RelFieldSportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelFieldSport.
     * @param {RelFieldSportUpsertArgs} args - Arguments to update or create a RelFieldSport.
     * @example
     * // Update or create a RelFieldSport
     * const relFieldSport = await prisma.relFieldSport.upsert({
     *   create: {
     *     // ... data to create a RelFieldSport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelFieldSport we want to update
     *   }
     * })
     */
    upsert<T extends RelFieldSportUpsertArgs>(args: SelectSubset<T, RelFieldSportUpsertArgs<ExtArgs>>): Prisma__RelFieldSportClient<$Result.GetResult<Prisma.$RelFieldSportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelFieldSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportCountArgs} args - Arguments to filter RelFieldSports to count.
     * @example
     * // Count the number of RelFieldSports
     * const count = await prisma.relFieldSport.count({
     *   where: {
     *     // ... the filter for the RelFieldSports we want to count
     *   }
     * })
    **/
    count<T extends RelFieldSportCountArgs>(
      args?: Subset<T, RelFieldSportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelFieldSportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelFieldSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelFieldSportAggregateArgs>(args: Subset<T, RelFieldSportAggregateArgs>): Prisma.PrismaPromise<GetRelFieldSportAggregateType<T>>

    /**
     * Group by RelFieldSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelFieldSportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelFieldSportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelFieldSportGroupByArgs['orderBy'] }
        : { orderBy?: RelFieldSportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelFieldSportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelFieldSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelFieldSport model
   */
  readonly fields: RelFieldSportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelFieldSport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelFieldSportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelFieldSport model
   */
  interface RelFieldSportFieldRefs {
    readonly id: FieldRef<"RelFieldSport", 'Decimal'>
    readonly fieldId: FieldRef<"RelFieldSport", 'Decimal'>
    readonly sportId: FieldRef<"RelFieldSport", 'Decimal'>
    readonly isPrimary: FieldRef<"RelFieldSport", 'Int'>
    readonly notes: FieldRef<"RelFieldSport", 'String'>
    readonly ord: FieldRef<"RelFieldSport", 'Int'>
    readonly createdAt: FieldRef<"RelFieldSport", 'DateTime'>
    readonly updatedAt: FieldRef<"RelFieldSport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelFieldSport findUnique
   */
  export type RelFieldSportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * Filter, which RelFieldSport to fetch.
     */
    where: RelFieldSportWhereUniqueInput
  }

  /**
   * RelFieldSport findUniqueOrThrow
   */
  export type RelFieldSportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * Filter, which RelFieldSport to fetch.
     */
    where: RelFieldSportWhereUniqueInput
  }

  /**
   * RelFieldSport findFirst
   */
  export type RelFieldSportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * Filter, which RelFieldSport to fetch.
     */
    where?: RelFieldSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelFieldSports to fetch.
     */
    orderBy?: RelFieldSportOrderByWithRelationInput | RelFieldSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelFieldSports.
     */
    cursor?: RelFieldSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelFieldSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelFieldSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelFieldSports.
     */
    distinct?: RelFieldSportScalarFieldEnum | RelFieldSportScalarFieldEnum[]
  }

  /**
   * RelFieldSport findFirstOrThrow
   */
  export type RelFieldSportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * Filter, which RelFieldSport to fetch.
     */
    where?: RelFieldSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelFieldSports to fetch.
     */
    orderBy?: RelFieldSportOrderByWithRelationInput | RelFieldSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelFieldSports.
     */
    cursor?: RelFieldSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelFieldSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelFieldSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelFieldSports.
     */
    distinct?: RelFieldSportScalarFieldEnum | RelFieldSportScalarFieldEnum[]
  }

  /**
   * RelFieldSport findMany
   */
  export type RelFieldSportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * Filter, which RelFieldSports to fetch.
     */
    where?: RelFieldSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelFieldSports to fetch.
     */
    orderBy?: RelFieldSportOrderByWithRelationInput | RelFieldSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelFieldSports.
     */
    cursor?: RelFieldSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelFieldSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelFieldSports.
     */
    skip?: number
    distinct?: RelFieldSportScalarFieldEnum | RelFieldSportScalarFieldEnum[]
  }

  /**
   * RelFieldSport create
   */
  export type RelFieldSportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * The data needed to create a RelFieldSport.
     */
    data: XOR<RelFieldSportCreateInput, RelFieldSportUncheckedCreateInput>
  }

  /**
   * RelFieldSport createMany
   */
  export type RelFieldSportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelFieldSports.
     */
    data: RelFieldSportCreateManyInput | RelFieldSportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelFieldSport createManyAndReturn
   */
  export type RelFieldSportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * The data used to create many RelFieldSports.
     */
    data: RelFieldSportCreateManyInput | RelFieldSportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelFieldSport update
   */
  export type RelFieldSportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * The data needed to update a RelFieldSport.
     */
    data: XOR<RelFieldSportUpdateInput, RelFieldSportUncheckedUpdateInput>
    /**
     * Choose, which RelFieldSport to update.
     */
    where: RelFieldSportWhereUniqueInput
  }

  /**
   * RelFieldSport updateMany
   */
  export type RelFieldSportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelFieldSports.
     */
    data: XOR<RelFieldSportUpdateManyMutationInput, RelFieldSportUncheckedUpdateManyInput>
    /**
     * Filter which RelFieldSports to update
     */
    where?: RelFieldSportWhereInput
    /**
     * Limit how many RelFieldSports to update.
     */
    limit?: number
  }

  /**
   * RelFieldSport updateManyAndReturn
   */
  export type RelFieldSportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * The data used to update RelFieldSports.
     */
    data: XOR<RelFieldSportUpdateManyMutationInput, RelFieldSportUncheckedUpdateManyInput>
    /**
     * Filter which RelFieldSports to update
     */
    where?: RelFieldSportWhereInput
    /**
     * Limit how many RelFieldSports to update.
     */
    limit?: number
  }

  /**
   * RelFieldSport upsert
   */
  export type RelFieldSportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * The filter to search for the RelFieldSport to update in case it exists.
     */
    where: RelFieldSportWhereUniqueInput
    /**
     * In case the RelFieldSport found by the `where` argument doesn't exist, create a new RelFieldSport with this data.
     */
    create: XOR<RelFieldSportCreateInput, RelFieldSportUncheckedCreateInput>
    /**
     * In case the RelFieldSport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelFieldSportUpdateInput, RelFieldSportUncheckedUpdateInput>
  }

  /**
   * RelFieldSport delete
   */
  export type RelFieldSportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
    /**
     * Filter which RelFieldSport to delete.
     */
    where: RelFieldSportWhereUniqueInput
  }

  /**
   * RelFieldSport deleteMany
   */
  export type RelFieldSportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelFieldSports to delete
     */
    where?: RelFieldSportWhereInput
    /**
     * Limit how many RelFieldSports to delete.
     */
    limit?: number
  }

  /**
   * RelFieldSport without action
   */
  export type RelFieldSportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelFieldSport
     */
    select?: RelFieldSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelFieldSport
     */
    omit?: RelFieldSportOmit<ExtArgs> | null
  }


  /**
   * Model RelMatchReferee
   */

  export type AggregateRelMatchReferee = {
    _count: RelMatchRefereeCountAggregateOutputType | null
    _avg: RelMatchRefereeAvgAggregateOutputType | null
    _sum: RelMatchRefereeSumAggregateOutputType | null
    _min: RelMatchRefereeMinAggregateOutputType | null
    _max: RelMatchRefereeMaxAggregateOutputType | null
  }

  export type RelMatchRefereeAvgAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    refereeId: Decimal | null
    matchFee: Decimal | null
    ord: number | null
  }

  export type RelMatchRefereeSumAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    refereeId: Decimal | null
    matchFee: Decimal | null
    ord: number | null
  }

  export type RelMatchRefereeMinAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    refereeId: Decimal | null
    assignedAt: Date | null
    confirmedAt: Date | null
    cancelledAt: Date | null
    status: string | null
    matchFee: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelMatchRefereeMaxAggregateOutputType = {
    id: Decimal | null
    matchId: Decimal | null
    refereeId: Decimal | null
    assignedAt: Date | null
    confirmedAt: Date | null
    cancelledAt: Date | null
    status: string | null
    matchFee: Decimal | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelMatchRefereeCountAggregateOutputType = {
    id: number
    matchId: number
    refereeId: number
    assignedAt: number
    confirmedAt: number
    cancelledAt: number
    status: number
    matchFee: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelMatchRefereeAvgAggregateInputType = {
    id?: true
    matchId?: true
    refereeId?: true
    matchFee?: true
    ord?: true
  }

  export type RelMatchRefereeSumAggregateInputType = {
    id?: true
    matchId?: true
    refereeId?: true
    matchFee?: true
    ord?: true
  }

  export type RelMatchRefereeMinAggregateInputType = {
    id?: true
    matchId?: true
    refereeId?: true
    assignedAt?: true
    confirmedAt?: true
    cancelledAt?: true
    status?: true
    matchFee?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelMatchRefereeMaxAggregateInputType = {
    id?: true
    matchId?: true
    refereeId?: true
    assignedAt?: true
    confirmedAt?: true
    cancelledAt?: true
    status?: true
    matchFee?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelMatchRefereeCountAggregateInputType = {
    id?: true
    matchId?: true
    refereeId?: true
    assignedAt?: true
    confirmedAt?: true
    cancelledAt?: true
    status?: true
    matchFee?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelMatchRefereeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelMatchReferee to aggregate.
     */
    where?: RelMatchRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelMatchReferees to fetch.
     */
    orderBy?: RelMatchRefereeOrderByWithRelationInput | RelMatchRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelMatchRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelMatchReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelMatchReferees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelMatchReferees
    **/
    _count?: true | RelMatchRefereeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelMatchRefereeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelMatchRefereeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelMatchRefereeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelMatchRefereeMaxAggregateInputType
  }

  export type GetRelMatchRefereeAggregateType<T extends RelMatchRefereeAggregateArgs> = {
        [P in keyof T & keyof AggregateRelMatchReferee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelMatchReferee[P]>
      : GetScalarType<T[P], AggregateRelMatchReferee[P]>
  }




  export type RelMatchRefereeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelMatchRefereeWhereInput
    orderBy?: RelMatchRefereeOrderByWithAggregationInput | RelMatchRefereeOrderByWithAggregationInput[]
    by: RelMatchRefereeScalarFieldEnum[] | RelMatchRefereeScalarFieldEnum
    having?: RelMatchRefereeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelMatchRefereeCountAggregateInputType | true
    _avg?: RelMatchRefereeAvgAggregateInputType
    _sum?: RelMatchRefereeSumAggregateInputType
    _min?: RelMatchRefereeMinAggregateInputType
    _max?: RelMatchRefereeMaxAggregateInputType
  }

  export type RelMatchRefereeGroupByOutputType = {
    id: Decimal
    matchId: Decimal
    refereeId: Decimal
    assignedAt: Date | null
    confirmedAt: Date | null
    cancelledAt: Date | null
    status: string
    matchFee: Decimal | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelMatchRefereeCountAggregateOutputType | null
    _avg: RelMatchRefereeAvgAggregateOutputType | null
    _sum: RelMatchRefereeSumAggregateOutputType | null
    _min: RelMatchRefereeMinAggregateOutputType | null
    _max: RelMatchRefereeMaxAggregateOutputType | null
  }

  type GetRelMatchRefereeGroupByPayload<T extends RelMatchRefereeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelMatchRefereeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelMatchRefereeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelMatchRefereeGroupByOutputType[P]>
            : GetScalarType<T[P], RelMatchRefereeGroupByOutputType[P]>
        }
      >
    >


  export type RelMatchRefereeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    refereeId?: boolean
    assignedAt?: boolean
    confirmedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    matchFee?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relMatchReferee"]>

  export type RelMatchRefereeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    refereeId?: boolean
    assignedAt?: boolean
    confirmedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    matchFee?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relMatchReferee"]>

  export type RelMatchRefereeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    refereeId?: boolean
    assignedAt?: boolean
    confirmedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    matchFee?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relMatchReferee"]>

  export type RelMatchRefereeSelectScalar = {
    id?: boolean
    matchId?: boolean
    refereeId?: boolean
    assignedAt?: boolean
    confirmedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    matchFee?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelMatchRefereeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchId" | "refereeId" | "assignedAt" | "confirmedAt" | "cancelledAt" | "status" | "matchFee" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relMatchReferee"]>

  export type $RelMatchRefereePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelMatchReferee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      matchId: Prisma.Decimal
      refereeId: Prisma.Decimal
      assignedAt: Date | null
      confirmedAt: Date | null
      cancelledAt: Date | null
      status: string
      matchFee: Prisma.Decimal | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relMatchReferee"]>
    composites: {}
  }

  type RelMatchRefereeGetPayload<S extends boolean | null | undefined | RelMatchRefereeDefaultArgs> = $Result.GetResult<Prisma.$RelMatchRefereePayload, S>

  type RelMatchRefereeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelMatchRefereeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelMatchRefereeCountAggregateInputType | true
    }

  export interface RelMatchRefereeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelMatchReferee'], meta: { name: 'RelMatchReferee' } }
    /**
     * Find zero or one RelMatchReferee that matches the filter.
     * @param {RelMatchRefereeFindUniqueArgs} args - Arguments to find a RelMatchReferee
     * @example
     * // Get one RelMatchReferee
     * const relMatchReferee = await prisma.relMatchReferee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelMatchRefereeFindUniqueArgs>(args: SelectSubset<T, RelMatchRefereeFindUniqueArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelMatchReferee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelMatchRefereeFindUniqueOrThrowArgs} args - Arguments to find a RelMatchReferee
     * @example
     * // Get one RelMatchReferee
     * const relMatchReferee = await prisma.relMatchReferee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelMatchRefereeFindUniqueOrThrowArgs>(args: SelectSubset<T, RelMatchRefereeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelMatchReferee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeFindFirstArgs} args - Arguments to find a RelMatchReferee
     * @example
     * // Get one RelMatchReferee
     * const relMatchReferee = await prisma.relMatchReferee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelMatchRefereeFindFirstArgs>(args?: SelectSubset<T, RelMatchRefereeFindFirstArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelMatchReferee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeFindFirstOrThrowArgs} args - Arguments to find a RelMatchReferee
     * @example
     * // Get one RelMatchReferee
     * const relMatchReferee = await prisma.relMatchReferee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelMatchRefereeFindFirstOrThrowArgs>(args?: SelectSubset<T, RelMatchRefereeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelMatchReferees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelMatchReferees
     * const relMatchReferees = await prisma.relMatchReferee.findMany()
     * 
     * // Get first 10 RelMatchReferees
     * const relMatchReferees = await prisma.relMatchReferee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relMatchRefereeWithIdOnly = await prisma.relMatchReferee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelMatchRefereeFindManyArgs>(args?: SelectSubset<T, RelMatchRefereeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelMatchReferee.
     * @param {RelMatchRefereeCreateArgs} args - Arguments to create a RelMatchReferee.
     * @example
     * // Create one RelMatchReferee
     * const RelMatchReferee = await prisma.relMatchReferee.create({
     *   data: {
     *     // ... data to create a RelMatchReferee
     *   }
     * })
     * 
     */
    create<T extends RelMatchRefereeCreateArgs>(args: SelectSubset<T, RelMatchRefereeCreateArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelMatchReferees.
     * @param {RelMatchRefereeCreateManyArgs} args - Arguments to create many RelMatchReferees.
     * @example
     * // Create many RelMatchReferees
     * const relMatchReferee = await prisma.relMatchReferee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelMatchRefereeCreateManyArgs>(args?: SelectSubset<T, RelMatchRefereeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelMatchReferees and returns the data saved in the database.
     * @param {RelMatchRefereeCreateManyAndReturnArgs} args - Arguments to create many RelMatchReferees.
     * @example
     * // Create many RelMatchReferees
     * const relMatchReferee = await prisma.relMatchReferee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelMatchReferees and only return the `id`
     * const relMatchRefereeWithIdOnly = await prisma.relMatchReferee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelMatchRefereeCreateManyAndReturnArgs>(args?: SelectSubset<T, RelMatchRefereeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelMatchReferee.
     * @param {RelMatchRefereeDeleteArgs} args - Arguments to delete one RelMatchReferee.
     * @example
     * // Delete one RelMatchReferee
     * const RelMatchReferee = await prisma.relMatchReferee.delete({
     *   where: {
     *     // ... filter to delete one RelMatchReferee
     *   }
     * })
     * 
     */
    delete<T extends RelMatchRefereeDeleteArgs>(args: SelectSubset<T, RelMatchRefereeDeleteArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelMatchReferee.
     * @param {RelMatchRefereeUpdateArgs} args - Arguments to update one RelMatchReferee.
     * @example
     * // Update one RelMatchReferee
     * const relMatchReferee = await prisma.relMatchReferee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelMatchRefereeUpdateArgs>(args: SelectSubset<T, RelMatchRefereeUpdateArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelMatchReferees.
     * @param {RelMatchRefereeDeleteManyArgs} args - Arguments to filter RelMatchReferees to delete.
     * @example
     * // Delete a few RelMatchReferees
     * const { count } = await prisma.relMatchReferee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelMatchRefereeDeleteManyArgs>(args?: SelectSubset<T, RelMatchRefereeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelMatchReferees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelMatchReferees
     * const relMatchReferee = await prisma.relMatchReferee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelMatchRefereeUpdateManyArgs>(args: SelectSubset<T, RelMatchRefereeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelMatchReferees and returns the data updated in the database.
     * @param {RelMatchRefereeUpdateManyAndReturnArgs} args - Arguments to update many RelMatchReferees.
     * @example
     * // Update many RelMatchReferees
     * const relMatchReferee = await prisma.relMatchReferee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelMatchReferees and only return the `id`
     * const relMatchRefereeWithIdOnly = await prisma.relMatchReferee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelMatchRefereeUpdateManyAndReturnArgs>(args: SelectSubset<T, RelMatchRefereeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelMatchReferee.
     * @param {RelMatchRefereeUpsertArgs} args - Arguments to update or create a RelMatchReferee.
     * @example
     * // Update or create a RelMatchReferee
     * const relMatchReferee = await prisma.relMatchReferee.upsert({
     *   create: {
     *     // ... data to create a RelMatchReferee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelMatchReferee we want to update
     *   }
     * })
     */
    upsert<T extends RelMatchRefereeUpsertArgs>(args: SelectSubset<T, RelMatchRefereeUpsertArgs<ExtArgs>>): Prisma__RelMatchRefereeClient<$Result.GetResult<Prisma.$RelMatchRefereePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelMatchReferees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeCountArgs} args - Arguments to filter RelMatchReferees to count.
     * @example
     * // Count the number of RelMatchReferees
     * const count = await prisma.relMatchReferee.count({
     *   where: {
     *     // ... the filter for the RelMatchReferees we want to count
     *   }
     * })
    **/
    count<T extends RelMatchRefereeCountArgs>(
      args?: Subset<T, RelMatchRefereeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelMatchRefereeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelMatchReferee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelMatchRefereeAggregateArgs>(args: Subset<T, RelMatchRefereeAggregateArgs>): Prisma.PrismaPromise<GetRelMatchRefereeAggregateType<T>>

    /**
     * Group by RelMatchReferee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelMatchRefereeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelMatchRefereeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelMatchRefereeGroupByArgs['orderBy'] }
        : { orderBy?: RelMatchRefereeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelMatchRefereeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelMatchRefereeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelMatchReferee model
   */
  readonly fields: RelMatchRefereeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelMatchReferee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelMatchRefereeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelMatchReferee model
   */
  interface RelMatchRefereeFieldRefs {
    readonly id: FieldRef<"RelMatchReferee", 'Decimal'>
    readonly matchId: FieldRef<"RelMatchReferee", 'Decimal'>
    readonly refereeId: FieldRef<"RelMatchReferee", 'Decimal'>
    readonly assignedAt: FieldRef<"RelMatchReferee", 'DateTime'>
    readonly confirmedAt: FieldRef<"RelMatchReferee", 'DateTime'>
    readonly cancelledAt: FieldRef<"RelMatchReferee", 'DateTime'>
    readonly status: FieldRef<"RelMatchReferee", 'String'>
    readonly matchFee: FieldRef<"RelMatchReferee", 'Decimal'>
    readonly notes: FieldRef<"RelMatchReferee", 'String'>
    readonly ord: FieldRef<"RelMatchReferee", 'Int'>
    readonly createdAt: FieldRef<"RelMatchReferee", 'DateTime'>
    readonly updatedAt: FieldRef<"RelMatchReferee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelMatchReferee findUnique
   */
  export type RelMatchRefereeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * Filter, which RelMatchReferee to fetch.
     */
    where: RelMatchRefereeWhereUniqueInput
  }

  /**
   * RelMatchReferee findUniqueOrThrow
   */
  export type RelMatchRefereeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * Filter, which RelMatchReferee to fetch.
     */
    where: RelMatchRefereeWhereUniqueInput
  }

  /**
   * RelMatchReferee findFirst
   */
  export type RelMatchRefereeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * Filter, which RelMatchReferee to fetch.
     */
    where?: RelMatchRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelMatchReferees to fetch.
     */
    orderBy?: RelMatchRefereeOrderByWithRelationInput | RelMatchRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelMatchReferees.
     */
    cursor?: RelMatchRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelMatchReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelMatchReferees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelMatchReferees.
     */
    distinct?: RelMatchRefereeScalarFieldEnum | RelMatchRefereeScalarFieldEnum[]
  }

  /**
   * RelMatchReferee findFirstOrThrow
   */
  export type RelMatchRefereeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * Filter, which RelMatchReferee to fetch.
     */
    where?: RelMatchRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelMatchReferees to fetch.
     */
    orderBy?: RelMatchRefereeOrderByWithRelationInput | RelMatchRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelMatchReferees.
     */
    cursor?: RelMatchRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelMatchReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelMatchReferees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelMatchReferees.
     */
    distinct?: RelMatchRefereeScalarFieldEnum | RelMatchRefereeScalarFieldEnum[]
  }

  /**
   * RelMatchReferee findMany
   */
  export type RelMatchRefereeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * Filter, which RelMatchReferees to fetch.
     */
    where?: RelMatchRefereeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelMatchReferees to fetch.
     */
    orderBy?: RelMatchRefereeOrderByWithRelationInput | RelMatchRefereeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelMatchReferees.
     */
    cursor?: RelMatchRefereeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelMatchReferees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelMatchReferees.
     */
    skip?: number
    distinct?: RelMatchRefereeScalarFieldEnum | RelMatchRefereeScalarFieldEnum[]
  }

  /**
   * RelMatchReferee create
   */
  export type RelMatchRefereeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * The data needed to create a RelMatchReferee.
     */
    data: XOR<RelMatchRefereeCreateInput, RelMatchRefereeUncheckedCreateInput>
  }

  /**
   * RelMatchReferee createMany
   */
  export type RelMatchRefereeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelMatchReferees.
     */
    data: RelMatchRefereeCreateManyInput | RelMatchRefereeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelMatchReferee createManyAndReturn
   */
  export type RelMatchRefereeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * The data used to create many RelMatchReferees.
     */
    data: RelMatchRefereeCreateManyInput | RelMatchRefereeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelMatchReferee update
   */
  export type RelMatchRefereeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * The data needed to update a RelMatchReferee.
     */
    data: XOR<RelMatchRefereeUpdateInput, RelMatchRefereeUncheckedUpdateInput>
    /**
     * Choose, which RelMatchReferee to update.
     */
    where: RelMatchRefereeWhereUniqueInput
  }

  /**
   * RelMatchReferee updateMany
   */
  export type RelMatchRefereeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelMatchReferees.
     */
    data: XOR<RelMatchRefereeUpdateManyMutationInput, RelMatchRefereeUncheckedUpdateManyInput>
    /**
     * Filter which RelMatchReferees to update
     */
    where?: RelMatchRefereeWhereInput
    /**
     * Limit how many RelMatchReferees to update.
     */
    limit?: number
  }

  /**
   * RelMatchReferee updateManyAndReturn
   */
  export type RelMatchRefereeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * The data used to update RelMatchReferees.
     */
    data: XOR<RelMatchRefereeUpdateManyMutationInput, RelMatchRefereeUncheckedUpdateManyInput>
    /**
     * Filter which RelMatchReferees to update
     */
    where?: RelMatchRefereeWhereInput
    /**
     * Limit how many RelMatchReferees to update.
     */
    limit?: number
  }

  /**
   * RelMatchReferee upsert
   */
  export type RelMatchRefereeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * The filter to search for the RelMatchReferee to update in case it exists.
     */
    where: RelMatchRefereeWhereUniqueInput
    /**
     * In case the RelMatchReferee found by the `where` argument doesn't exist, create a new RelMatchReferee with this data.
     */
    create: XOR<RelMatchRefereeCreateInput, RelMatchRefereeUncheckedCreateInput>
    /**
     * In case the RelMatchReferee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelMatchRefereeUpdateInput, RelMatchRefereeUncheckedUpdateInput>
  }

  /**
   * RelMatchReferee delete
   */
  export type RelMatchRefereeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
    /**
     * Filter which RelMatchReferee to delete.
     */
    where: RelMatchRefereeWhereUniqueInput
  }

  /**
   * RelMatchReferee deleteMany
   */
  export type RelMatchRefereeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelMatchReferees to delete
     */
    where?: RelMatchRefereeWhereInput
    /**
     * Limit how many RelMatchReferees to delete.
     */
    limit?: number
  }

  /**
   * RelMatchReferee without action
   */
  export type RelMatchRefereeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelMatchReferee
     */
    select?: RelMatchRefereeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelMatchReferee
     */
    omit?: RelMatchRefereeOmit<ExtArgs> | null
  }


  /**
   * Model RelPlayerParent
   */

  export type AggregateRelPlayerParent = {
    _count: RelPlayerParentCountAggregateOutputType | null
    _avg: RelPlayerParentAvgAggregateOutputType | null
    _sum: RelPlayerParentSumAggregateOutputType | null
    _min: RelPlayerParentMinAggregateOutputType | null
    _max: RelPlayerParentMaxAggregateOutputType | null
  }

  export type RelPlayerParentAvgAggregateOutputType = {
    id: Decimal | null
    playerId: Decimal | null
    parentId: Decimal | null
    isPrimaryContact: number | null
    canPickup: number | null
    receivesNotifications: number | null
    ord: number | null
  }

  export type RelPlayerParentSumAggregateOutputType = {
    id: Decimal | null
    playerId: Decimal | null
    parentId: Decimal | null
    isPrimaryContact: number | null
    canPickup: number | null
    receivesNotifications: number | null
    ord: number | null
  }

  export type RelPlayerParentMinAggregateOutputType = {
    id: Decimal | null
    playerId: Decimal | null
    parentId: Decimal | null
    assignedAt: Date | null
    removedAt: Date | null
    relationship: string | null
    isPrimaryContact: number | null
    canPickup: number | null
    receivesNotifications: number | null
    occupation: string | null
    employer: string | null
    workPhone: string | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelPlayerParentMaxAggregateOutputType = {
    id: Decimal | null
    playerId: Decimal | null
    parentId: Decimal | null
    assignedAt: Date | null
    removedAt: Date | null
    relationship: string | null
    isPrimaryContact: number | null
    canPickup: number | null
    receivesNotifications: number | null
    occupation: string | null
    employer: string | null
    workPhone: string | null
    status: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelPlayerParentCountAggregateOutputType = {
    id: number
    playerId: number
    parentId: number
    assignedAt: number
    removedAt: number
    relationship: number
    isPrimaryContact: number
    canPickup: number
    receivesNotifications: number
    occupation: number
    employer: number
    workPhone: number
    status: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelPlayerParentAvgAggregateInputType = {
    id?: true
    playerId?: true
    parentId?: true
    isPrimaryContact?: true
    canPickup?: true
    receivesNotifications?: true
    ord?: true
  }

  export type RelPlayerParentSumAggregateInputType = {
    id?: true
    playerId?: true
    parentId?: true
    isPrimaryContact?: true
    canPickup?: true
    receivesNotifications?: true
    ord?: true
  }

  export type RelPlayerParentMinAggregateInputType = {
    id?: true
    playerId?: true
    parentId?: true
    assignedAt?: true
    removedAt?: true
    relationship?: true
    isPrimaryContact?: true
    canPickup?: true
    receivesNotifications?: true
    occupation?: true
    employer?: true
    workPhone?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelPlayerParentMaxAggregateInputType = {
    id?: true
    playerId?: true
    parentId?: true
    assignedAt?: true
    removedAt?: true
    relationship?: true
    isPrimaryContact?: true
    canPickup?: true
    receivesNotifications?: true
    occupation?: true
    employer?: true
    workPhone?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelPlayerParentCountAggregateInputType = {
    id?: true
    playerId?: true
    parentId?: true
    assignedAt?: true
    removedAt?: true
    relationship?: true
    isPrimaryContact?: true
    canPickup?: true
    receivesNotifications?: true
    occupation?: true
    employer?: true
    workPhone?: true
    status?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelPlayerParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelPlayerParent to aggregate.
     */
    where?: RelPlayerParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelPlayerParents to fetch.
     */
    orderBy?: RelPlayerParentOrderByWithRelationInput | RelPlayerParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelPlayerParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelPlayerParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelPlayerParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelPlayerParents
    **/
    _count?: true | RelPlayerParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelPlayerParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelPlayerParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelPlayerParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelPlayerParentMaxAggregateInputType
  }

  export type GetRelPlayerParentAggregateType<T extends RelPlayerParentAggregateArgs> = {
        [P in keyof T & keyof AggregateRelPlayerParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelPlayerParent[P]>
      : GetScalarType<T[P], AggregateRelPlayerParent[P]>
  }




  export type RelPlayerParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelPlayerParentWhereInput
    orderBy?: RelPlayerParentOrderByWithAggregationInput | RelPlayerParentOrderByWithAggregationInput[]
    by: RelPlayerParentScalarFieldEnum[] | RelPlayerParentScalarFieldEnum
    having?: RelPlayerParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelPlayerParentCountAggregateInputType | true
    _avg?: RelPlayerParentAvgAggregateInputType
    _sum?: RelPlayerParentSumAggregateInputType
    _min?: RelPlayerParentMinAggregateInputType
    _max?: RelPlayerParentMaxAggregateInputType
  }

  export type RelPlayerParentGroupByOutputType = {
    id: Decimal
    playerId: Decimal
    parentId: Decimal
    assignedAt: Date | null
    removedAt: Date | null
    relationship: string | null
    isPrimaryContact: number
    canPickup: number
    receivesNotifications: number
    occupation: string | null
    employer: string | null
    workPhone: string | null
    status: string
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelPlayerParentCountAggregateOutputType | null
    _avg: RelPlayerParentAvgAggregateOutputType | null
    _sum: RelPlayerParentSumAggregateOutputType | null
    _min: RelPlayerParentMinAggregateOutputType | null
    _max: RelPlayerParentMaxAggregateOutputType | null
  }

  type GetRelPlayerParentGroupByPayload<T extends RelPlayerParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelPlayerParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelPlayerParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelPlayerParentGroupByOutputType[P]>
            : GetScalarType<T[P], RelPlayerParentGroupByOutputType[P]>
        }
      >
    >


  export type RelPlayerParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    parentId?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    relationship?: boolean
    isPrimaryContact?: boolean
    canPickup?: boolean
    receivesNotifications?: boolean
    occupation?: boolean
    employer?: boolean
    workPhone?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relPlayerParent"]>

  export type RelPlayerParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    parentId?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    relationship?: boolean
    isPrimaryContact?: boolean
    canPickup?: boolean
    receivesNotifications?: boolean
    occupation?: boolean
    employer?: boolean
    workPhone?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relPlayerParent"]>

  export type RelPlayerParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    parentId?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    relationship?: boolean
    isPrimaryContact?: boolean
    canPickup?: boolean
    receivesNotifications?: boolean
    occupation?: boolean
    employer?: boolean
    workPhone?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relPlayerParent"]>

  export type RelPlayerParentSelectScalar = {
    id?: boolean
    playerId?: boolean
    parentId?: boolean
    assignedAt?: boolean
    removedAt?: boolean
    relationship?: boolean
    isPrimaryContact?: boolean
    canPickup?: boolean
    receivesNotifications?: boolean
    occupation?: boolean
    employer?: boolean
    workPhone?: boolean
    status?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelPlayerParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "playerId" | "parentId" | "assignedAt" | "removedAt" | "relationship" | "isPrimaryContact" | "canPickup" | "receivesNotifications" | "occupation" | "employer" | "workPhone" | "status" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relPlayerParent"]>

  export type $RelPlayerParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelPlayerParent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      playerId: Prisma.Decimal
      parentId: Prisma.Decimal
      assignedAt: Date | null
      removedAt: Date | null
      relationship: string | null
      isPrimaryContact: number
      canPickup: number
      receivesNotifications: number
      occupation: string | null
      employer: string | null
      workPhone: string | null
      status: string
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relPlayerParent"]>
    composites: {}
  }

  type RelPlayerParentGetPayload<S extends boolean | null | undefined | RelPlayerParentDefaultArgs> = $Result.GetResult<Prisma.$RelPlayerParentPayload, S>

  type RelPlayerParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelPlayerParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelPlayerParentCountAggregateInputType | true
    }

  export interface RelPlayerParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelPlayerParent'], meta: { name: 'RelPlayerParent' } }
    /**
     * Find zero or one RelPlayerParent that matches the filter.
     * @param {RelPlayerParentFindUniqueArgs} args - Arguments to find a RelPlayerParent
     * @example
     * // Get one RelPlayerParent
     * const relPlayerParent = await prisma.relPlayerParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelPlayerParentFindUniqueArgs>(args: SelectSubset<T, RelPlayerParentFindUniqueArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelPlayerParent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelPlayerParentFindUniqueOrThrowArgs} args - Arguments to find a RelPlayerParent
     * @example
     * // Get one RelPlayerParent
     * const relPlayerParent = await prisma.relPlayerParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelPlayerParentFindUniqueOrThrowArgs>(args: SelectSubset<T, RelPlayerParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelPlayerParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentFindFirstArgs} args - Arguments to find a RelPlayerParent
     * @example
     * // Get one RelPlayerParent
     * const relPlayerParent = await prisma.relPlayerParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelPlayerParentFindFirstArgs>(args?: SelectSubset<T, RelPlayerParentFindFirstArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelPlayerParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentFindFirstOrThrowArgs} args - Arguments to find a RelPlayerParent
     * @example
     * // Get one RelPlayerParent
     * const relPlayerParent = await prisma.relPlayerParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelPlayerParentFindFirstOrThrowArgs>(args?: SelectSubset<T, RelPlayerParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelPlayerParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelPlayerParents
     * const relPlayerParents = await prisma.relPlayerParent.findMany()
     * 
     * // Get first 10 RelPlayerParents
     * const relPlayerParents = await prisma.relPlayerParent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relPlayerParentWithIdOnly = await prisma.relPlayerParent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelPlayerParentFindManyArgs>(args?: SelectSubset<T, RelPlayerParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelPlayerParent.
     * @param {RelPlayerParentCreateArgs} args - Arguments to create a RelPlayerParent.
     * @example
     * // Create one RelPlayerParent
     * const RelPlayerParent = await prisma.relPlayerParent.create({
     *   data: {
     *     // ... data to create a RelPlayerParent
     *   }
     * })
     * 
     */
    create<T extends RelPlayerParentCreateArgs>(args: SelectSubset<T, RelPlayerParentCreateArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelPlayerParents.
     * @param {RelPlayerParentCreateManyArgs} args - Arguments to create many RelPlayerParents.
     * @example
     * // Create many RelPlayerParents
     * const relPlayerParent = await prisma.relPlayerParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelPlayerParentCreateManyArgs>(args?: SelectSubset<T, RelPlayerParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelPlayerParents and returns the data saved in the database.
     * @param {RelPlayerParentCreateManyAndReturnArgs} args - Arguments to create many RelPlayerParents.
     * @example
     * // Create many RelPlayerParents
     * const relPlayerParent = await prisma.relPlayerParent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelPlayerParents and only return the `id`
     * const relPlayerParentWithIdOnly = await prisma.relPlayerParent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelPlayerParentCreateManyAndReturnArgs>(args?: SelectSubset<T, RelPlayerParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelPlayerParent.
     * @param {RelPlayerParentDeleteArgs} args - Arguments to delete one RelPlayerParent.
     * @example
     * // Delete one RelPlayerParent
     * const RelPlayerParent = await prisma.relPlayerParent.delete({
     *   where: {
     *     // ... filter to delete one RelPlayerParent
     *   }
     * })
     * 
     */
    delete<T extends RelPlayerParentDeleteArgs>(args: SelectSubset<T, RelPlayerParentDeleteArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelPlayerParent.
     * @param {RelPlayerParentUpdateArgs} args - Arguments to update one RelPlayerParent.
     * @example
     * // Update one RelPlayerParent
     * const relPlayerParent = await prisma.relPlayerParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelPlayerParentUpdateArgs>(args: SelectSubset<T, RelPlayerParentUpdateArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelPlayerParents.
     * @param {RelPlayerParentDeleteManyArgs} args - Arguments to filter RelPlayerParents to delete.
     * @example
     * // Delete a few RelPlayerParents
     * const { count } = await prisma.relPlayerParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelPlayerParentDeleteManyArgs>(args?: SelectSubset<T, RelPlayerParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelPlayerParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelPlayerParents
     * const relPlayerParent = await prisma.relPlayerParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelPlayerParentUpdateManyArgs>(args: SelectSubset<T, RelPlayerParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelPlayerParents and returns the data updated in the database.
     * @param {RelPlayerParentUpdateManyAndReturnArgs} args - Arguments to update many RelPlayerParents.
     * @example
     * // Update many RelPlayerParents
     * const relPlayerParent = await prisma.relPlayerParent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelPlayerParents and only return the `id`
     * const relPlayerParentWithIdOnly = await prisma.relPlayerParent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelPlayerParentUpdateManyAndReturnArgs>(args: SelectSubset<T, RelPlayerParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelPlayerParent.
     * @param {RelPlayerParentUpsertArgs} args - Arguments to update or create a RelPlayerParent.
     * @example
     * // Update or create a RelPlayerParent
     * const relPlayerParent = await prisma.relPlayerParent.upsert({
     *   create: {
     *     // ... data to create a RelPlayerParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelPlayerParent we want to update
     *   }
     * })
     */
    upsert<T extends RelPlayerParentUpsertArgs>(args: SelectSubset<T, RelPlayerParentUpsertArgs<ExtArgs>>): Prisma__RelPlayerParentClient<$Result.GetResult<Prisma.$RelPlayerParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelPlayerParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentCountArgs} args - Arguments to filter RelPlayerParents to count.
     * @example
     * // Count the number of RelPlayerParents
     * const count = await prisma.relPlayerParent.count({
     *   where: {
     *     // ... the filter for the RelPlayerParents we want to count
     *   }
     * })
    **/
    count<T extends RelPlayerParentCountArgs>(
      args?: Subset<T, RelPlayerParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelPlayerParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelPlayerParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelPlayerParentAggregateArgs>(args: Subset<T, RelPlayerParentAggregateArgs>): Prisma.PrismaPromise<GetRelPlayerParentAggregateType<T>>

    /**
     * Group by RelPlayerParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelPlayerParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelPlayerParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelPlayerParentGroupByArgs['orderBy'] }
        : { orderBy?: RelPlayerParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelPlayerParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelPlayerParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelPlayerParent model
   */
  readonly fields: RelPlayerParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelPlayerParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelPlayerParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelPlayerParent model
   */
  interface RelPlayerParentFieldRefs {
    readonly id: FieldRef<"RelPlayerParent", 'Decimal'>
    readonly playerId: FieldRef<"RelPlayerParent", 'Decimal'>
    readonly parentId: FieldRef<"RelPlayerParent", 'Decimal'>
    readonly assignedAt: FieldRef<"RelPlayerParent", 'DateTime'>
    readonly removedAt: FieldRef<"RelPlayerParent", 'DateTime'>
    readonly relationship: FieldRef<"RelPlayerParent", 'String'>
    readonly isPrimaryContact: FieldRef<"RelPlayerParent", 'Int'>
    readonly canPickup: FieldRef<"RelPlayerParent", 'Int'>
    readonly receivesNotifications: FieldRef<"RelPlayerParent", 'Int'>
    readonly occupation: FieldRef<"RelPlayerParent", 'String'>
    readonly employer: FieldRef<"RelPlayerParent", 'String'>
    readonly workPhone: FieldRef<"RelPlayerParent", 'String'>
    readonly status: FieldRef<"RelPlayerParent", 'String'>
    readonly notes: FieldRef<"RelPlayerParent", 'String'>
    readonly ord: FieldRef<"RelPlayerParent", 'Int'>
    readonly createdAt: FieldRef<"RelPlayerParent", 'DateTime'>
    readonly updatedAt: FieldRef<"RelPlayerParent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelPlayerParent findUnique
   */
  export type RelPlayerParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * Filter, which RelPlayerParent to fetch.
     */
    where: RelPlayerParentWhereUniqueInput
  }

  /**
   * RelPlayerParent findUniqueOrThrow
   */
  export type RelPlayerParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * Filter, which RelPlayerParent to fetch.
     */
    where: RelPlayerParentWhereUniqueInput
  }

  /**
   * RelPlayerParent findFirst
   */
  export type RelPlayerParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * Filter, which RelPlayerParent to fetch.
     */
    where?: RelPlayerParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelPlayerParents to fetch.
     */
    orderBy?: RelPlayerParentOrderByWithRelationInput | RelPlayerParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelPlayerParents.
     */
    cursor?: RelPlayerParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelPlayerParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelPlayerParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelPlayerParents.
     */
    distinct?: RelPlayerParentScalarFieldEnum | RelPlayerParentScalarFieldEnum[]
  }

  /**
   * RelPlayerParent findFirstOrThrow
   */
  export type RelPlayerParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * Filter, which RelPlayerParent to fetch.
     */
    where?: RelPlayerParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelPlayerParents to fetch.
     */
    orderBy?: RelPlayerParentOrderByWithRelationInput | RelPlayerParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelPlayerParents.
     */
    cursor?: RelPlayerParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelPlayerParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelPlayerParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelPlayerParents.
     */
    distinct?: RelPlayerParentScalarFieldEnum | RelPlayerParentScalarFieldEnum[]
  }

  /**
   * RelPlayerParent findMany
   */
  export type RelPlayerParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * Filter, which RelPlayerParents to fetch.
     */
    where?: RelPlayerParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelPlayerParents to fetch.
     */
    orderBy?: RelPlayerParentOrderByWithRelationInput | RelPlayerParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelPlayerParents.
     */
    cursor?: RelPlayerParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelPlayerParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelPlayerParents.
     */
    skip?: number
    distinct?: RelPlayerParentScalarFieldEnum | RelPlayerParentScalarFieldEnum[]
  }

  /**
   * RelPlayerParent create
   */
  export type RelPlayerParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * The data needed to create a RelPlayerParent.
     */
    data: XOR<RelPlayerParentCreateInput, RelPlayerParentUncheckedCreateInput>
  }

  /**
   * RelPlayerParent createMany
   */
  export type RelPlayerParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelPlayerParents.
     */
    data: RelPlayerParentCreateManyInput | RelPlayerParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelPlayerParent createManyAndReturn
   */
  export type RelPlayerParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * The data used to create many RelPlayerParents.
     */
    data: RelPlayerParentCreateManyInput | RelPlayerParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelPlayerParent update
   */
  export type RelPlayerParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * The data needed to update a RelPlayerParent.
     */
    data: XOR<RelPlayerParentUpdateInput, RelPlayerParentUncheckedUpdateInput>
    /**
     * Choose, which RelPlayerParent to update.
     */
    where: RelPlayerParentWhereUniqueInput
  }

  /**
   * RelPlayerParent updateMany
   */
  export type RelPlayerParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelPlayerParents.
     */
    data: XOR<RelPlayerParentUpdateManyMutationInput, RelPlayerParentUncheckedUpdateManyInput>
    /**
     * Filter which RelPlayerParents to update
     */
    where?: RelPlayerParentWhereInput
    /**
     * Limit how many RelPlayerParents to update.
     */
    limit?: number
  }

  /**
   * RelPlayerParent updateManyAndReturn
   */
  export type RelPlayerParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * The data used to update RelPlayerParents.
     */
    data: XOR<RelPlayerParentUpdateManyMutationInput, RelPlayerParentUncheckedUpdateManyInput>
    /**
     * Filter which RelPlayerParents to update
     */
    where?: RelPlayerParentWhereInput
    /**
     * Limit how many RelPlayerParents to update.
     */
    limit?: number
  }

  /**
   * RelPlayerParent upsert
   */
  export type RelPlayerParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * The filter to search for the RelPlayerParent to update in case it exists.
     */
    where: RelPlayerParentWhereUniqueInput
    /**
     * In case the RelPlayerParent found by the `where` argument doesn't exist, create a new RelPlayerParent with this data.
     */
    create: XOR<RelPlayerParentCreateInput, RelPlayerParentUncheckedCreateInput>
    /**
     * In case the RelPlayerParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelPlayerParentUpdateInput, RelPlayerParentUncheckedUpdateInput>
  }

  /**
   * RelPlayerParent delete
   */
  export type RelPlayerParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
    /**
     * Filter which RelPlayerParent to delete.
     */
    where: RelPlayerParentWhereUniqueInput
  }

  /**
   * RelPlayerParent deleteMany
   */
  export type RelPlayerParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelPlayerParents to delete
     */
    where?: RelPlayerParentWhereInput
    /**
     * Limit how many RelPlayerParents to delete.
     */
    limit?: number
  }

  /**
   * RelPlayerParent without action
   */
  export type RelPlayerParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelPlayerParent
     */
    select?: RelPlayerParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelPlayerParent
     */
    omit?: RelPlayerParentOmit<ExtArgs> | null
  }


  /**
   * Model RelSponsorClub
   */

  export type AggregateRelSponsorClub = {
    _count: RelSponsorClubCountAggregateOutputType | null
    _avg: RelSponsorClubAvgAggregateOutputType | null
    _sum: RelSponsorClubSumAggregateOutputType | null
    _min: RelSponsorClubMinAggregateOutputType | null
    _max: RelSponsorClubMaxAggregateOutputType | null
  }

  export type RelSponsorClubAvgAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    clubId: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type RelSponsorClubSumAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    clubId: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type RelSponsorClubMinAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    clubId: Decimal | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelSponsorClubMaxAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    clubId: Decimal | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelSponsorClubCountAggregateOutputType = {
    id: number
    sponsorId: number
    clubId: number
    startedAt: number
    endedAt: number
    status: number
    sponsorshipAmount: number
    benefits: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelSponsorClubAvgAggregateInputType = {
    id?: true
    sponsorId?: true
    clubId?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type RelSponsorClubSumAggregateInputType = {
    id?: true
    sponsorId?: true
    clubId?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type RelSponsorClubMinAggregateInputType = {
    id?: true
    sponsorId?: true
    clubId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelSponsorClubMaxAggregateInputType = {
    id?: true
    sponsorId?: true
    clubId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelSponsorClubCountAggregateInputType = {
    id?: true
    sponsorId?: true
    clubId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelSponsorClubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelSponsorClub to aggregate.
     */
    where?: RelSponsorClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorClubs to fetch.
     */
    orderBy?: RelSponsorClubOrderByWithRelationInput | RelSponsorClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelSponsorClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorClubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelSponsorClubs
    **/
    _count?: true | RelSponsorClubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelSponsorClubAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelSponsorClubSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelSponsorClubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelSponsorClubMaxAggregateInputType
  }

  export type GetRelSponsorClubAggregateType<T extends RelSponsorClubAggregateArgs> = {
        [P in keyof T & keyof AggregateRelSponsorClub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelSponsorClub[P]>
      : GetScalarType<T[P], AggregateRelSponsorClub[P]>
  }




  export type RelSponsorClubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelSponsorClubWhereInput
    orderBy?: RelSponsorClubOrderByWithAggregationInput | RelSponsorClubOrderByWithAggregationInput[]
    by: RelSponsorClubScalarFieldEnum[] | RelSponsorClubScalarFieldEnum
    having?: RelSponsorClubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelSponsorClubCountAggregateInputType | true
    _avg?: RelSponsorClubAvgAggregateInputType
    _sum?: RelSponsorClubSumAggregateInputType
    _min?: RelSponsorClubMinAggregateInputType
    _max?: RelSponsorClubMaxAggregateInputType
  }

  export type RelSponsorClubGroupByOutputType = {
    id: Decimal
    sponsorId: Decimal
    clubId: Decimal
    startedAt: Date | null
    endedAt: Date | null
    status: string
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelSponsorClubCountAggregateOutputType | null
    _avg: RelSponsorClubAvgAggregateOutputType | null
    _sum: RelSponsorClubSumAggregateOutputType | null
    _min: RelSponsorClubMinAggregateOutputType | null
    _max: RelSponsorClubMaxAggregateOutputType | null
  }

  type GetRelSponsorClubGroupByPayload<T extends RelSponsorClubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelSponsorClubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelSponsorClubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelSponsorClubGroupByOutputType[P]>
            : GetScalarType<T[P], RelSponsorClubGroupByOutputType[P]>
        }
      >
    >


  export type RelSponsorClubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    clubId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorClub"]>

  export type RelSponsorClubSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    clubId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorClub"]>

  export type RelSponsorClubSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    clubId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorClub"]>

  export type RelSponsorClubSelectScalar = {
    id?: boolean
    sponsorId?: boolean
    clubId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelSponsorClubOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sponsorId" | "clubId" | "startedAt" | "endedAt" | "status" | "sponsorshipAmount" | "benefits" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relSponsorClub"]>

  export type $RelSponsorClubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelSponsorClub"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sponsorId: Prisma.Decimal
      clubId: Prisma.Decimal
      startedAt: Date | null
      endedAt: Date | null
      status: string
      sponsorshipAmount: Prisma.Decimal | null
      benefits: string | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relSponsorClub"]>
    composites: {}
  }

  type RelSponsorClubGetPayload<S extends boolean | null | undefined | RelSponsorClubDefaultArgs> = $Result.GetResult<Prisma.$RelSponsorClubPayload, S>

  type RelSponsorClubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelSponsorClubFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelSponsorClubCountAggregateInputType | true
    }

  export interface RelSponsorClubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelSponsorClub'], meta: { name: 'RelSponsorClub' } }
    /**
     * Find zero or one RelSponsorClub that matches the filter.
     * @param {RelSponsorClubFindUniqueArgs} args - Arguments to find a RelSponsorClub
     * @example
     * // Get one RelSponsorClub
     * const relSponsorClub = await prisma.relSponsorClub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelSponsorClubFindUniqueArgs>(args: SelectSubset<T, RelSponsorClubFindUniqueArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelSponsorClub that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelSponsorClubFindUniqueOrThrowArgs} args - Arguments to find a RelSponsorClub
     * @example
     * // Get one RelSponsorClub
     * const relSponsorClub = await prisma.relSponsorClub.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelSponsorClubFindUniqueOrThrowArgs>(args: SelectSubset<T, RelSponsorClubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelSponsorClub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubFindFirstArgs} args - Arguments to find a RelSponsorClub
     * @example
     * // Get one RelSponsorClub
     * const relSponsorClub = await prisma.relSponsorClub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelSponsorClubFindFirstArgs>(args?: SelectSubset<T, RelSponsorClubFindFirstArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelSponsorClub that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubFindFirstOrThrowArgs} args - Arguments to find a RelSponsorClub
     * @example
     * // Get one RelSponsorClub
     * const relSponsorClub = await prisma.relSponsorClub.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelSponsorClubFindFirstOrThrowArgs>(args?: SelectSubset<T, RelSponsorClubFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelSponsorClubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelSponsorClubs
     * const relSponsorClubs = await prisma.relSponsorClub.findMany()
     * 
     * // Get first 10 RelSponsorClubs
     * const relSponsorClubs = await prisma.relSponsorClub.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relSponsorClubWithIdOnly = await prisma.relSponsorClub.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelSponsorClubFindManyArgs>(args?: SelectSubset<T, RelSponsorClubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelSponsorClub.
     * @param {RelSponsorClubCreateArgs} args - Arguments to create a RelSponsorClub.
     * @example
     * // Create one RelSponsorClub
     * const RelSponsorClub = await prisma.relSponsorClub.create({
     *   data: {
     *     // ... data to create a RelSponsorClub
     *   }
     * })
     * 
     */
    create<T extends RelSponsorClubCreateArgs>(args: SelectSubset<T, RelSponsorClubCreateArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelSponsorClubs.
     * @param {RelSponsorClubCreateManyArgs} args - Arguments to create many RelSponsorClubs.
     * @example
     * // Create many RelSponsorClubs
     * const relSponsorClub = await prisma.relSponsorClub.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelSponsorClubCreateManyArgs>(args?: SelectSubset<T, RelSponsorClubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelSponsorClubs and returns the data saved in the database.
     * @param {RelSponsorClubCreateManyAndReturnArgs} args - Arguments to create many RelSponsorClubs.
     * @example
     * // Create many RelSponsorClubs
     * const relSponsorClub = await prisma.relSponsorClub.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelSponsorClubs and only return the `id`
     * const relSponsorClubWithIdOnly = await prisma.relSponsorClub.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelSponsorClubCreateManyAndReturnArgs>(args?: SelectSubset<T, RelSponsorClubCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelSponsorClub.
     * @param {RelSponsorClubDeleteArgs} args - Arguments to delete one RelSponsorClub.
     * @example
     * // Delete one RelSponsorClub
     * const RelSponsorClub = await prisma.relSponsorClub.delete({
     *   where: {
     *     // ... filter to delete one RelSponsorClub
     *   }
     * })
     * 
     */
    delete<T extends RelSponsorClubDeleteArgs>(args: SelectSubset<T, RelSponsorClubDeleteArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelSponsorClub.
     * @param {RelSponsorClubUpdateArgs} args - Arguments to update one RelSponsorClub.
     * @example
     * // Update one RelSponsorClub
     * const relSponsorClub = await prisma.relSponsorClub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelSponsorClubUpdateArgs>(args: SelectSubset<T, RelSponsorClubUpdateArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelSponsorClubs.
     * @param {RelSponsorClubDeleteManyArgs} args - Arguments to filter RelSponsorClubs to delete.
     * @example
     * // Delete a few RelSponsorClubs
     * const { count } = await prisma.relSponsorClub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelSponsorClubDeleteManyArgs>(args?: SelectSubset<T, RelSponsorClubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelSponsorClubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelSponsorClubs
     * const relSponsorClub = await prisma.relSponsorClub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelSponsorClubUpdateManyArgs>(args: SelectSubset<T, RelSponsorClubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelSponsorClubs and returns the data updated in the database.
     * @param {RelSponsorClubUpdateManyAndReturnArgs} args - Arguments to update many RelSponsorClubs.
     * @example
     * // Update many RelSponsorClubs
     * const relSponsorClub = await prisma.relSponsorClub.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelSponsorClubs and only return the `id`
     * const relSponsorClubWithIdOnly = await prisma.relSponsorClub.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelSponsorClubUpdateManyAndReturnArgs>(args: SelectSubset<T, RelSponsorClubUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelSponsorClub.
     * @param {RelSponsorClubUpsertArgs} args - Arguments to update or create a RelSponsorClub.
     * @example
     * // Update or create a RelSponsorClub
     * const relSponsorClub = await prisma.relSponsorClub.upsert({
     *   create: {
     *     // ... data to create a RelSponsorClub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelSponsorClub we want to update
     *   }
     * })
     */
    upsert<T extends RelSponsorClubUpsertArgs>(args: SelectSubset<T, RelSponsorClubUpsertArgs<ExtArgs>>): Prisma__RelSponsorClubClient<$Result.GetResult<Prisma.$RelSponsorClubPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelSponsorClubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubCountArgs} args - Arguments to filter RelSponsorClubs to count.
     * @example
     * // Count the number of RelSponsorClubs
     * const count = await prisma.relSponsorClub.count({
     *   where: {
     *     // ... the filter for the RelSponsorClubs we want to count
     *   }
     * })
    **/
    count<T extends RelSponsorClubCountArgs>(
      args?: Subset<T, RelSponsorClubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelSponsorClubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelSponsorClub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelSponsorClubAggregateArgs>(args: Subset<T, RelSponsorClubAggregateArgs>): Prisma.PrismaPromise<GetRelSponsorClubAggregateType<T>>

    /**
     * Group by RelSponsorClub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorClubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelSponsorClubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelSponsorClubGroupByArgs['orderBy'] }
        : { orderBy?: RelSponsorClubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelSponsorClubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelSponsorClubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelSponsorClub model
   */
  readonly fields: RelSponsorClubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelSponsorClub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelSponsorClubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelSponsorClub model
   */
  interface RelSponsorClubFieldRefs {
    readonly id: FieldRef<"RelSponsorClub", 'Decimal'>
    readonly sponsorId: FieldRef<"RelSponsorClub", 'Decimal'>
    readonly clubId: FieldRef<"RelSponsorClub", 'Decimal'>
    readonly startedAt: FieldRef<"RelSponsorClub", 'DateTime'>
    readonly endedAt: FieldRef<"RelSponsorClub", 'DateTime'>
    readonly status: FieldRef<"RelSponsorClub", 'String'>
    readonly sponsorshipAmount: FieldRef<"RelSponsorClub", 'Decimal'>
    readonly benefits: FieldRef<"RelSponsorClub", 'String'>
    readonly notes: FieldRef<"RelSponsorClub", 'String'>
    readonly ord: FieldRef<"RelSponsorClub", 'Int'>
    readonly createdAt: FieldRef<"RelSponsorClub", 'DateTime'>
    readonly updatedAt: FieldRef<"RelSponsorClub", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelSponsorClub findUnique
   */
  export type RelSponsorClubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorClub to fetch.
     */
    where: RelSponsorClubWhereUniqueInput
  }

  /**
   * RelSponsorClub findUniqueOrThrow
   */
  export type RelSponsorClubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorClub to fetch.
     */
    where: RelSponsorClubWhereUniqueInput
  }

  /**
   * RelSponsorClub findFirst
   */
  export type RelSponsorClubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorClub to fetch.
     */
    where?: RelSponsorClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorClubs to fetch.
     */
    orderBy?: RelSponsorClubOrderByWithRelationInput | RelSponsorClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelSponsorClubs.
     */
    cursor?: RelSponsorClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorClubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelSponsorClubs.
     */
    distinct?: RelSponsorClubScalarFieldEnum | RelSponsorClubScalarFieldEnum[]
  }

  /**
   * RelSponsorClub findFirstOrThrow
   */
  export type RelSponsorClubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorClub to fetch.
     */
    where?: RelSponsorClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorClubs to fetch.
     */
    orderBy?: RelSponsorClubOrderByWithRelationInput | RelSponsorClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelSponsorClubs.
     */
    cursor?: RelSponsorClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorClubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelSponsorClubs.
     */
    distinct?: RelSponsorClubScalarFieldEnum | RelSponsorClubScalarFieldEnum[]
  }

  /**
   * RelSponsorClub findMany
   */
  export type RelSponsorClubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorClubs to fetch.
     */
    where?: RelSponsorClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorClubs to fetch.
     */
    orderBy?: RelSponsorClubOrderByWithRelationInput | RelSponsorClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelSponsorClubs.
     */
    cursor?: RelSponsorClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorClubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorClubs.
     */
    skip?: number
    distinct?: RelSponsorClubScalarFieldEnum | RelSponsorClubScalarFieldEnum[]
  }

  /**
   * RelSponsorClub create
   */
  export type RelSponsorClubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * The data needed to create a RelSponsorClub.
     */
    data: XOR<RelSponsorClubCreateInput, RelSponsorClubUncheckedCreateInput>
  }

  /**
   * RelSponsorClub createMany
   */
  export type RelSponsorClubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelSponsorClubs.
     */
    data: RelSponsorClubCreateManyInput | RelSponsorClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelSponsorClub createManyAndReturn
   */
  export type RelSponsorClubCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * The data used to create many RelSponsorClubs.
     */
    data: RelSponsorClubCreateManyInput | RelSponsorClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelSponsorClub update
   */
  export type RelSponsorClubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * The data needed to update a RelSponsorClub.
     */
    data: XOR<RelSponsorClubUpdateInput, RelSponsorClubUncheckedUpdateInput>
    /**
     * Choose, which RelSponsorClub to update.
     */
    where: RelSponsorClubWhereUniqueInput
  }

  /**
   * RelSponsorClub updateMany
   */
  export type RelSponsorClubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelSponsorClubs.
     */
    data: XOR<RelSponsorClubUpdateManyMutationInput, RelSponsorClubUncheckedUpdateManyInput>
    /**
     * Filter which RelSponsorClubs to update
     */
    where?: RelSponsorClubWhereInput
    /**
     * Limit how many RelSponsorClubs to update.
     */
    limit?: number
  }

  /**
   * RelSponsorClub updateManyAndReturn
   */
  export type RelSponsorClubUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * The data used to update RelSponsorClubs.
     */
    data: XOR<RelSponsorClubUpdateManyMutationInput, RelSponsorClubUncheckedUpdateManyInput>
    /**
     * Filter which RelSponsorClubs to update
     */
    where?: RelSponsorClubWhereInput
    /**
     * Limit how many RelSponsorClubs to update.
     */
    limit?: number
  }

  /**
   * RelSponsorClub upsert
   */
  export type RelSponsorClubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * The filter to search for the RelSponsorClub to update in case it exists.
     */
    where: RelSponsorClubWhereUniqueInput
    /**
     * In case the RelSponsorClub found by the `where` argument doesn't exist, create a new RelSponsorClub with this data.
     */
    create: XOR<RelSponsorClubCreateInput, RelSponsorClubUncheckedCreateInput>
    /**
     * In case the RelSponsorClub was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelSponsorClubUpdateInput, RelSponsorClubUncheckedUpdateInput>
  }

  /**
   * RelSponsorClub delete
   */
  export type RelSponsorClubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
    /**
     * Filter which RelSponsorClub to delete.
     */
    where: RelSponsorClubWhereUniqueInput
  }

  /**
   * RelSponsorClub deleteMany
   */
  export type RelSponsorClubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelSponsorClubs to delete
     */
    where?: RelSponsorClubWhereInput
    /**
     * Limit how many RelSponsorClubs to delete.
     */
    limit?: number
  }

  /**
   * RelSponsorClub without action
   */
  export type RelSponsorClubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorClub
     */
    select?: RelSponsorClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorClub
     */
    omit?: RelSponsorClubOmit<ExtArgs> | null
  }


  /**
   * Model RelSponsorLeague
   */

  export type AggregateRelSponsorLeague = {
    _count: RelSponsorLeagueCountAggregateOutputType | null
    _avg: RelSponsorLeagueAvgAggregateOutputType | null
    _sum: RelSponsorLeagueSumAggregateOutputType | null
    _min: RelSponsorLeagueMinAggregateOutputType | null
    _max: RelSponsorLeagueMaxAggregateOutputType | null
  }

  export type RelSponsorLeagueAvgAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    leagueId: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type RelSponsorLeagueSumAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    leagueId: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type RelSponsorLeagueMinAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    leagueId: Decimal | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelSponsorLeagueMaxAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    leagueId: Decimal | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelSponsorLeagueCountAggregateOutputType = {
    id: number
    sponsorId: number
    leagueId: number
    startedAt: number
    endedAt: number
    status: number
    sponsorshipAmount: number
    benefits: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelSponsorLeagueAvgAggregateInputType = {
    id?: true
    sponsorId?: true
    leagueId?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type RelSponsorLeagueSumAggregateInputType = {
    id?: true
    sponsorId?: true
    leagueId?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type RelSponsorLeagueMinAggregateInputType = {
    id?: true
    sponsorId?: true
    leagueId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelSponsorLeagueMaxAggregateInputType = {
    id?: true
    sponsorId?: true
    leagueId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelSponsorLeagueCountAggregateInputType = {
    id?: true
    sponsorId?: true
    leagueId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelSponsorLeagueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelSponsorLeague to aggregate.
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorLeagues to fetch.
     */
    orderBy?: RelSponsorLeagueOrderByWithRelationInput | RelSponsorLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelSponsorLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorLeagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelSponsorLeagues
    **/
    _count?: true | RelSponsorLeagueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelSponsorLeagueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelSponsorLeagueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelSponsorLeagueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelSponsorLeagueMaxAggregateInputType
  }

  export type GetRelSponsorLeagueAggregateType<T extends RelSponsorLeagueAggregateArgs> = {
        [P in keyof T & keyof AggregateRelSponsorLeague]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelSponsorLeague[P]>
      : GetScalarType<T[P], AggregateRelSponsorLeague[P]>
  }




  export type RelSponsorLeagueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelSponsorLeagueWhereInput
    orderBy?: RelSponsorLeagueOrderByWithAggregationInput | RelSponsorLeagueOrderByWithAggregationInput[]
    by: RelSponsorLeagueScalarFieldEnum[] | RelSponsorLeagueScalarFieldEnum
    having?: RelSponsorLeagueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelSponsorLeagueCountAggregateInputType | true
    _avg?: RelSponsorLeagueAvgAggregateInputType
    _sum?: RelSponsorLeagueSumAggregateInputType
    _min?: RelSponsorLeagueMinAggregateInputType
    _max?: RelSponsorLeagueMaxAggregateInputType
  }

  export type RelSponsorLeagueGroupByOutputType = {
    id: Decimal
    sponsorId: Decimal
    leagueId: Decimal
    startedAt: Date | null
    endedAt: Date | null
    status: string
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelSponsorLeagueCountAggregateOutputType | null
    _avg: RelSponsorLeagueAvgAggregateOutputType | null
    _sum: RelSponsorLeagueSumAggregateOutputType | null
    _min: RelSponsorLeagueMinAggregateOutputType | null
    _max: RelSponsorLeagueMaxAggregateOutputType | null
  }

  type GetRelSponsorLeagueGroupByPayload<T extends RelSponsorLeagueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelSponsorLeagueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelSponsorLeagueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelSponsorLeagueGroupByOutputType[P]>
            : GetScalarType<T[P], RelSponsorLeagueGroupByOutputType[P]>
        }
      >
    >


  export type RelSponsorLeagueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    leagueId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorLeague"]>

  export type RelSponsorLeagueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    leagueId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorLeague"]>

  export type RelSponsorLeagueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    leagueId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorLeague"]>

  export type RelSponsorLeagueSelectScalar = {
    id?: boolean
    sponsorId?: boolean
    leagueId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelSponsorLeagueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sponsorId" | "leagueId" | "startedAt" | "endedAt" | "status" | "sponsorshipAmount" | "benefits" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relSponsorLeague"]>

  export type $RelSponsorLeaguePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelSponsorLeague"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sponsorId: Prisma.Decimal
      leagueId: Prisma.Decimal
      startedAt: Date | null
      endedAt: Date | null
      status: string
      sponsorshipAmount: Prisma.Decimal | null
      benefits: string | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relSponsorLeague"]>
    composites: {}
  }

  type RelSponsorLeagueGetPayload<S extends boolean | null | undefined | RelSponsorLeagueDefaultArgs> = $Result.GetResult<Prisma.$RelSponsorLeaguePayload, S>

  type RelSponsorLeagueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelSponsorLeagueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelSponsorLeagueCountAggregateInputType | true
    }

  export interface RelSponsorLeagueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelSponsorLeague'], meta: { name: 'RelSponsorLeague' } }
    /**
     * Find zero or one RelSponsorLeague that matches the filter.
     * @param {RelSponsorLeagueFindUniqueArgs} args - Arguments to find a RelSponsorLeague
     * @example
     * // Get one RelSponsorLeague
     * const relSponsorLeague = await prisma.relSponsorLeague.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelSponsorLeagueFindUniqueArgs>(args: SelectSubset<T, RelSponsorLeagueFindUniqueArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelSponsorLeague that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelSponsorLeagueFindUniqueOrThrowArgs} args - Arguments to find a RelSponsorLeague
     * @example
     * // Get one RelSponsorLeague
     * const relSponsorLeague = await prisma.relSponsorLeague.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelSponsorLeagueFindUniqueOrThrowArgs>(args: SelectSubset<T, RelSponsorLeagueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelSponsorLeague that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueFindFirstArgs} args - Arguments to find a RelSponsorLeague
     * @example
     * // Get one RelSponsorLeague
     * const relSponsorLeague = await prisma.relSponsorLeague.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelSponsorLeagueFindFirstArgs>(args?: SelectSubset<T, RelSponsorLeagueFindFirstArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelSponsorLeague that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueFindFirstOrThrowArgs} args - Arguments to find a RelSponsorLeague
     * @example
     * // Get one RelSponsorLeague
     * const relSponsorLeague = await prisma.relSponsorLeague.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelSponsorLeagueFindFirstOrThrowArgs>(args?: SelectSubset<T, RelSponsorLeagueFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelSponsorLeagues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelSponsorLeagues
     * const relSponsorLeagues = await prisma.relSponsorLeague.findMany()
     * 
     * // Get first 10 RelSponsorLeagues
     * const relSponsorLeagues = await prisma.relSponsorLeague.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relSponsorLeagueWithIdOnly = await prisma.relSponsorLeague.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelSponsorLeagueFindManyArgs>(args?: SelectSubset<T, RelSponsorLeagueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelSponsorLeague.
     * @param {RelSponsorLeagueCreateArgs} args - Arguments to create a RelSponsorLeague.
     * @example
     * // Create one RelSponsorLeague
     * const RelSponsorLeague = await prisma.relSponsorLeague.create({
     *   data: {
     *     // ... data to create a RelSponsorLeague
     *   }
     * })
     * 
     */
    create<T extends RelSponsorLeagueCreateArgs>(args: SelectSubset<T, RelSponsorLeagueCreateArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelSponsorLeagues.
     * @param {RelSponsorLeagueCreateManyArgs} args - Arguments to create many RelSponsorLeagues.
     * @example
     * // Create many RelSponsorLeagues
     * const relSponsorLeague = await prisma.relSponsorLeague.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelSponsorLeagueCreateManyArgs>(args?: SelectSubset<T, RelSponsorLeagueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelSponsorLeagues and returns the data saved in the database.
     * @param {RelSponsorLeagueCreateManyAndReturnArgs} args - Arguments to create many RelSponsorLeagues.
     * @example
     * // Create many RelSponsorLeagues
     * const relSponsorLeague = await prisma.relSponsorLeague.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelSponsorLeagues and only return the `id`
     * const relSponsorLeagueWithIdOnly = await prisma.relSponsorLeague.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelSponsorLeagueCreateManyAndReturnArgs>(args?: SelectSubset<T, RelSponsorLeagueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelSponsorLeague.
     * @param {RelSponsorLeagueDeleteArgs} args - Arguments to delete one RelSponsorLeague.
     * @example
     * // Delete one RelSponsorLeague
     * const RelSponsorLeague = await prisma.relSponsorLeague.delete({
     *   where: {
     *     // ... filter to delete one RelSponsorLeague
     *   }
     * })
     * 
     */
    delete<T extends RelSponsorLeagueDeleteArgs>(args: SelectSubset<T, RelSponsorLeagueDeleteArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelSponsorLeague.
     * @param {RelSponsorLeagueUpdateArgs} args - Arguments to update one RelSponsorLeague.
     * @example
     * // Update one RelSponsorLeague
     * const relSponsorLeague = await prisma.relSponsorLeague.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelSponsorLeagueUpdateArgs>(args: SelectSubset<T, RelSponsorLeagueUpdateArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelSponsorLeagues.
     * @param {RelSponsorLeagueDeleteManyArgs} args - Arguments to filter RelSponsorLeagues to delete.
     * @example
     * // Delete a few RelSponsorLeagues
     * const { count } = await prisma.relSponsorLeague.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelSponsorLeagueDeleteManyArgs>(args?: SelectSubset<T, RelSponsorLeagueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelSponsorLeagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelSponsorLeagues
     * const relSponsorLeague = await prisma.relSponsorLeague.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelSponsorLeagueUpdateManyArgs>(args: SelectSubset<T, RelSponsorLeagueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelSponsorLeagues and returns the data updated in the database.
     * @param {RelSponsorLeagueUpdateManyAndReturnArgs} args - Arguments to update many RelSponsorLeagues.
     * @example
     * // Update many RelSponsorLeagues
     * const relSponsorLeague = await prisma.relSponsorLeague.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelSponsorLeagues and only return the `id`
     * const relSponsorLeagueWithIdOnly = await prisma.relSponsorLeague.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelSponsorLeagueUpdateManyAndReturnArgs>(args: SelectSubset<T, RelSponsorLeagueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelSponsorLeague.
     * @param {RelSponsorLeagueUpsertArgs} args - Arguments to update or create a RelSponsorLeague.
     * @example
     * // Update or create a RelSponsorLeague
     * const relSponsorLeague = await prisma.relSponsorLeague.upsert({
     *   create: {
     *     // ... data to create a RelSponsorLeague
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelSponsorLeague we want to update
     *   }
     * })
     */
    upsert<T extends RelSponsorLeagueUpsertArgs>(args: SelectSubset<T, RelSponsorLeagueUpsertArgs<ExtArgs>>): Prisma__RelSponsorLeagueClient<$Result.GetResult<Prisma.$RelSponsorLeaguePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelSponsorLeagues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueCountArgs} args - Arguments to filter RelSponsorLeagues to count.
     * @example
     * // Count the number of RelSponsorLeagues
     * const count = await prisma.relSponsorLeague.count({
     *   where: {
     *     // ... the filter for the RelSponsorLeagues we want to count
     *   }
     * })
    **/
    count<T extends RelSponsorLeagueCountArgs>(
      args?: Subset<T, RelSponsorLeagueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelSponsorLeagueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelSponsorLeague.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelSponsorLeagueAggregateArgs>(args: Subset<T, RelSponsorLeagueAggregateArgs>): Prisma.PrismaPromise<GetRelSponsorLeagueAggregateType<T>>

    /**
     * Group by RelSponsorLeague.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorLeagueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelSponsorLeagueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelSponsorLeagueGroupByArgs['orderBy'] }
        : { orderBy?: RelSponsorLeagueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelSponsorLeagueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelSponsorLeagueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelSponsorLeague model
   */
  readonly fields: RelSponsorLeagueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelSponsorLeague.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelSponsorLeagueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelSponsorLeague model
   */
  interface RelSponsorLeagueFieldRefs {
    readonly id: FieldRef<"RelSponsorLeague", 'Decimal'>
    readonly sponsorId: FieldRef<"RelSponsorLeague", 'Decimal'>
    readonly leagueId: FieldRef<"RelSponsorLeague", 'Decimal'>
    readonly startedAt: FieldRef<"RelSponsorLeague", 'DateTime'>
    readonly endedAt: FieldRef<"RelSponsorLeague", 'DateTime'>
    readonly status: FieldRef<"RelSponsorLeague", 'String'>
    readonly sponsorshipAmount: FieldRef<"RelSponsorLeague", 'Decimal'>
    readonly benefits: FieldRef<"RelSponsorLeague", 'String'>
    readonly notes: FieldRef<"RelSponsorLeague", 'String'>
    readonly ord: FieldRef<"RelSponsorLeague", 'Int'>
    readonly createdAt: FieldRef<"RelSponsorLeague", 'DateTime'>
    readonly updatedAt: FieldRef<"RelSponsorLeague", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelSponsorLeague findUnique
   */
  export type RelSponsorLeagueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorLeague to fetch.
     */
    where: RelSponsorLeagueWhereUniqueInput
  }

  /**
   * RelSponsorLeague findUniqueOrThrow
   */
  export type RelSponsorLeagueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorLeague to fetch.
     */
    where: RelSponsorLeagueWhereUniqueInput
  }

  /**
   * RelSponsorLeague findFirst
   */
  export type RelSponsorLeagueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorLeague to fetch.
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorLeagues to fetch.
     */
    orderBy?: RelSponsorLeagueOrderByWithRelationInput | RelSponsorLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelSponsorLeagues.
     */
    cursor?: RelSponsorLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorLeagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelSponsorLeagues.
     */
    distinct?: RelSponsorLeagueScalarFieldEnum | RelSponsorLeagueScalarFieldEnum[]
  }

  /**
   * RelSponsorLeague findFirstOrThrow
   */
  export type RelSponsorLeagueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorLeague to fetch.
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorLeagues to fetch.
     */
    orderBy?: RelSponsorLeagueOrderByWithRelationInput | RelSponsorLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelSponsorLeagues.
     */
    cursor?: RelSponsorLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorLeagues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelSponsorLeagues.
     */
    distinct?: RelSponsorLeagueScalarFieldEnum | RelSponsorLeagueScalarFieldEnum[]
  }

  /**
   * RelSponsorLeague findMany
   */
  export type RelSponsorLeagueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorLeagues to fetch.
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorLeagues to fetch.
     */
    orderBy?: RelSponsorLeagueOrderByWithRelationInput | RelSponsorLeagueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelSponsorLeagues.
     */
    cursor?: RelSponsorLeagueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorLeagues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorLeagues.
     */
    skip?: number
    distinct?: RelSponsorLeagueScalarFieldEnum | RelSponsorLeagueScalarFieldEnum[]
  }

  /**
   * RelSponsorLeague create
   */
  export type RelSponsorLeagueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * The data needed to create a RelSponsorLeague.
     */
    data: XOR<RelSponsorLeagueCreateInput, RelSponsorLeagueUncheckedCreateInput>
  }

  /**
   * RelSponsorLeague createMany
   */
  export type RelSponsorLeagueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelSponsorLeagues.
     */
    data: RelSponsorLeagueCreateManyInput | RelSponsorLeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelSponsorLeague createManyAndReturn
   */
  export type RelSponsorLeagueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * The data used to create many RelSponsorLeagues.
     */
    data: RelSponsorLeagueCreateManyInput | RelSponsorLeagueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelSponsorLeague update
   */
  export type RelSponsorLeagueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * The data needed to update a RelSponsorLeague.
     */
    data: XOR<RelSponsorLeagueUpdateInput, RelSponsorLeagueUncheckedUpdateInput>
    /**
     * Choose, which RelSponsorLeague to update.
     */
    where: RelSponsorLeagueWhereUniqueInput
  }

  /**
   * RelSponsorLeague updateMany
   */
  export type RelSponsorLeagueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelSponsorLeagues.
     */
    data: XOR<RelSponsorLeagueUpdateManyMutationInput, RelSponsorLeagueUncheckedUpdateManyInput>
    /**
     * Filter which RelSponsorLeagues to update
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * Limit how many RelSponsorLeagues to update.
     */
    limit?: number
  }

  /**
   * RelSponsorLeague updateManyAndReturn
   */
  export type RelSponsorLeagueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * The data used to update RelSponsorLeagues.
     */
    data: XOR<RelSponsorLeagueUpdateManyMutationInput, RelSponsorLeagueUncheckedUpdateManyInput>
    /**
     * Filter which RelSponsorLeagues to update
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * Limit how many RelSponsorLeagues to update.
     */
    limit?: number
  }

  /**
   * RelSponsorLeague upsert
   */
  export type RelSponsorLeagueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * The filter to search for the RelSponsorLeague to update in case it exists.
     */
    where: RelSponsorLeagueWhereUniqueInput
    /**
     * In case the RelSponsorLeague found by the `where` argument doesn't exist, create a new RelSponsorLeague with this data.
     */
    create: XOR<RelSponsorLeagueCreateInput, RelSponsorLeagueUncheckedCreateInput>
    /**
     * In case the RelSponsorLeague was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelSponsorLeagueUpdateInput, RelSponsorLeagueUncheckedUpdateInput>
  }

  /**
   * RelSponsorLeague delete
   */
  export type RelSponsorLeagueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
    /**
     * Filter which RelSponsorLeague to delete.
     */
    where: RelSponsorLeagueWhereUniqueInput
  }

  /**
   * RelSponsorLeague deleteMany
   */
  export type RelSponsorLeagueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelSponsorLeagues to delete
     */
    where?: RelSponsorLeagueWhereInput
    /**
     * Limit how many RelSponsorLeagues to delete.
     */
    limit?: number
  }

  /**
   * RelSponsorLeague without action
   */
  export type RelSponsorLeagueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorLeague
     */
    select?: RelSponsorLeagueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorLeague
     */
    omit?: RelSponsorLeagueOmit<ExtArgs> | null
  }


  /**
   * Model RelSponsorTeam
   */

  export type AggregateRelSponsorTeam = {
    _count: RelSponsorTeamCountAggregateOutputType | null
    _avg: RelSponsorTeamAvgAggregateOutputType | null
    _sum: RelSponsorTeamSumAggregateOutputType | null
    _min: RelSponsorTeamMinAggregateOutputType | null
    _max: RelSponsorTeamMaxAggregateOutputType | null
  }

  export type RelSponsorTeamAvgAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    teamId: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type RelSponsorTeamSumAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    teamId: Decimal | null
    sponsorshipAmount: Decimal | null
    ord: number | null
  }

  export type RelSponsorTeamMinAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    teamId: Decimal | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelSponsorTeamMaxAggregateOutputType = {
    id: Decimal | null
    sponsorId: Decimal | null
    teamId: Decimal | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelSponsorTeamCountAggregateOutputType = {
    id: number
    sponsorId: number
    teamId: number
    startedAt: number
    endedAt: number
    status: number
    sponsorshipAmount: number
    benefits: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelSponsorTeamAvgAggregateInputType = {
    id?: true
    sponsorId?: true
    teamId?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type RelSponsorTeamSumAggregateInputType = {
    id?: true
    sponsorId?: true
    teamId?: true
    sponsorshipAmount?: true
    ord?: true
  }

  export type RelSponsorTeamMinAggregateInputType = {
    id?: true
    sponsorId?: true
    teamId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelSponsorTeamMaxAggregateInputType = {
    id?: true
    sponsorId?: true
    teamId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelSponsorTeamCountAggregateInputType = {
    id?: true
    sponsorId?: true
    teamId?: true
    startedAt?: true
    endedAt?: true
    status?: true
    sponsorshipAmount?: true
    benefits?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelSponsorTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelSponsorTeam to aggregate.
     */
    where?: RelSponsorTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorTeams to fetch.
     */
    orderBy?: RelSponsorTeamOrderByWithRelationInput | RelSponsorTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelSponsorTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelSponsorTeams
    **/
    _count?: true | RelSponsorTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelSponsorTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelSponsorTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelSponsorTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelSponsorTeamMaxAggregateInputType
  }

  export type GetRelSponsorTeamAggregateType<T extends RelSponsorTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateRelSponsorTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelSponsorTeam[P]>
      : GetScalarType<T[P], AggregateRelSponsorTeam[P]>
  }




  export type RelSponsorTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelSponsorTeamWhereInput
    orderBy?: RelSponsorTeamOrderByWithAggregationInput | RelSponsorTeamOrderByWithAggregationInput[]
    by: RelSponsorTeamScalarFieldEnum[] | RelSponsorTeamScalarFieldEnum
    having?: RelSponsorTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelSponsorTeamCountAggregateInputType | true
    _avg?: RelSponsorTeamAvgAggregateInputType
    _sum?: RelSponsorTeamSumAggregateInputType
    _min?: RelSponsorTeamMinAggregateInputType
    _max?: RelSponsorTeamMaxAggregateInputType
  }

  export type RelSponsorTeamGroupByOutputType = {
    id: Decimal
    sponsorId: Decimal
    teamId: Decimal
    startedAt: Date | null
    endedAt: Date | null
    status: string
    sponsorshipAmount: Decimal | null
    benefits: string | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelSponsorTeamCountAggregateOutputType | null
    _avg: RelSponsorTeamAvgAggregateOutputType | null
    _sum: RelSponsorTeamSumAggregateOutputType | null
    _min: RelSponsorTeamMinAggregateOutputType | null
    _max: RelSponsorTeamMaxAggregateOutputType | null
  }

  type GetRelSponsorTeamGroupByPayload<T extends RelSponsorTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelSponsorTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelSponsorTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelSponsorTeamGroupByOutputType[P]>
            : GetScalarType<T[P], RelSponsorTeamGroupByOutputType[P]>
        }
      >
    >


  export type RelSponsorTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    teamId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorTeam"]>

  export type RelSponsorTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    teamId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorTeam"]>

  export type RelSponsorTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sponsorId?: boolean
    teamId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relSponsorTeam"]>

  export type RelSponsorTeamSelectScalar = {
    id?: boolean
    sponsorId?: boolean
    teamId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    sponsorshipAmount?: boolean
    benefits?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelSponsorTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sponsorId" | "teamId" | "startedAt" | "endedAt" | "status" | "sponsorshipAmount" | "benefits" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relSponsorTeam"]>

  export type $RelSponsorTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelSponsorTeam"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sponsorId: Prisma.Decimal
      teamId: Prisma.Decimal
      startedAt: Date | null
      endedAt: Date | null
      status: string
      sponsorshipAmount: Prisma.Decimal | null
      benefits: string | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relSponsorTeam"]>
    composites: {}
  }

  type RelSponsorTeamGetPayload<S extends boolean | null | undefined | RelSponsorTeamDefaultArgs> = $Result.GetResult<Prisma.$RelSponsorTeamPayload, S>

  type RelSponsorTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelSponsorTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelSponsorTeamCountAggregateInputType | true
    }

  export interface RelSponsorTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelSponsorTeam'], meta: { name: 'RelSponsorTeam' } }
    /**
     * Find zero or one RelSponsorTeam that matches the filter.
     * @param {RelSponsorTeamFindUniqueArgs} args - Arguments to find a RelSponsorTeam
     * @example
     * // Get one RelSponsorTeam
     * const relSponsorTeam = await prisma.relSponsorTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelSponsorTeamFindUniqueArgs>(args: SelectSubset<T, RelSponsorTeamFindUniqueArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelSponsorTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelSponsorTeamFindUniqueOrThrowArgs} args - Arguments to find a RelSponsorTeam
     * @example
     * // Get one RelSponsorTeam
     * const relSponsorTeam = await prisma.relSponsorTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelSponsorTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, RelSponsorTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelSponsorTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamFindFirstArgs} args - Arguments to find a RelSponsorTeam
     * @example
     * // Get one RelSponsorTeam
     * const relSponsorTeam = await prisma.relSponsorTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelSponsorTeamFindFirstArgs>(args?: SelectSubset<T, RelSponsorTeamFindFirstArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelSponsorTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamFindFirstOrThrowArgs} args - Arguments to find a RelSponsorTeam
     * @example
     * // Get one RelSponsorTeam
     * const relSponsorTeam = await prisma.relSponsorTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelSponsorTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, RelSponsorTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelSponsorTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelSponsorTeams
     * const relSponsorTeams = await prisma.relSponsorTeam.findMany()
     * 
     * // Get first 10 RelSponsorTeams
     * const relSponsorTeams = await prisma.relSponsorTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relSponsorTeamWithIdOnly = await prisma.relSponsorTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelSponsorTeamFindManyArgs>(args?: SelectSubset<T, RelSponsorTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelSponsorTeam.
     * @param {RelSponsorTeamCreateArgs} args - Arguments to create a RelSponsorTeam.
     * @example
     * // Create one RelSponsorTeam
     * const RelSponsorTeam = await prisma.relSponsorTeam.create({
     *   data: {
     *     // ... data to create a RelSponsorTeam
     *   }
     * })
     * 
     */
    create<T extends RelSponsorTeamCreateArgs>(args: SelectSubset<T, RelSponsorTeamCreateArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelSponsorTeams.
     * @param {RelSponsorTeamCreateManyArgs} args - Arguments to create many RelSponsorTeams.
     * @example
     * // Create many RelSponsorTeams
     * const relSponsorTeam = await prisma.relSponsorTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelSponsorTeamCreateManyArgs>(args?: SelectSubset<T, RelSponsorTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelSponsorTeams and returns the data saved in the database.
     * @param {RelSponsorTeamCreateManyAndReturnArgs} args - Arguments to create many RelSponsorTeams.
     * @example
     * // Create many RelSponsorTeams
     * const relSponsorTeam = await prisma.relSponsorTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelSponsorTeams and only return the `id`
     * const relSponsorTeamWithIdOnly = await prisma.relSponsorTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelSponsorTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, RelSponsorTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelSponsorTeam.
     * @param {RelSponsorTeamDeleteArgs} args - Arguments to delete one RelSponsorTeam.
     * @example
     * // Delete one RelSponsorTeam
     * const RelSponsorTeam = await prisma.relSponsorTeam.delete({
     *   where: {
     *     // ... filter to delete one RelSponsorTeam
     *   }
     * })
     * 
     */
    delete<T extends RelSponsorTeamDeleteArgs>(args: SelectSubset<T, RelSponsorTeamDeleteArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelSponsorTeam.
     * @param {RelSponsorTeamUpdateArgs} args - Arguments to update one RelSponsorTeam.
     * @example
     * // Update one RelSponsorTeam
     * const relSponsorTeam = await prisma.relSponsorTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelSponsorTeamUpdateArgs>(args: SelectSubset<T, RelSponsorTeamUpdateArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelSponsorTeams.
     * @param {RelSponsorTeamDeleteManyArgs} args - Arguments to filter RelSponsorTeams to delete.
     * @example
     * // Delete a few RelSponsorTeams
     * const { count } = await prisma.relSponsorTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelSponsorTeamDeleteManyArgs>(args?: SelectSubset<T, RelSponsorTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelSponsorTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelSponsorTeams
     * const relSponsorTeam = await prisma.relSponsorTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelSponsorTeamUpdateManyArgs>(args: SelectSubset<T, RelSponsorTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelSponsorTeams and returns the data updated in the database.
     * @param {RelSponsorTeamUpdateManyAndReturnArgs} args - Arguments to update many RelSponsorTeams.
     * @example
     * // Update many RelSponsorTeams
     * const relSponsorTeam = await prisma.relSponsorTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelSponsorTeams and only return the `id`
     * const relSponsorTeamWithIdOnly = await prisma.relSponsorTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelSponsorTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, RelSponsorTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelSponsorTeam.
     * @param {RelSponsorTeamUpsertArgs} args - Arguments to update or create a RelSponsorTeam.
     * @example
     * // Update or create a RelSponsorTeam
     * const relSponsorTeam = await prisma.relSponsorTeam.upsert({
     *   create: {
     *     // ... data to create a RelSponsorTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelSponsorTeam we want to update
     *   }
     * })
     */
    upsert<T extends RelSponsorTeamUpsertArgs>(args: SelectSubset<T, RelSponsorTeamUpsertArgs<ExtArgs>>): Prisma__RelSponsorTeamClient<$Result.GetResult<Prisma.$RelSponsorTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelSponsorTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamCountArgs} args - Arguments to filter RelSponsorTeams to count.
     * @example
     * // Count the number of RelSponsorTeams
     * const count = await prisma.relSponsorTeam.count({
     *   where: {
     *     // ... the filter for the RelSponsorTeams we want to count
     *   }
     * })
    **/
    count<T extends RelSponsorTeamCountArgs>(
      args?: Subset<T, RelSponsorTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelSponsorTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelSponsorTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelSponsorTeamAggregateArgs>(args: Subset<T, RelSponsorTeamAggregateArgs>): Prisma.PrismaPromise<GetRelSponsorTeamAggregateType<T>>

    /**
     * Group by RelSponsorTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelSponsorTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelSponsorTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelSponsorTeamGroupByArgs['orderBy'] }
        : { orderBy?: RelSponsorTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelSponsorTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelSponsorTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelSponsorTeam model
   */
  readonly fields: RelSponsorTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelSponsorTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelSponsorTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelSponsorTeam model
   */
  interface RelSponsorTeamFieldRefs {
    readonly id: FieldRef<"RelSponsorTeam", 'Decimal'>
    readonly sponsorId: FieldRef<"RelSponsorTeam", 'Decimal'>
    readonly teamId: FieldRef<"RelSponsorTeam", 'Decimal'>
    readonly startedAt: FieldRef<"RelSponsorTeam", 'DateTime'>
    readonly endedAt: FieldRef<"RelSponsorTeam", 'DateTime'>
    readonly status: FieldRef<"RelSponsorTeam", 'String'>
    readonly sponsorshipAmount: FieldRef<"RelSponsorTeam", 'Decimal'>
    readonly benefits: FieldRef<"RelSponsorTeam", 'String'>
    readonly notes: FieldRef<"RelSponsorTeam", 'String'>
    readonly ord: FieldRef<"RelSponsorTeam", 'Int'>
    readonly createdAt: FieldRef<"RelSponsorTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"RelSponsorTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelSponsorTeam findUnique
   */
  export type RelSponsorTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorTeam to fetch.
     */
    where: RelSponsorTeamWhereUniqueInput
  }

  /**
   * RelSponsorTeam findUniqueOrThrow
   */
  export type RelSponsorTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorTeam to fetch.
     */
    where: RelSponsorTeamWhereUniqueInput
  }

  /**
   * RelSponsorTeam findFirst
   */
  export type RelSponsorTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorTeam to fetch.
     */
    where?: RelSponsorTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorTeams to fetch.
     */
    orderBy?: RelSponsorTeamOrderByWithRelationInput | RelSponsorTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelSponsorTeams.
     */
    cursor?: RelSponsorTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelSponsorTeams.
     */
    distinct?: RelSponsorTeamScalarFieldEnum | RelSponsorTeamScalarFieldEnum[]
  }

  /**
   * RelSponsorTeam findFirstOrThrow
   */
  export type RelSponsorTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorTeam to fetch.
     */
    where?: RelSponsorTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorTeams to fetch.
     */
    orderBy?: RelSponsorTeamOrderByWithRelationInput | RelSponsorTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelSponsorTeams.
     */
    cursor?: RelSponsorTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelSponsorTeams.
     */
    distinct?: RelSponsorTeamScalarFieldEnum | RelSponsorTeamScalarFieldEnum[]
  }

  /**
   * RelSponsorTeam findMany
   */
  export type RelSponsorTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * Filter, which RelSponsorTeams to fetch.
     */
    where?: RelSponsorTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelSponsorTeams to fetch.
     */
    orderBy?: RelSponsorTeamOrderByWithRelationInput | RelSponsorTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelSponsorTeams.
     */
    cursor?: RelSponsorTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelSponsorTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelSponsorTeams.
     */
    skip?: number
    distinct?: RelSponsorTeamScalarFieldEnum | RelSponsorTeamScalarFieldEnum[]
  }

  /**
   * RelSponsorTeam create
   */
  export type RelSponsorTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * The data needed to create a RelSponsorTeam.
     */
    data: XOR<RelSponsorTeamCreateInput, RelSponsorTeamUncheckedCreateInput>
  }

  /**
   * RelSponsorTeam createMany
   */
  export type RelSponsorTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelSponsorTeams.
     */
    data: RelSponsorTeamCreateManyInput | RelSponsorTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelSponsorTeam createManyAndReturn
   */
  export type RelSponsorTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * The data used to create many RelSponsorTeams.
     */
    data: RelSponsorTeamCreateManyInput | RelSponsorTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelSponsorTeam update
   */
  export type RelSponsorTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * The data needed to update a RelSponsorTeam.
     */
    data: XOR<RelSponsorTeamUpdateInput, RelSponsorTeamUncheckedUpdateInput>
    /**
     * Choose, which RelSponsorTeam to update.
     */
    where: RelSponsorTeamWhereUniqueInput
  }

  /**
   * RelSponsorTeam updateMany
   */
  export type RelSponsorTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelSponsorTeams.
     */
    data: XOR<RelSponsorTeamUpdateManyMutationInput, RelSponsorTeamUncheckedUpdateManyInput>
    /**
     * Filter which RelSponsorTeams to update
     */
    where?: RelSponsorTeamWhereInput
    /**
     * Limit how many RelSponsorTeams to update.
     */
    limit?: number
  }

  /**
   * RelSponsorTeam updateManyAndReturn
   */
  export type RelSponsorTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * The data used to update RelSponsorTeams.
     */
    data: XOR<RelSponsorTeamUpdateManyMutationInput, RelSponsorTeamUncheckedUpdateManyInput>
    /**
     * Filter which RelSponsorTeams to update
     */
    where?: RelSponsorTeamWhereInput
    /**
     * Limit how many RelSponsorTeams to update.
     */
    limit?: number
  }

  /**
   * RelSponsorTeam upsert
   */
  export type RelSponsorTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * The filter to search for the RelSponsorTeam to update in case it exists.
     */
    where: RelSponsorTeamWhereUniqueInput
    /**
     * In case the RelSponsorTeam found by the `where` argument doesn't exist, create a new RelSponsorTeam with this data.
     */
    create: XOR<RelSponsorTeamCreateInput, RelSponsorTeamUncheckedCreateInput>
    /**
     * In case the RelSponsorTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelSponsorTeamUpdateInput, RelSponsorTeamUncheckedUpdateInput>
  }

  /**
   * RelSponsorTeam delete
   */
  export type RelSponsorTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
    /**
     * Filter which RelSponsorTeam to delete.
     */
    where: RelSponsorTeamWhereUniqueInput
  }

  /**
   * RelSponsorTeam deleteMany
   */
  export type RelSponsorTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelSponsorTeams to delete
     */
    where?: RelSponsorTeamWhereInput
    /**
     * Limit how many RelSponsorTeams to delete.
     */
    limit?: number
  }

  /**
   * RelSponsorTeam without action
   */
  export type RelSponsorTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelSponsorTeam
     */
    select?: RelSponsorTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelSponsorTeam
     */
    omit?: RelSponsorTeamOmit<ExtArgs> | null
  }


  /**
   * Model RelTeamCoach
   */

  export type AggregateRelTeamCoach = {
    _count: RelTeamCoachCountAggregateOutputType | null
    _avg: RelTeamCoachAvgAggregateOutputType | null
    _sum: RelTeamCoachSumAggregateOutputType | null
    _min: RelTeamCoachMinAggregateOutputType | null
    _max: RelTeamCoachMaxAggregateOutputType | null
  }

  export type RelTeamCoachAvgAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    coachId: Decimal | null
    coachTypeId: number | null
    salary: Decimal | null
    ord: number | null
  }

  export type RelTeamCoachSumAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    coachId: Decimal | null
    coachTypeId: bigint | null
    salary: Decimal | null
    ord: number | null
  }

  export type RelTeamCoachMinAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    coachId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    coachTypeId: bigint | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    responsibilities: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelTeamCoachMaxAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    coachId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    coachTypeId: bigint | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    responsibilities: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelTeamCoachCountAggregateOutputType = {
    id: number
    teamId: number
    coachId: number
    joinedAt: number
    leftAt: number
    status: number
    coachTypeId: number
    salary: number
    contractStart: number
    contractEnd: number
    responsibilities: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelTeamCoachAvgAggregateInputType = {
    id?: true
    teamId?: true
    coachId?: true
    coachTypeId?: true
    salary?: true
    ord?: true
  }

  export type RelTeamCoachSumAggregateInputType = {
    id?: true
    teamId?: true
    coachId?: true
    coachTypeId?: true
    salary?: true
    ord?: true
  }

  export type RelTeamCoachMinAggregateInputType = {
    id?: true
    teamId?: true
    coachId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    coachTypeId?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    responsibilities?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelTeamCoachMaxAggregateInputType = {
    id?: true
    teamId?: true
    coachId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    coachTypeId?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    responsibilities?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelTeamCoachCountAggregateInputType = {
    id?: true
    teamId?: true
    coachId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    coachTypeId?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    responsibilities?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelTeamCoachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelTeamCoach to aggregate.
     */
    where?: RelTeamCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamCoaches to fetch.
     */
    orderBy?: RelTeamCoachOrderByWithRelationInput | RelTeamCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelTeamCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelTeamCoaches
    **/
    _count?: true | RelTeamCoachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelTeamCoachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelTeamCoachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelTeamCoachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelTeamCoachMaxAggregateInputType
  }

  export type GetRelTeamCoachAggregateType<T extends RelTeamCoachAggregateArgs> = {
        [P in keyof T & keyof AggregateRelTeamCoach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelTeamCoach[P]>
      : GetScalarType<T[P], AggregateRelTeamCoach[P]>
  }




  export type RelTeamCoachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelTeamCoachWhereInput
    orderBy?: RelTeamCoachOrderByWithAggregationInput | RelTeamCoachOrderByWithAggregationInput[]
    by: RelTeamCoachScalarFieldEnum[] | RelTeamCoachScalarFieldEnum
    having?: RelTeamCoachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelTeamCoachCountAggregateInputType | true
    _avg?: RelTeamCoachAvgAggregateInputType
    _sum?: RelTeamCoachSumAggregateInputType
    _min?: RelTeamCoachMinAggregateInputType
    _max?: RelTeamCoachMaxAggregateInputType
  }

  export type RelTeamCoachGroupByOutputType = {
    id: Decimal
    teamId: Decimal
    coachId: Decimal
    joinedAt: Date | null
    leftAt: Date | null
    status: string
    coachTypeId: bigint | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    responsibilities: string | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelTeamCoachCountAggregateOutputType | null
    _avg: RelTeamCoachAvgAggregateOutputType | null
    _sum: RelTeamCoachSumAggregateOutputType | null
    _min: RelTeamCoachMinAggregateOutputType | null
    _max: RelTeamCoachMaxAggregateOutputType | null
  }

  type GetRelTeamCoachGroupByPayload<T extends RelTeamCoachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelTeamCoachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelTeamCoachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelTeamCoachGroupByOutputType[P]>
            : GetScalarType<T[P], RelTeamCoachGroupByOutputType[P]>
        }
      >
    >


  export type RelTeamCoachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    coachId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    coachTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamCoach"]>

  export type RelTeamCoachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    coachId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    coachTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamCoach"]>

  export type RelTeamCoachSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    coachId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    coachTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamCoach"]>

  export type RelTeamCoachSelectScalar = {
    id?: boolean
    teamId?: boolean
    coachId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    coachTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelTeamCoachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "coachId" | "joinedAt" | "leftAt" | "status" | "coachTypeId" | "salary" | "contractStart" | "contractEnd" | "responsibilities" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relTeamCoach"]>

  export type $RelTeamCoachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelTeamCoach"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      teamId: Prisma.Decimal
      coachId: Prisma.Decimal
      joinedAt: Date | null
      leftAt: Date | null
      status: string
      coachTypeId: bigint | null
      salary: Prisma.Decimal | null
      contractStart: Date | null
      contractEnd: Date | null
      responsibilities: string | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relTeamCoach"]>
    composites: {}
  }

  type RelTeamCoachGetPayload<S extends boolean | null | undefined | RelTeamCoachDefaultArgs> = $Result.GetResult<Prisma.$RelTeamCoachPayload, S>

  type RelTeamCoachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelTeamCoachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelTeamCoachCountAggregateInputType | true
    }

  export interface RelTeamCoachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelTeamCoach'], meta: { name: 'RelTeamCoach' } }
    /**
     * Find zero or one RelTeamCoach that matches the filter.
     * @param {RelTeamCoachFindUniqueArgs} args - Arguments to find a RelTeamCoach
     * @example
     * // Get one RelTeamCoach
     * const relTeamCoach = await prisma.relTeamCoach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelTeamCoachFindUniqueArgs>(args: SelectSubset<T, RelTeamCoachFindUniqueArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelTeamCoach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelTeamCoachFindUniqueOrThrowArgs} args - Arguments to find a RelTeamCoach
     * @example
     * // Get one RelTeamCoach
     * const relTeamCoach = await prisma.relTeamCoach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelTeamCoachFindUniqueOrThrowArgs>(args: SelectSubset<T, RelTeamCoachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelTeamCoach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachFindFirstArgs} args - Arguments to find a RelTeamCoach
     * @example
     * // Get one RelTeamCoach
     * const relTeamCoach = await prisma.relTeamCoach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelTeamCoachFindFirstArgs>(args?: SelectSubset<T, RelTeamCoachFindFirstArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelTeamCoach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachFindFirstOrThrowArgs} args - Arguments to find a RelTeamCoach
     * @example
     * // Get one RelTeamCoach
     * const relTeamCoach = await prisma.relTeamCoach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelTeamCoachFindFirstOrThrowArgs>(args?: SelectSubset<T, RelTeamCoachFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelTeamCoaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelTeamCoaches
     * const relTeamCoaches = await prisma.relTeamCoach.findMany()
     * 
     * // Get first 10 RelTeamCoaches
     * const relTeamCoaches = await prisma.relTeamCoach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relTeamCoachWithIdOnly = await prisma.relTeamCoach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelTeamCoachFindManyArgs>(args?: SelectSubset<T, RelTeamCoachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelTeamCoach.
     * @param {RelTeamCoachCreateArgs} args - Arguments to create a RelTeamCoach.
     * @example
     * // Create one RelTeamCoach
     * const RelTeamCoach = await prisma.relTeamCoach.create({
     *   data: {
     *     // ... data to create a RelTeamCoach
     *   }
     * })
     * 
     */
    create<T extends RelTeamCoachCreateArgs>(args: SelectSubset<T, RelTeamCoachCreateArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelTeamCoaches.
     * @param {RelTeamCoachCreateManyArgs} args - Arguments to create many RelTeamCoaches.
     * @example
     * // Create many RelTeamCoaches
     * const relTeamCoach = await prisma.relTeamCoach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelTeamCoachCreateManyArgs>(args?: SelectSubset<T, RelTeamCoachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelTeamCoaches and returns the data saved in the database.
     * @param {RelTeamCoachCreateManyAndReturnArgs} args - Arguments to create many RelTeamCoaches.
     * @example
     * // Create many RelTeamCoaches
     * const relTeamCoach = await prisma.relTeamCoach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelTeamCoaches and only return the `id`
     * const relTeamCoachWithIdOnly = await prisma.relTeamCoach.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelTeamCoachCreateManyAndReturnArgs>(args?: SelectSubset<T, RelTeamCoachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelTeamCoach.
     * @param {RelTeamCoachDeleteArgs} args - Arguments to delete one RelTeamCoach.
     * @example
     * // Delete one RelTeamCoach
     * const RelTeamCoach = await prisma.relTeamCoach.delete({
     *   where: {
     *     // ... filter to delete one RelTeamCoach
     *   }
     * })
     * 
     */
    delete<T extends RelTeamCoachDeleteArgs>(args: SelectSubset<T, RelTeamCoachDeleteArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelTeamCoach.
     * @param {RelTeamCoachUpdateArgs} args - Arguments to update one RelTeamCoach.
     * @example
     * // Update one RelTeamCoach
     * const relTeamCoach = await prisma.relTeamCoach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelTeamCoachUpdateArgs>(args: SelectSubset<T, RelTeamCoachUpdateArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelTeamCoaches.
     * @param {RelTeamCoachDeleteManyArgs} args - Arguments to filter RelTeamCoaches to delete.
     * @example
     * // Delete a few RelTeamCoaches
     * const { count } = await prisma.relTeamCoach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelTeamCoachDeleteManyArgs>(args?: SelectSubset<T, RelTeamCoachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelTeamCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelTeamCoaches
     * const relTeamCoach = await prisma.relTeamCoach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelTeamCoachUpdateManyArgs>(args: SelectSubset<T, RelTeamCoachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelTeamCoaches and returns the data updated in the database.
     * @param {RelTeamCoachUpdateManyAndReturnArgs} args - Arguments to update many RelTeamCoaches.
     * @example
     * // Update many RelTeamCoaches
     * const relTeamCoach = await prisma.relTeamCoach.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelTeamCoaches and only return the `id`
     * const relTeamCoachWithIdOnly = await prisma.relTeamCoach.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelTeamCoachUpdateManyAndReturnArgs>(args: SelectSubset<T, RelTeamCoachUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelTeamCoach.
     * @param {RelTeamCoachUpsertArgs} args - Arguments to update or create a RelTeamCoach.
     * @example
     * // Update or create a RelTeamCoach
     * const relTeamCoach = await prisma.relTeamCoach.upsert({
     *   create: {
     *     // ... data to create a RelTeamCoach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelTeamCoach we want to update
     *   }
     * })
     */
    upsert<T extends RelTeamCoachUpsertArgs>(args: SelectSubset<T, RelTeamCoachUpsertArgs<ExtArgs>>): Prisma__RelTeamCoachClient<$Result.GetResult<Prisma.$RelTeamCoachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelTeamCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachCountArgs} args - Arguments to filter RelTeamCoaches to count.
     * @example
     * // Count the number of RelTeamCoaches
     * const count = await prisma.relTeamCoach.count({
     *   where: {
     *     // ... the filter for the RelTeamCoaches we want to count
     *   }
     * })
    **/
    count<T extends RelTeamCoachCountArgs>(
      args?: Subset<T, RelTeamCoachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelTeamCoachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelTeamCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelTeamCoachAggregateArgs>(args: Subset<T, RelTeamCoachAggregateArgs>): Prisma.PrismaPromise<GetRelTeamCoachAggregateType<T>>

    /**
     * Group by RelTeamCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamCoachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelTeamCoachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelTeamCoachGroupByArgs['orderBy'] }
        : { orderBy?: RelTeamCoachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelTeamCoachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelTeamCoachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelTeamCoach model
   */
  readonly fields: RelTeamCoachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelTeamCoach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelTeamCoachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelTeamCoach model
   */
  interface RelTeamCoachFieldRefs {
    readonly id: FieldRef<"RelTeamCoach", 'Decimal'>
    readonly teamId: FieldRef<"RelTeamCoach", 'Decimal'>
    readonly coachId: FieldRef<"RelTeamCoach", 'Decimal'>
    readonly joinedAt: FieldRef<"RelTeamCoach", 'DateTime'>
    readonly leftAt: FieldRef<"RelTeamCoach", 'DateTime'>
    readonly status: FieldRef<"RelTeamCoach", 'String'>
    readonly coachTypeId: FieldRef<"RelTeamCoach", 'BigInt'>
    readonly salary: FieldRef<"RelTeamCoach", 'Decimal'>
    readonly contractStart: FieldRef<"RelTeamCoach", 'DateTime'>
    readonly contractEnd: FieldRef<"RelTeamCoach", 'DateTime'>
    readonly responsibilities: FieldRef<"RelTeamCoach", 'String'>
    readonly notes: FieldRef<"RelTeamCoach", 'String'>
    readonly ord: FieldRef<"RelTeamCoach", 'Int'>
    readonly createdAt: FieldRef<"RelTeamCoach", 'DateTime'>
    readonly updatedAt: FieldRef<"RelTeamCoach", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelTeamCoach findUnique
   */
  export type RelTeamCoachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamCoach to fetch.
     */
    where: RelTeamCoachWhereUniqueInput
  }

  /**
   * RelTeamCoach findUniqueOrThrow
   */
  export type RelTeamCoachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamCoach to fetch.
     */
    where: RelTeamCoachWhereUniqueInput
  }

  /**
   * RelTeamCoach findFirst
   */
  export type RelTeamCoachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamCoach to fetch.
     */
    where?: RelTeamCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamCoaches to fetch.
     */
    orderBy?: RelTeamCoachOrderByWithRelationInput | RelTeamCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelTeamCoaches.
     */
    cursor?: RelTeamCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelTeamCoaches.
     */
    distinct?: RelTeamCoachScalarFieldEnum | RelTeamCoachScalarFieldEnum[]
  }

  /**
   * RelTeamCoach findFirstOrThrow
   */
  export type RelTeamCoachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamCoach to fetch.
     */
    where?: RelTeamCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamCoaches to fetch.
     */
    orderBy?: RelTeamCoachOrderByWithRelationInput | RelTeamCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelTeamCoaches.
     */
    cursor?: RelTeamCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelTeamCoaches.
     */
    distinct?: RelTeamCoachScalarFieldEnum | RelTeamCoachScalarFieldEnum[]
  }

  /**
   * RelTeamCoach findMany
   */
  export type RelTeamCoachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamCoaches to fetch.
     */
    where?: RelTeamCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamCoaches to fetch.
     */
    orderBy?: RelTeamCoachOrderByWithRelationInput | RelTeamCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelTeamCoaches.
     */
    cursor?: RelTeamCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamCoaches.
     */
    skip?: number
    distinct?: RelTeamCoachScalarFieldEnum | RelTeamCoachScalarFieldEnum[]
  }

  /**
   * RelTeamCoach create
   */
  export type RelTeamCoachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * The data needed to create a RelTeamCoach.
     */
    data: XOR<RelTeamCoachCreateInput, RelTeamCoachUncheckedCreateInput>
  }

  /**
   * RelTeamCoach createMany
   */
  export type RelTeamCoachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelTeamCoaches.
     */
    data: RelTeamCoachCreateManyInput | RelTeamCoachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelTeamCoach createManyAndReturn
   */
  export type RelTeamCoachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * The data used to create many RelTeamCoaches.
     */
    data: RelTeamCoachCreateManyInput | RelTeamCoachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelTeamCoach update
   */
  export type RelTeamCoachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * The data needed to update a RelTeamCoach.
     */
    data: XOR<RelTeamCoachUpdateInput, RelTeamCoachUncheckedUpdateInput>
    /**
     * Choose, which RelTeamCoach to update.
     */
    where: RelTeamCoachWhereUniqueInput
  }

  /**
   * RelTeamCoach updateMany
   */
  export type RelTeamCoachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelTeamCoaches.
     */
    data: XOR<RelTeamCoachUpdateManyMutationInput, RelTeamCoachUncheckedUpdateManyInput>
    /**
     * Filter which RelTeamCoaches to update
     */
    where?: RelTeamCoachWhereInput
    /**
     * Limit how many RelTeamCoaches to update.
     */
    limit?: number
  }

  /**
   * RelTeamCoach updateManyAndReturn
   */
  export type RelTeamCoachUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * The data used to update RelTeamCoaches.
     */
    data: XOR<RelTeamCoachUpdateManyMutationInput, RelTeamCoachUncheckedUpdateManyInput>
    /**
     * Filter which RelTeamCoaches to update
     */
    where?: RelTeamCoachWhereInput
    /**
     * Limit how many RelTeamCoaches to update.
     */
    limit?: number
  }

  /**
   * RelTeamCoach upsert
   */
  export type RelTeamCoachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * The filter to search for the RelTeamCoach to update in case it exists.
     */
    where: RelTeamCoachWhereUniqueInput
    /**
     * In case the RelTeamCoach found by the `where` argument doesn't exist, create a new RelTeamCoach with this data.
     */
    create: XOR<RelTeamCoachCreateInput, RelTeamCoachUncheckedCreateInput>
    /**
     * In case the RelTeamCoach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelTeamCoachUpdateInput, RelTeamCoachUncheckedUpdateInput>
  }

  /**
   * RelTeamCoach delete
   */
  export type RelTeamCoachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
    /**
     * Filter which RelTeamCoach to delete.
     */
    where: RelTeamCoachWhereUniqueInput
  }

  /**
   * RelTeamCoach deleteMany
   */
  export type RelTeamCoachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelTeamCoaches to delete
     */
    where?: RelTeamCoachWhereInput
    /**
     * Limit how many RelTeamCoaches to delete.
     */
    limit?: number
  }

  /**
   * RelTeamCoach without action
   */
  export type RelTeamCoachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamCoach
     */
    select?: RelTeamCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamCoach
     */
    omit?: RelTeamCoachOmit<ExtArgs> | null
  }


  /**
   * Model RelTeamPlayer
   */

  export type AggregateRelTeamPlayer = {
    _count: RelTeamPlayerCountAggregateOutputType | null
    _avg: RelTeamPlayerAvgAggregateOutputType | null
    _sum: RelTeamPlayerSumAggregateOutputType | null
    _min: RelTeamPlayerMinAggregateOutputType | null
    _max: RelTeamPlayerMaxAggregateOutputType | null
  }

  export type RelTeamPlayerAvgAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    playerId: Decimal | null
    positionId: number | null
    ord: number | null
  }

  export type RelTeamPlayerSumAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    playerId: Decimal | null
    positionId: bigint | null
    ord: number | null
  }

  export type RelTeamPlayerMinAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    playerId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    jerseyNumber: string | null
    positionId: bigint | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelTeamPlayerMaxAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    playerId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    jerseyNumber: string | null
    positionId: bigint | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelTeamPlayerCountAggregateOutputType = {
    id: number
    teamId: number
    playerId: number
    joinedAt: number
    leftAt: number
    status: number
    jerseyNumber: number
    positionId: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelTeamPlayerAvgAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    positionId?: true
    ord?: true
  }

  export type RelTeamPlayerSumAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    positionId?: true
    ord?: true
  }

  export type RelTeamPlayerMinAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    jerseyNumber?: true
    positionId?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelTeamPlayerMaxAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    jerseyNumber?: true
    positionId?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelTeamPlayerCountAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    jerseyNumber?: true
    positionId?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelTeamPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelTeamPlayer to aggregate.
     */
    where?: RelTeamPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamPlayers to fetch.
     */
    orderBy?: RelTeamPlayerOrderByWithRelationInput | RelTeamPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelTeamPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelTeamPlayers
    **/
    _count?: true | RelTeamPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelTeamPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelTeamPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelTeamPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelTeamPlayerMaxAggregateInputType
  }

  export type GetRelTeamPlayerAggregateType<T extends RelTeamPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateRelTeamPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelTeamPlayer[P]>
      : GetScalarType<T[P], AggregateRelTeamPlayer[P]>
  }




  export type RelTeamPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelTeamPlayerWhereInput
    orderBy?: RelTeamPlayerOrderByWithAggregationInput | RelTeamPlayerOrderByWithAggregationInput[]
    by: RelTeamPlayerScalarFieldEnum[] | RelTeamPlayerScalarFieldEnum
    having?: RelTeamPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelTeamPlayerCountAggregateInputType | true
    _avg?: RelTeamPlayerAvgAggregateInputType
    _sum?: RelTeamPlayerSumAggregateInputType
    _min?: RelTeamPlayerMinAggregateInputType
    _max?: RelTeamPlayerMaxAggregateInputType
  }

  export type RelTeamPlayerGroupByOutputType = {
    id: Decimal
    teamId: Decimal
    playerId: Decimal
    joinedAt: Date | null
    leftAt: Date | null
    status: string
    jerseyNumber: string | null
    positionId: bigint | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelTeamPlayerCountAggregateOutputType | null
    _avg: RelTeamPlayerAvgAggregateOutputType | null
    _sum: RelTeamPlayerSumAggregateOutputType | null
    _min: RelTeamPlayerMinAggregateOutputType | null
    _max: RelTeamPlayerMaxAggregateOutputType | null
  }

  type GetRelTeamPlayerGroupByPayload<T extends RelTeamPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelTeamPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelTeamPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelTeamPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], RelTeamPlayerGroupByOutputType[P]>
        }
      >
    >


  export type RelTeamPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    jerseyNumber?: boolean
    positionId?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamPlayer"]>

  export type RelTeamPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    jerseyNumber?: boolean
    positionId?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamPlayer"]>

  export type RelTeamPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    jerseyNumber?: boolean
    positionId?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamPlayer"]>

  export type RelTeamPlayerSelectScalar = {
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    jerseyNumber?: boolean
    positionId?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelTeamPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "playerId" | "joinedAt" | "leftAt" | "status" | "jerseyNumber" | "positionId" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relTeamPlayer"]>

  export type $RelTeamPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelTeamPlayer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      teamId: Prisma.Decimal
      playerId: Prisma.Decimal
      joinedAt: Date | null
      leftAt: Date | null
      status: string
      jerseyNumber: string | null
      positionId: bigint | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relTeamPlayer"]>
    composites: {}
  }

  type RelTeamPlayerGetPayload<S extends boolean | null | undefined | RelTeamPlayerDefaultArgs> = $Result.GetResult<Prisma.$RelTeamPlayerPayload, S>

  type RelTeamPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelTeamPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelTeamPlayerCountAggregateInputType | true
    }

  export interface RelTeamPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelTeamPlayer'], meta: { name: 'RelTeamPlayer' } }
    /**
     * Find zero or one RelTeamPlayer that matches the filter.
     * @param {RelTeamPlayerFindUniqueArgs} args - Arguments to find a RelTeamPlayer
     * @example
     * // Get one RelTeamPlayer
     * const relTeamPlayer = await prisma.relTeamPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelTeamPlayerFindUniqueArgs>(args: SelectSubset<T, RelTeamPlayerFindUniqueArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelTeamPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelTeamPlayerFindUniqueOrThrowArgs} args - Arguments to find a RelTeamPlayer
     * @example
     * // Get one RelTeamPlayer
     * const relTeamPlayer = await prisma.relTeamPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelTeamPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, RelTeamPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelTeamPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerFindFirstArgs} args - Arguments to find a RelTeamPlayer
     * @example
     * // Get one RelTeamPlayer
     * const relTeamPlayer = await prisma.relTeamPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelTeamPlayerFindFirstArgs>(args?: SelectSubset<T, RelTeamPlayerFindFirstArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelTeamPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerFindFirstOrThrowArgs} args - Arguments to find a RelTeamPlayer
     * @example
     * // Get one RelTeamPlayer
     * const relTeamPlayer = await prisma.relTeamPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelTeamPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, RelTeamPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelTeamPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelTeamPlayers
     * const relTeamPlayers = await prisma.relTeamPlayer.findMany()
     * 
     * // Get first 10 RelTeamPlayers
     * const relTeamPlayers = await prisma.relTeamPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relTeamPlayerWithIdOnly = await prisma.relTeamPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelTeamPlayerFindManyArgs>(args?: SelectSubset<T, RelTeamPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelTeamPlayer.
     * @param {RelTeamPlayerCreateArgs} args - Arguments to create a RelTeamPlayer.
     * @example
     * // Create one RelTeamPlayer
     * const RelTeamPlayer = await prisma.relTeamPlayer.create({
     *   data: {
     *     // ... data to create a RelTeamPlayer
     *   }
     * })
     * 
     */
    create<T extends RelTeamPlayerCreateArgs>(args: SelectSubset<T, RelTeamPlayerCreateArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelTeamPlayers.
     * @param {RelTeamPlayerCreateManyArgs} args - Arguments to create many RelTeamPlayers.
     * @example
     * // Create many RelTeamPlayers
     * const relTeamPlayer = await prisma.relTeamPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelTeamPlayerCreateManyArgs>(args?: SelectSubset<T, RelTeamPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelTeamPlayers and returns the data saved in the database.
     * @param {RelTeamPlayerCreateManyAndReturnArgs} args - Arguments to create many RelTeamPlayers.
     * @example
     * // Create many RelTeamPlayers
     * const relTeamPlayer = await prisma.relTeamPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelTeamPlayers and only return the `id`
     * const relTeamPlayerWithIdOnly = await prisma.relTeamPlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelTeamPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, RelTeamPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelTeamPlayer.
     * @param {RelTeamPlayerDeleteArgs} args - Arguments to delete one RelTeamPlayer.
     * @example
     * // Delete one RelTeamPlayer
     * const RelTeamPlayer = await prisma.relTeamPlayer.delete({
     *   where: {
     *     // ... filter to delete one RelTeamPlayer
     *   }
     * })
     * 
     */
    delete<T extends RelTeamPlayerDeleteArgs>(args: SelectSubset<T, RelTeamPlayerDeleteArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelTeamPlayer.
     * @param {RelTeamPlayerUpdateArgs} args - Arguments to update one RelTeamPlayer.
     * @example
     * // Update one RelTeamPlayer
     * const relTeamPlayer = await prisma.relTeamPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelTeamPlayerUpdateArgs>(args: SelectSubset<T, RelTeamPlayerUpdateArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelTeamPlayers.
     * @param {RelTeamPlayerDeleteManyArgs} args - Arguments to filter RelTeamPlayers to delete.
     * @example
     * // Delete a few RelTeamPlayers
     * const { count } = await prisma.relTeamPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelTeamPlayerDeleteManyArgs>(args?: SelectSubset<T, RelTeamPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelTeamPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelTeamPlayers
     * const relTeamPlayer = await prisma.relTeamPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelTeamPlayerUpdateManyArgs>(args: SelectSubset<T, RelTeamPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelTeamPlayers and returns the data updated in the database.
     * @param {RelTeamPlayerUpdateManyAndReturnArgs} args - Arguments to update many RelTeamPlayers.
     * @example
     * // Update many RelTeamPlayers
     * const relTeamPlayer = await prisma.relTeamPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelTeamPlayers and only return the `id`
     * const relTeamPlayerWithIdOnly = await prisma.relTeamPlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelTeamPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, RelTeamPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelTeamPlayer.
     * @param {RelTeamPlayerUpsertArgs} args - Arguments to update or create a RelTeamPlayer.
     * @example
     * // Update or create a RelTeamPlayer
     * const relTeamPlayer = await prisma.relTeamPlayer.upsert({
     *   create: {
     *     // ... data to create a RelTeamPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelTeamPlayer we want to update
     *   }
     * })
     */
    upsert<T extends RelTeamPlayerUpsertArgs>(args: SelectSubset<T, RelTeamPlayerUpsertArgs<ExtArgs>>): Prisma__RelTeamPlayerClient<$Result.GetResult<Prisma.$RelTeamPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelTeamPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerCountArgs} args - Arguments to filter RelTeamPlayers to count.
     * @example
     * // Count the number of RelTeamPlayers
     * const count = await prisma.relTeamPlayer.count({
     *   where: {
     *     // ... the filter for the RelTeamPlayers we want to count
     *   }
     * })
    **/
    count<T extends RelTeamPlayerCountArgs>(
      args?: Subset<T, RelTeamPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelTeamPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelTeamPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelTeamPlayerAggregateArgs>(args: Subset<T, RelTeamPlayerAggregateArgs>): Prisma.PrismaPromise<GetRelTeamPlayerAggregateType<T>>

    /**
     * Group by RelTeamPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelTeamPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelTeamPlayerGroupByArgs['orderBy'] }
        : { orderBy?: RelTeamPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelTeamPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelTeamPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelTeamPlayer model
   */
  readonly fields: RelTeamPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelTeamPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelTeamPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelTeamPlayer model
   */
  interface RelTeamPlayerFieldRefs {
    readonly id: FieldRef<"RelTeamPlayer", 'Decimal'>
    readonly teamId: FieldRef<"RelTeamPlayer", 'Decimal'>
    readonly playerId: FieldRef<"RelTeamPlayer", 'Decimal'>
    readonly joinedAt: FieldRef<"RelTeamPlayer", 'DateTime'>
    readonly leftAt: FieldRef<"RelTeamPlayer", 'DateTime'>
    readonly status: FieldRef<"RelTeamPlayer", 'String'>
    readonly jerseyNumber: FieldRef<"RelTeamPlayer", 'String'>
    readonly positionId: FieldRef<"RelTeamPlayer", 'BigInt'>
    readonly notes: FieldRef<"RelTeamPlayer", 'String'>
    readonly ord: FieldRef<"RelTeamPlayer", 'Int'>
    readonly createdAt: FieldRef<"RelTeamPlayer", 'DateTime'>
    readonly updatedAt: FieldRef<"RelTeamPlayer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelTeamPlayer findUnique
   */
  export type RelTeamPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamPlayer to fetch.
     */
    where: RelTeamPlayerWhereUniqueInput
  }

  /**
   * RelTeamPlayer findUniqueOrThrow
   */
  export type RelTeamPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamPlayer to fetch.
     */
    where: RelTeamPlayerWhereUniqueInput
  }

  /**
   * RelTeamPlayer findFirst
   */
  export type RelTeamPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamPlayer to fetch.
     */
    where?: RelTeamPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamPlayers to fetch.
     */
    orderBy?: RelTeamPlayerOrderByWithRelationInput | RelTeamPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelTeamPlayers.
     */
    cursor?: RelTeamPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelTeamPlayers.
     */
    distinct?: RelTeamPlayerScalarFieldEnum | RelTeamPlayerScalarFieldEnum[]
  }

  /**
   * RelTeamPlayer findFirstOrThrow
   */
  export type RelTeamPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamPlayer to fetch.
     */
    where?: RelTeamPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamPlayers to fetch.
     */
    orderBy?: RelTeamPlayerOrderByWithRelationInput | RelTeamPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelTeamPlayers.
     */
    cursor?: RelTeamPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelTeamPlayers.
     */
    distinct?: RelTeamPlayerScalarFieldEnum | RelTeamPlayerScalarFieldEnum[]
  }

  /**
   * RelTeamPlayer findMany
   */
  export type RelTeamPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamPlayers to fetch.
     */
    where?: RelTeamPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamPlayers to fetch.
     */
    orderBy?: RelTeamPlayerOrderByWithRelationInput | RelTeamPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelTeamPlayers.
     */
    cursor?: RelTeamPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamPlayers.
     */
    skip?: number
    distinct?: RelTeamPlayerScalarFieldEnum | RelTeamPlayerScalarFieldEnum[]
  }

  /**
   * RelTeamPlayer create
   */
  export type RelTeamPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * The data needed to create a RelTeamPlayer.
     */
    data: XOR<RelTeamPlayerCreateInput, RelTeamPlayerUncheckedCreateInput>
  }

  /**
   * RelTeamPlayer createMany
   */
  export type RelTeamPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelTeamPlayers.
     */
    data: RelTeamPlayerCreateManyInput | RelTeamPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelTeamPlayer createManyAndReturn
   */
  export type RelTeamPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many RelTeamPlayers.
     */
    data: RelTeamPlayerCreateManyInput | RelTeamPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelTeamPlayer update
   */
  export type RelTeamPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * The data needed to update a RelTeamPlayer.
     */
    data: XOR<RelTeamPlayerUpdateInput, RelTeamPlayerUncheckedUpdateInput>
    /**
     * Choose, which RelTeamPlayer to update.
     */
    where: RelTeamPlayerWhereUniqueInput
  }

  /**
   * RelTeamPlayer updateMany
   */
  export type RelTeamPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelTeamPlayers.
     */
    data: XOR<RelTeamPlayerUpdateManyMutationInput, RelTeamPlayerUncheckedUpdateManyInput>
    /**
     * Filter which RelTeamPlayers to update
     */
    where?: RelTeamPlayerWhereInput
    /**
     * Limit how many RelTeamPlayers to update.
     */
    limit?: number
  }

  /**
   * RelTeamPlayer updateManyAndReturn
   */
  export type RelTeamPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * The data used to update RelTeamPlayers.
     */
    data: XOR<RelTeamPlayerUpdateManyMutationInput, RelTeamPlayerUncheckedUpdateManyInput>
    /**
     * Filter which RelTeamPlayers to update
     */
    where?: RelTeamPlayerWhereInput
    /**
     * Limit how many RelTeamPlayers to update.
     */
    limit?: number
  }

  /**
   * RelTeamPlayer upsert
   */
  export type RelTeamPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * The filter to search for the RelTeamPlayer to update in case it exists.
     */
    where: RelTeamPlayerWhereUniqueInput
    /**
     * In case the RelTeamPlayer found by the `where` argument doesn't exist, create a new RelTeamPlayer with this data.
     */
    create: XOR<RelTeamPlayerCreateInput, RelTeamPlayerUncheckedCreateInput>
    /**
     * In case the RelTeamPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelTeamPlayerUpdateInput, RelTeamPlayerUncheckedUpdateInput>
  }

  /**
   * RelTeamPlayer delete
   */
  export type RelTeamPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
    /**
     * Filter which RelTeamPlayer to delete.
     */
    where: RelTeamPlayerWhereUniqueInput
  }

  /**
   * RelTeamPlayer deleteMany
   */
  export type RelTeamPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelTeamPlayers to delete
     */
    where?: RelTeamPlayerWhereInput
    /**
     * Limit how many RelTeamPlayers to delete.
     */
    limit?: number
  }

  /**
   * RelTeamPlayer without action
   */
  export type RelTeamPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamPlayer
     */
    select?: RelTeamPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamPlayer
     */
    omit?: RelTeamPlayerOmit<ExtArgs> | null
  }


  /**
   * Model RelTeamTeamManager
   */

  export type AggregateRelTeamTeamManager = {
    _count: RelTeamTeamManagerCountAggregateOutputType | null
    _avg: RelTeamTeamManagerAvgAggregateOutputType | null
    _sum: RelTeamTeamManagerSumAggregateOutputType | null
    _min: RelTeamTeamManagerMinAggregateOutputType | null
    _max: RelTeamTeamManagerMaxAggregateOutputType | null
  }

  export type RelTeamTeamManagerAvgAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    managerId: Decimal | null
    salary: Decimal | null
    ord: number | null
  }

  export type RelTeamTeamManagerSumAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    managerId: Decimal | null
    salary: Decimal | null
    ord: number | null
  }

  export type RelTeamTeamManagerMinAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    managerId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    managerTypeId: string | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    responsibilities: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelTeamTeamManagerMaxAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    managerId: Decimal | null
    joinedAt: Date | null
    leftAt: Date | null
    status: string | null
    managerTypeId: string | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    responsibilities: string | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelTeamTeamManagerCountAggregateOutputType = {
    id: number
    teamId: number
    managerId: number
    joinedAt: number
    leftAt: number
    status: number
    managerTypeId: number
    salary: number
    contractStart: number
    contractEnd: number
    responsibilities: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelTeamTeamManagerAvgAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    salary?: true
    ord?: true
  }

  export type RelTeamTeamManagerSumAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    salary?: true
    ord?: true
  }

  export type RelTeamTeamManagerMinAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    managerTypeId?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    responsibilities?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelTeamTeamManagerMaxAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    managerTypeId?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    responsibilities?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelTeamTeamManagerCountAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    joinedAt?: true
    leftAt?: true
    status?: true
    managerTypeId?: true
    salary?: true
    contractStart?: true
    contractEnd?: true
    responsibilities?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelTeamTeamManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelTeamTeamManager to aggregate.
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamTeamManagers to fetch.
     */
    orderBy?: RelTeamTeamManagerOrderByWithRelationInput | RelTeamTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelTeamTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelTeamTeamManagers
    **/
    _count?: true | RelTeamTeamManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelTeamTeamManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelTeamTeamManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelTeamTeamManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelTeamTeamManagerMaxAggregateInputType
  }

  export type GetRelTeamTeamManagerAggregateType<T extends RelTeamTeamManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateRelTeamTeamManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelTeamTeamManager[P]>
      : GetScalarType<T[P], AggregateRelTeamTeamManager[P]>
  }




  export type RelTeamTeamManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelTeamTeamManagerWhereInput
    orderBy?: RelTeamTeamManagerOrderByWithAggregationInput | RelTeamTeamManagerOrderByWithAggregationInput[]
    by: RelTeamTeamManagerScalarFieldEnum[] | RelTeamTeamManagerScalarFieldEnum
    having?: RelTeamTeamManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelTeamTeamManagerCountAggregateInputType | true
    _avg?: RelTeamTeamManagerAvgAggregateInputType
    _sum?: RelTeamTeamManagerSumAggregateInputType
    _min?: RelTeamTeamManagerMinAggregateInputType
    _max?: RelTeamTeamManagerMaxAggregateInputType
  }

  export type RelTeamTeamManagerGroupByOutputType = {
    id: Decimal
    teamId: Decimal
    managerId: Decimal
    joinedAt: Date | null
    leftAt: Date | null
    status: string
    managerTypeId: string | null
    salary: Decimal | null
    contractStart: Date | null
    contractEnd: Date | null
    responsibilities: string | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: RelTeamTeamManagerCountAggregateOutputType | null
    _avg: RelTeamTeamManagerAvgAggregateOutputType | null
    _sum: RelTeamTeamManagerSumAggregateOutputType | null
    _min: RelTeamTeamManagerMinAggregateOutputType | null
    _max: RelTeamTeamManagerMaxAggregateOutputType | null
  }

  type GetRelTeamTeamManagerGroupByPayload<T extends RelTeamTeamManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelTeamTeamManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelTeamTeamManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelTeamTeamManagerGroupByOutputType[P]>
            : GetScalarType<T[P], RelTeamTeamManagerGroupByOutputType[P]>
        }
      >
    >


  export type RelTeamTeamManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    managerTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamTeamManager"]>

  export type RelTeamTeamManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    managerTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamTeamManager"]>

  export type RelTeamTeamManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    managerTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relTeamTeamManager"]>

  export type RelTeamTeamManagerSelectScalar = {
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    status?: boolean
    managerTypeId?: boolean
    salary?: boolean
    contractStart?: boolean
    contractEnd?: boolean
    responsibilities?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelTeamTeamManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "managerId" | "joinedAt" | "leftAt" | "status" | "managerTypeId" | "salary" | "contractStart" | "contractEnd" | "responsibilities" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["relTeamTeamManager"]>

  export type $RelTeamTeamManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelTeamTeamManager"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      teamId: Prisma.Decimal
      managerId: Prisma.Decimal
      joinedAt: Date | null
      leftAt: Date | null
      status: string
      managerTypeId: string | null
      salary: Prisma.Decimal | null
      contractStart: Date | null
      contractEnd: Date | null
      responsibilities: string | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["relTeamTeamManager"]>
    composites: {}
  }

  type RelTeamTeamManagerGetPayload<S extends boolean | null | undefined | RelTeamTeamManagerDefaultArgs> = $Result.GetResult<Prisma.$RelTeamTeamManagerPayload, S>

  type RelTeamTeamManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelTeamTeamManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelTeamTeamManagerCountAggregateInputType | true
    }

  export interface RelTeamTeamManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelTeamTeamManager'], meta: { name: 'RelTeamTeamManager' } }
    /**
     * Find zero or one RelTeamTeamManager that matches the filter.
     * @param {RelTeamTeamManagerFindUniqueArgs} args - Arguments to find a RelTeamTeamManager
     * @example
     * // Get one RelTeamTeamManager
     * const relTeamTeamManager = await prisma.relTeamTeamManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelTeamTeamManagerFindUniqueArgs>(args: SelectSubset<T, RelTeamTeamManagerFindUniqueArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RelTeamTeamManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelTeamTeamManagerFindUniqueOrThrowArgs} args - Arguments to find a RelTeamTeamManager
     * @example
     * // Get one RelTeamTeamManager
     * const relTeamTeamManager = await prisma.relTeamTeamManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelTeamTeamManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, RelTeamTeamManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelTeamTeamManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerFindFirstArgs} args - Arguments to find a RelTeamTeamManager
     * @example
     * // Get one RelTeamTeamManager
     * const relTeamTeamManager = await prisma.relTeamTeamManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelTeamTeamManagerFindFirstArgs>(args?: SelectSubset<T, RelTeamTeamManagerFindFirstArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RelTeamTeamManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerFindFirstOrThrowArgs} args - Arguments to find a RelTeamTeamManager
     * @example
     * // Get one RelTeamTeamManager
     * const relTeamTeamManager = await prisma.relTeamTeamManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelTeamTeamManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, RelTeamTeamManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RelTeamTeamManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelTeamTeamManagers
     * const relTeamTeamManagers = await prisma.relTeamTeamManager.findMany()
     * 
     * // Get first 10 RelTeamTeamManagers
     * const relTeamTeamManagers = await prisma.relTeamTeamManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relTeamTeamManagerWithIdOnly = await prisma.relTeamTeamManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelTeamTeamManagerFindManyArgs>(args?: SelectSubset<T, RelTeamTeamManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RelTeamTeamManager.
     * @param {RelTeamTeamManagerCreateArgs} args - Arguments to create a RelTeamTeamManager.
     * @example
     * // Create one RelTeamTeamManager
     * const RelTeamTeamManager = await prisma.relTeamTeamManager.create({
     *   data: {
     *     // ... data to create a RelTeamTeamManager
     *   }
     * })
     * 
     */
    create<T extends RelTeamTeamManagerCreateArgs>(args: SelectSubset<T, RelTeamTeamManagerCreateArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RelTeamTeamManagers.
     * @param {RelTeamTeamManagerCreateManyArgs} args - Arguments to create many RelTeamTeamManagers.
     * @example
     * // Create many RelTeamTeamManagers
     * const relTeamTeamManager = await prisma.relTeamTeamManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelTeamTeamManagerCreateManyArgs>(args?: SelectSubset<T, RelTeamTeamManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelTeamTeamManagers and returns the data saved in the database.
     * @param {RelTeamTeamManagerCreateManyAndReturnArgs} args - Arguments to create many RelTeamTeamManagers.
     * @example
     * // Create many RelTeamTeamManagers
     * const relTeamTeamManager = await prisma.relTeamTeamManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelTeamTeamManagers and only return the `id`
     * const relTeamTeamManagerWithIdOnly = await prisma.relTeamTeamManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelTeamTeamManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, RelTeamTeamManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RelTeamTeamManager.
     * @param {RelTeamTeamManagerDeleteArgs} args - Arguments to delete one RelTeamTeamManager.
     * @example
     * // Delete one RelTeamTeamManager
     * const RelTeamTeamManager = await prisma.relTeamTeamManager.delete({
     *   where: {
     *     // ... filter to delete one RelTeamTeamManager
     *   }
     * })
     * 
     */
    delete<T extends RelTeamTeamManagerDeleteArgs>(args: SelectSubset<T, RelTeamTeamManagerDeleteArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RelTeamTeamManager.
     * @param {RelTeamTeamManagerUpdateArgs} args - Arguments to update one RelTeamTeamManager.
     * @example
     * // Update one RelTeamTeamManager
     * const relTeamTeamManager = await prisma.relTeamTeamManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelTeamTeamManagerUpdateArgs>(args: SelectSubset<T, RelTeamTeamManagerUpdateArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RelTeamTeamManagers.
     * @param {RelTeamTeamManagerDeleteManyArgs} args - Arguments to filter RelTeamTeamManagers to delete.
     * @example
     * // Delete a few RelTeamTeamManagers
     * const { count } = await prisma.relTeamTeamManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelTeamTeamManagerDeleteManyArgs>(args?: SelectSubset<T, RelTeamTeamManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelTeamTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelTeamTeamManagers
     * const relTeamTeamManager = await prisma.relTeamTeamManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelTeamTeamManagerUpdateManyArgs>(args: SelectSubset<T, RelTeamTeamManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelTeamTeamManagers and returns the data updated in the database.
     * @param {RelTeamTeamManagerUpdateManyAndReturnArgs} args - Arguments to update many RelTeamTeamManagers.
     * @example
     * // Update many RelTeamTeamManagers
     * const relTeamTeamManager = await prisma.relTeamTeamManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RelTeamTeamManagers and only return the `id`
     * const relTeamTeamManagerWithIdOnly = await prisma.relTeamTeamManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelTeamTeamManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, RelTeamTeamManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RelTeamTeamManager.
     * @param {RelTeamTeamManagerUpsertArgs} args - Arguments to update or create a RelTeamTeamManager.
     * @example
     * // Update or create a RelTeamTeamManager
     * const relTeamTeamManager = await prisma.relTeamTeamManager.upsert({
     *   create: {
     *     // ... data to create a RelTeamTeamManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelTeamTeamManager we want to update
     *   }
     * })
     */
    upsert<T extends RelTeamTeamManagerUpsertArgs>(args: SelectSubset<T, RelTeamTeamManagerUpsertArgs<ExtArgs>>): Prisma__RelTeamTeamManagerClient<$Result.GetResult<Prisma.$RelTeamTeamManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RelTeamTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerCountArgs} args - Arguments to filter RelTeamTeamManagers to count.
     * @example
     * // Count the number of RelTeamTeamManagers
     * const count = await prisma.relTeamTeamManager.count({
     *   where: {
     *     // ... the filter for the RelTeamTeamManagers we want to count
     *   }
     * })
    **/
    count<T extends RelTeamTeamManagerCountArgs>(
      args?: Subset<T, RelTeamTeamManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelTeamTeamManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelTeamTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelTeamTeamManagerAggregateArgs>(args: Subset<T, RelTeamTeamManagerAggregateArgs>): Prisma.PrismaPromise<GetRelTeamTeamManagerAggregateType<T>>

    /**
     * Group by RelTeamTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelTeamTeamManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelTeamTeamManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelTeamTeamManagerGroupByArgs['orderBy'] }
        : { orderBy?: RelTeamTeamManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelTeamTeamManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelTeamTeamManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelTeamTeamManager model
   */
  readonly fields: RelTeamTeamManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelTeamTeamManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelTeamTeamManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelTeamTeamManager model
   */
  interface RelTeamTeamManagerFieldRefs {
    readonly id: FieldRef<"RelTeamTeamManager", 'Decimal'>
    readonly teamId: FieldRef<"RelTeamTeamManager", 'Decimal'>
    readonly managerId: FieldRef<"RelTeamTeamManager", 'Decimal'>
    readonly joinedAt: FieldRef<"RelTeamTeamManager", 'DateTime'>
    readonly leftAt: FieldRef<"RelTeamTeamManager", 'DateTime'>
    readonly status: FieldRef<"RelTeamTeamManager", 'String'>
    readonly managerTypeId: FieldRef<"RelTeamTeamManager", 'String'>
    readonly salary: FieldRef<"RelTeamTeamManager", 'Decimal'>
    readonly contractStart: FieldRef<"RelTeamTeamManager", 'DateTime'>
    readonly contractEnd: FieldRef<"RelTeamTeamManager", 'DateTime'>
    readonly responsibilities: FieldRef<"RelTeamTeamManager", 'String'>
    readonly notes: FieldRef<"RelTeamTeamManager", 'String'>
    readonly ord: FieldRef<"RelTeamTeamManager", 'Int'>
    readonly createdAt: FieldRef<"RelTeamTeamManager", 'DateTime'>
    readonly updatedAt: FieldRef<"RelTeamTeamManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelTeamTeamManager findUnique
   */
  export type RelTeamTeamManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamTeamManager to fetch.
     */
    where: RelTeamTeamManagerWhereUniqueInput
  }

  /**
   * RelTeamTeamManager findUniqueOrThrow
   */
  export type RelTeamTeamManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamTeamManager to fetch.
     */
    where: RelTeamTeamManagerWhereUniqueInput
  }

  /**
   * RelTeamTeamManager findFirst
   */
  export type RelTeamTeamManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamTeamManager to fetch.
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamTeamManagers to fetch.
     */
    orderBy?: RelTeamTeamManagerOrderByWithRelationInput | RelTeamTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelTeamTeamManagers.
     */
    cursor?: RelTeamTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelTeamTeamManagers.
     */
    distinct?: RelTeamTeamManagerScalarFieldEnum | RelTeamTeamManagerScalarFieldEnum[]
  }

  /**
   * RelTeamTeamManager findFirstOrThrow
   */
  export type RelTeamTeamManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamTeamManager to fetch.
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamTeamManagers to fetch.
     */
    orderBy?: RelTeamTeamManagerOrderByWithRelationInput | RelTeamTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelTeamTeamManagers.
     */
    cursor?: RelTeamTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelTeamTeamManagers.
     */
    distinct?: RelTeamTeamManagerScalarFieldEnum | RelTeamTeamManagerScalarFieldEnum[]
  }

  /**
   * RelTeamTeamManager findMany
   */
  export type RelTeamTeamManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which RelTeamTeamManagers to fetch.
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelTeamTeamManagers to fetch.
     */
    orderBy?: RelTeamTeamManagerOrderByWithRelationInput | RelTeamTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelTeamTeamManagers.
     */
    cursor?: RelTeamTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelTeamTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelTeamTeamManagers.
     */
    skip?: number
    distinct?: RelTeamTeamManagerScalarFieldEnum | RelTeamTeamManagerScalarFieldEnum[]
  }

  /**
   * RelTeamTeamManager create
   */
  export type RelTeamTeamManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to create a RelTeamTeamManager.
     */
    data: XOR<RelTeamTeamManagerCreateInput, RelTeamTeamManagerUncheckedCreateInput>
  }

  /**
   * RelTeamTeamManager createMany
   */
  export type RelTeamTeamManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelTeamTeamManagers.
     */
    data: RelTeamTeamManagerCreateManyInput | RelTeamTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelTeamTeamManager createManyAndReturn
   */
  export type RelTeamTeamManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to create many RelTeamTeamManagers.
     */
    data: RelTeamTeamManagerCreateManyInput | RelTeamTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelTeamTeamManager update
   */
  export type RelTeamTeamManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to update a RelTeamTeamManager.
     */
    data: XOR<RelTeamTeamManagerUpdateInput, RelTeamTeamManagerUncheckedUpdateInput>
    /**
     * Choose, which RelTeamTeamManager to update.
     */
    where: RelTeamTeamManagerWhereUniqueInput
  }

  /**
   * RelTeamTeamManager updateMany
   */
  export type RelTeamTeamManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelTeamTeamManagers.
     */
    data: XOR<RelTeamTeamManagerUpdateManyMutationInput, RelTeamTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which RelTeamTeamManagers to update
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * Limit how many RelTeamTeamManagers to update.
     */
    limit?: number
  }

  /**
   * RelTeamTeamManager updateManyAndReturn
   */
  export type RelTeamTeamManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to update RelTeamTeamManagers.
     */
    data: XOR<RelTeamTeamManagerUpdateManyMutationInput, RelTeamTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which RelTeamTeamManagers to update
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * Limit how many RelTeamTeamManagers to update.
     */
    limit?: number
  }

  /**
   * RelTeamTeamManager upsert
   */
  export type RelTeamTeamManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * The filter to search for the RelTeamTeamManager to update in case it exists.
     */
    where: RelTeamTeamManagerWhereUniqueInput
    /**
     * In case the RelTeamTeamManager found by the `where` argument doesn't exist, create a new RelTeamTeamManager with this data.
     */
    create: XOR<RelTeamTeamManagerCreateInput, RelTeamTeamManagerUncheckedCreateInput>
    /**
     * In case the RelTeamTeamManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelTeamTeamManagerUpdateInput, RelTeamTeamManagerUncheckedUpdateInput>
  }

  /**
   * RelTeamTeamManager delete
   */
  export type RelTeamTeamManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
    /**
     * Filter which RelTeamTeamManager to delete.
     */
    where: RelTeamTeamManagerWhereUniqueInput
  }

  /**
   * RelTeamTeamManager deleteMany
   */
  export type RelTeamTeamManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelTeamTeamManagers to delete
     */
    where?: RelTeamTeamManagerWhereInput
    /**
     * Limit how many RelTeamTeamManagers to delete.
     */
    limit?: number
  }

  /**
   * RelTeamTeamManager without action
   */
  export type RelTeamTeamManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelTeamTeamManager
     */
    select?: RelTeamTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RelTeamTeamManager
     */
    omit?: RelTeamTeamManagerOmit<ExtArgs> | null
  }


  /**
   * Model SportCoachType
   */

  export type AggregateSportCoachType = {
    _count: SportCoachTypeCountAggregateOutputType | null
    _avg: SportCoachTypeAvgAggregateOutputType | null
    _sum: SportCoachTypeSumAggregateOutputType | null
    _min: SportCoachTypeMinAggregateOutputType | null
    _max: SportCoachTypeMaxAggregateOutputType | null
  }

  export type SportCoachTypeAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SportCoachTypeSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SportCoachTypeMinAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    abbr: string | null
    color: string | null
    note: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportCoachTypeMaxAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    abbr: string | null
    color: string | null
    note: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportCoachTypeCountAggregateOutputType = {
    id: number
    sportId: number
    name: number
    abbr: number
    color: number
    note: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportCoachTypeAvgAggregateInputType = {
    id?: true
    sportId?: true
    isActive?: true
    ord?: true
  }

  export type SportCoachTypeSumAggregateInputType = {
    id?: true
    sportId?: true
    isActive?: true
    ord?: true
  }

  export type SportCoachTypeMinAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportCoachTypeMaxAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportCoachTypeCountAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportCoachTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportCoachType to aggregate.
     */
    where?: SportCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportCoachTypes to fetch.
     */
    orderBy?: SportCoachTypeOrderByWithRelationInput | SportCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportCoachTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SportCoachTypes
    **/
    _count?: true | SportCoachTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportCoachTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportCoachTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportCoachTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportCoachTypeMaxAggregateInputType
  }

  export type GetSportCoachTypeAggregateType<T extends SportCoachTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSportCoachType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSportCoachType[P]>
      : GetScalarType<T[P], AggregateSportCoachType[P]>
  }




  export type SportCoachTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportCoachTypeWhereInput
    orderBy?: SportCoachTypeOrderByWithAggregationInput | SportCoachTypeOrderByWithAggregationInput[]
    by: SportCoachTypeScalarFieldEnum[] | SportCoachTypeScalarFieldEnum
    having?: SportCoachTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportCoachTypeCountAggregateInputType | true
    _avg?: SportCoachTypeAvgAggregateInputType
    _sum?: SportCoachTypeSumAggregateInputType
    _min?: SportCoachTypeMinAggregateInputType
    _max?: SportCoachTypeMaxAggregateInputType
  }

  export type SportCoachTypeGroupByOutputType = {
    id: Decimal
    sportId: Decimal
    name: string
    abbr: string
    color: string
    note: string | null
    isActive: number
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SportCoachTypeCountAggregateOutputType | null
    _avg: SportCoachTypeAvgAggregateOutputType | null
    _sum: SportCoachTypeSumAggregateOutputType | null
    _min: SportCoachTypeMinAggregateOutputType | null
    _max: SportCoachTypeMaxAggregateOutputType | null
  }

  type GetSportCoachTypeGroupByPayload<T extends SportCoachTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportCoachTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportCoachTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportCoachTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SportCoachTypeGroupByOutputType[P]>
        }
      >
    >


  export type SportCoachTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportCoachType"]>

  export type SportCoachTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportCoachType"]>

  export type SportCoachTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportCoachType"]>

  export type SportCoachTypeSelectScalar = {
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportCoachTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "name" | "abbr" | "color" | "note" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["sportCoachType"]>

  export type $SportCoachTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SportCoachType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sportId: Prisma.Decimal
      name: string
      abbr: string
      color: string
      note: string | null
      isActive: number
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sportCoachType"]>
    composites: {}
  }

  type SportCoachTypeGetPayload<S extends boolean | null | undefined | SportCoachTypeDefaultArgs> = $Result.GetResult<Prisma.$SportCoachTypePayload, S>

  type SportCoachTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportCoachTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportCoachTypeCountAggregateInputType | true
    }

  export interface SportCoachTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SportCoachType'], meta: { name: 'SportCoachType' } }
    /**
     * Find zero or one SportCoachType that matches the filter.
     * @param {SportCoachTypeFindUniqueArgs} args - Arguments to find a SportCoachType
     * @example
     * // Get one SportCoachType
     * const sportCoachType = await prisma.sportCoachType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportCoachTypeFindUniqueArgs>(args: SelectSubset<T, SportCoachTypeFindUniqueArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SportCoachType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportCoachTypeFindUniqueOrThrowArgs} args - Arguments to find a SportCoachType
     * @example
     * // Get one SportCoachType
     * const sportCoachType = await prisma.sportCoachType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportCoachTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SportCoachTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportCoachType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeFindFirstArgs} args - Arguments to find a SportCoachType
     * @example
     * // Get one SportCoachType
     * const sportCoachType = await prisma.sportCoachType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportCoachTypeFindFirstArgs>(args?: SelectSubset<T, SportCoachTypeFindFirstArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportCoachType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeFindFirstOrThrowArgs} args - Arguments to find a SportCoachType
     * @example
     * // Get one SportCoachType
     * const sportCoachType = await prisma.sportCoachType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportCoachTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SportCoachTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SportCoachTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SportCoachTypes
     * const sportCoachTypes = await prisma.sportCoachType.findMany()
     * 
     * // Get first 10 SportCoachTypes
     * const sportCoachTypes = await prisma.sportCoachType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportCoachTypeWithIdOnly = await prisma.sportCoachType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportCoachTypeFindManyArgs>(args?: SelectSubset<T, SportCoachTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SportCoachType.
     * @param {SportCoachTypeCreateArgs} args - Arguments to create a SportCoachType.
     * @example
     * // Create one SportCoachType
     * const SportCoachType = await prisma.sportCoachType.create({
     *   data: {
     *     // ... data to create a SportCoachType
     *   }
     * })
     * 
     */
    create<T extends SportCoachTypeCreateArgs>(args: SelectSubset<T, SportCoachTypeCreateArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SportCoachTypes.
     * @param {SportCoachTypeCreateManyArgs} args - Arguments to create many SportCoachTypes.
     * @example
     * // Create many SportCoachTypes
     * const sportCoachType = await prisma.sportCoachType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportCoachTypeCreateManyArgs>(args?: SelectSubset<T, SportCoachTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SportCoachTypes and returns the data saved in the database.
     * @param {SportCoachTypeCreateManyAndReturnArgs} args - Arguments to create many SportCoachTypes.
     * @example
     * // Create many SportCoachTypes
     * const sportCoachType = await prisma.sportCoachType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SportCoachTypes and only return the `id`
     * const sportCoachTypeWithIdOnly = await prisma.sportCoachType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportCoachTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SportCoachTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SportCoachType.
     * @param {SportCoachTypeDeleteArgs} args - Arguments to delete one SportCoachType.
     * @example
     * // Delete one SportCoachType
     * const SportCoachType = await prisma.sportCoachType.delete({
     *   where: {
     *     // ... filter to delete one SportCoachType
     *   }
     * })
     * 
     */
    delete<T extends SportCoachTypeDeleteArgs>(args: SelectSubset<T, SportCoachTypeDeleteArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SportCoachType.
     * @param {SportCoachTypeUpdateArgs} args - Arguments to update one SportCoachType.
     * @example
     * // Update one SportCoachType
     * const sportCoachType = await prisma.sportCoachType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportCoachTypeUpdateArgs>(args: SelectSubset<T, SportCoachTypeUpdateArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SportCoachTypes.
     * @param {SportCoachTypeDeleteManyArgs} args - Arguments to filter SportCoachTypes to delete.
     * @example
     * // Delete a few SportCoachTypes
     * const { count } = await prisma.sportCoachType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportCoachTypeDeleteManyArgs>(args?: SelectSubset<T, SportCoachTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportCoachTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SportCoachTypes
     * const sportCoachType = await prisma.sportCoachType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportCoachTypeUpdateManyArgs>(args: SelectSubset<T, SportCoachTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportCoachTypes and returns the data updated in the database.
     * @param {SportCoachTypeUpdateManyAndReturnArgs} args - Arguments to update many SportCoachTypes.
     * @example
     * // Update many SportCoachTypes
     * const sportCoachType = await prisma.sportCoachType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SportCoachTypes and only return the `id`
     * const sportCoachTypeWithIdOnly = await prisma.sportCoachType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportCoachTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SportCoachTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SportCoachType.
     * @param {SportCoachTypeUpsertArgs} args - Arguments to update or create a SportCoachType.
     * @example
     * // Update or create a SportCoachType
     * const sportCoachType = await prisma.sportCoachType.upsert({
     *   create: {
     *     // ... data to create a SportCoachType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SportCoachType we want to update
     *   }
     * })
     */
    upsert<T extends SportCoachTypeUpsertArgs>(args: SelectSubset<T, SportCoachTypeUpsertArgs<ExtArgs>>): Prisma__SportCoachTypeClient<$Result.GetResult<Prisma.$SportCoachTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SportCoachTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeCountArgs} args - Arguments to filter SportCoachTypes to count.
     * @example
     * // Count the number of SportCoachTypes
     * const count = await prisma.sportCoachType.count({
     *   where: {
     *     // ... the filter for the SportCoachTypes we want to count
     *   }
     * })
    **/
    count<T extends SportCoachTypeCountArgs>(
      args?: Subset<T, SportCoachTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportCoachTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SportCoachType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportCoachTypeAggregateArgs>(args: Subset<T, SportCoachTypeAggregateArgs>): Prisma.PrismaPromise<GetSportCoachTypeAggregateType<T>>

    /**
     * Group by SportCoachType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCoachTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportCoachTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportCoachTypeGroupByArgs['orderBy'] }
        : { orderBy?: SportCoachTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportCoachTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportCoachTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SportCoachType model
   */
  readonly fields: SportCoachTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SportCoachType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportCoachTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SportCoachType model
   */
  interface SportCoachTypeFieldRefs {
    readonly id: FieldRef<"SportCoachType", 'Decimal'>
    readonly sportId: FieldRef<"SportCoachType", 'Decimal'>
    readonly name: FieldRef<"SportCoachType", 'String'>
    readonly abbr: FieldRef<"SportCoachType", 'String'>
    readonly color: FieldRef<"SportCoachType", 'String'>
    readonly note: FieldRef<"SportCoachType", 'String'>
    readonly isActive: FieldRef<"SportCoachType", 'Int'>
    readonly ord: FieldRef<"SportCoachType", 'Int'>
    readonly createdAt: FieldRef<"SportCoachType", 'DateTime'>
    readonly updatedAt: FieldRef<"SportCoachType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SportCoachType findUnique
   */
  export type SportCoachTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportCoachType to fetch.
     */
    where: SportCoachTypeWhereUniqueInput
  }

  /**
   * SportCoachType findUniqueOrThrow
   */
  export type SportCoachTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportCoachType to fetch.
     */
    where: SportCoachTypeWhereUniqueInput
  }

  /**
   * SportCoachType findFirst
   */
  export type SportCoachTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportCoachType to fetch.
     */
    where?: SportCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportCoachTypes to fetch.
     */
    orderBy?: SportCoachTypeOrderByWithRelationInput | SportCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportCoachTypes.
     */
    cursor?: SportCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportCoachTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportCoachTypes.
     */
    distinct?: SportCoachTypeScalarFieldEnum | SportCoachTypeScalarFieldEnum[]
  }

  /**
   * SportCoachType findFirstOrThrow
   */
  export type SportCoachTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportCoachType to fetch.
     */
    where?: SportCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportCoachTypes to fetch.
     */
    orderBy?: SportCoachTypeOrderByWithRelationInput | SportCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportCoachTypes.
     */
    cursor?: SportCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportCoachTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportCoachTypes.
     */
    distinct?: SportCoachTypeScalarFieldEnum | SportCoachTypeScalarFieldEnum[]
  }

  /**
   * SportCoachType findMany
   */
  export type SportCoachTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportCoachTypes to fetch.
     */
    where?: SportCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportCoachTypes to fetch.
     */
    orderBy?: SportCoachTypeOrderByWithRelationInput | SportCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SportCoachTypes.
     */
    cursor?: SportCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportCoachTypes.
     */
    skip?: number
    distinct?: SportCoachTypeScalarFieldEnum | SportCoachTypeScalarFieldEnum[]
  }

  /**
   * SportCoachType create
   */
  export type SportCoachTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a SportCoachType.
     */
    data: XOR<SportCoachTypeCreateInput, SportCoachTypeUncheckedCreateInput>
  }

  /**
   * SportCoachType createMany
   */
  export type SportCoachTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SportCoachTypes.
     */
    data: SportCoachTypeCreateManyInput | SportCoachTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportCoachType createManyAndReturn
   */
  export type SportCoachTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SportCoachTypes.
     */
    data: SportCoachTypeCreateManyInput | SportCoachTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportCoachType update
   */
  export type SportCoachTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a SportCoachType.
     */
    data: XOR<SportCoachTypeUpdateInput, SportCoachTypeUncheckedUpdateInput>
    /**
     * Choose, which SportCoachType to update.
     */
    where: SportCoachTypeWhereUniqueInput
  }

  /**
   * SportCoachType updateMany
   */
  export type SportCoachTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SportCoachTypes.
     */
    data: XOR<SportCoachTypeUpdateManyMutationInput, SportCoachTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportCoachTypes to update
     */
    where?: SportCoachTypeWhereInput
    /**
     * Limit how many SportCoachTypes to update.
     */
    limit?: number
  }

  /**
   * SportCoachType updateManyAndReturn
   */
  export type SportCoachTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * The data used to update SportCoachTypes.
     */
    data: XOR<SportCoachTypeUpdateManyMutationInput, SportCoachTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportCoachTypes to update
     */
    where?: SportCoachTypeWhereInput
    /**
     * Limit how many SportCoachTypes to update.
     */
    limit?: number
  }

  /**
   * SportCoachType upsert
   */
  export type SportCoachTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the SportCoachType to update in case it exists.
     */
    where: SportCoachTypeWhereUniqueInput
    /**
     * In case the SportCoachType found by the `where` argument doesn't exist, create a new SportCoachType with this data.
     */
    create: XOR<SportCoachTypeCreateInput, SportCoachTypeUncheckedCreateInput>
    /**
     * In case the SportCoachType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportCoachTypeUpdateInput, SportCoachTypeUncheckedUpdateInput>
  }

  /**
   * SportCoachType delete
   */
  export type SportCoachTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
    /**
     * Filter which SportCoachType to delete.
     */
    where: SportCoachTypeWhereUniqueInput
  }

  /**
   * SportCoachType deleteMany
   */
  export type SportCoachTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportCoachTypes to delete
     */
    where?: SportCoachTypeWhereInput
    /**
     * Limit how many SportCoachTypes to delete.
     */
    limit?: number
  }

  /**
   * SportCoachType without action
   */
  export type SportCoachTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCoachType
     */
    select?: SportCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportCoachType
     */
    omit?: SportCoachTypeOmit<ExtArgs> | null
  }


  /**
   * Model SportEventType
   */

  export type AggregateSportEventType = {
    _count: SportEventTypeCountAggregateOutputType | null
    _avg: SportEventTypeAvgAggregateOutputType | null
    _sum: SportEventTypeSumAggregateOutputType | null
    _min: SportEventTypeMinAggregateOutputType | null
    _max: SportEventTypeMaxAggregateOutputType | null
  }

  export type SportEventTypeAvgAggregateOutputType = {
    id: Decimal | null
    category: number | null
    evaluationMetric: number | null
    sportId: Decimal | null
    isVisible: number | null
    ord: number | null
    score: number | null
    slot: number | null
  }

  export type SportEventTypeSumAggregateOutputType = {
    id: Decimal | null
    category: number | null
    evaluationMetric: number | null
    sportId: Decimal | null
    isVisible: number | null
    ord: number | null
    score: number | null
    slot: number | null
  }

  export type SportEventTypeMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    category: number | null
    evaluationMetric: number | null
    code: string | null
    sportId: Decimal | null
    isVisible: number | null
    note: string | null
    ord: number | null
    score: number | null
    slot: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportEventTypeMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    category: number | null
    evaluationMetric: number | null
    code: string | null
    sportId: Decimal | null
    isVisible: number | null
    note: string | null
    ord: number | null
    score: number | null
    slot: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportEventTypeCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    category: number
    evaluationMetric: number
    code: number
    sportId: number
    isVisible: number
    note: number
    ord: number
    score: number
    slot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportEventTypeAvgAggregateInputType = {
    id?: true
    category?: true
    evaluationMetric?: true
    sportId?: true
    isVisible?: true
    ord?: true
    score?: true
    slot?: true
  }

  export type SportEventTypeSumAggregateInputType = {
    id?: true
    category?: true
    evaluationMetric?: true
    sportId?: true
    isVisible?: true
    ord?: true
    score?: true
    slot?: true
  }

  export type SportEventTypeMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    category?: true
    evaluationMetric?: true
    code?: true
    sportId?: true
    isVisible?: true
    note?: true
    ord?: true
    score?: true
    slot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportEventTypeMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    category?: true
    evaluationMetric?: true
    code?: true
    sportId?: true
    isVisible?: true
    note?: true
    ord?: true
    score?: true
    slot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportEventTypeCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    category?: true
    evaluationMetric?: true
    code?: true
    sportId?: true
    isVisible?: true
    note?: true
    ord?: true
    score?: true
    slot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportEventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportEventType to aggregate.
     */
    where?: SportEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportEventTypes to fetch.
     */
    orderBy?: SportEventTypeOrderByWithRelationInput | SportEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SportEventTypes
    **/
    _count?: true | SportEventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportEventTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportEventTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportEventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportEventTypeMaxAggregateInputType
  }

  export type GetSportEventTypeAggregateType<T extends SportEventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSportEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSportEventType[P]>
      : GetScalarType<T[P], AggregateSportEventType[P]>
  }




  export type SportEventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportEventTypeWhereInput
    orderBy?: SportEventTypeOrderByWithAggregationInput | SportEventTypeOrderByWithAggregationInput[]
    by: SportEventTypeScalarFieldEnum[] | SportEventTypeScalarFieldEnum
    having?: SportEventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportEventTypeCountAggregateInputType | true
    _avg?: SportEventTypeAvgAggregateInputType
    _sum?: SportEventTypeSumAggregateInputType
    _min?: SportEventTypeMinAggregateInputType
    _max?: SportEventTypeMaxAggregateInputType
  }

  export type SportEventTypeGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string | null
    category: number | null
    evaluationMetric: number | null
    code: string | null
    sportId: Decimal | null
    isVisible: number
    note: string | null
    ord: number | null
    score: number
    slot: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SportEventTypeCountAggregateOutputType | null
    _avg: SportEventTypeAvgAggregateOutputType | null
    _sum: SportEventTypeSumAggregateOutputType | null
    _min: SportEventTypeMinAggregateOutputType | null
    _max: SportEventTypeMaxAggregateOutputType | null
  }

  type GetSportEventTypeGroupByPayload<T extends SportEventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportEventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportEventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportEventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SportEventTypeGroupByOutputType[P]>
        }
      >
    >


  export type SportEventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    category?: boolean
    evaluationMetric?: boolean
    code?: boolean
    sportId?: boolean
    isVisible?: boolean
    note?: boolean
    ord?: boolean
    score?: boolean
    slot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportEventType"]>

  export type SportEventTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    category?: boolean
    evaluationMetric?: boolean
    code?: boolean
    sportId?: boolean
    isVisible?: boolean
    note?: boolean
    ord?: boolean
    score?: boolean
    slot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportEventType"]>

  export type SportEventTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    category?: boolean
    evaluationMetric?: boolean
    code?: boolean
    sportId?: boolean
    isVisible?: boolean
    note?: boolean
    ord?: boolean
    score?: boolean
    slot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportEventType"]>

  export type SportEventTypeSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    category?: boolean
    evaluationMetric?: boolean
    code?: boolean
    sportId?: boolean
    isVisible?: boolean
    note?: boolean
    ord?: boolean
    score?: boolean
    slot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportEventTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "category" | "evaluationMetric" | "code" | "sportId" | "isVisible" | "note" | "ord" | "score" | "slot" | "createdAt" | "updatedAt", ExtArgs["result"]["sportEventType"]>

  export type $SportEventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SportEventType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string | null
      category: number | null
      evaluationMetric: number | null
      code: string | null
      sportId: Prisma.Decimal | null
      isVisible: number
      note: string | null
      ord: number | null
      score: number
      slot: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sportEventType"]>
    composites: {}
  }

  type SportEventTypeGetPayload<S extends boolean | null | undefined | SportEventTypeDefaultArgs> = $Result.GetResult<Prisma.$SportEventTypePayload, S>

  type SportEventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportEventTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportEventTypeCountAggregateInputType | true
    }

  export interface SportEventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SportEventType'], meta: { name: 'SportEventType' } }
    /**
     * Find zero or one SportEventType that matches the filter.
     * @param {SportEventTypeFindUniqueArgs} args - Arguments to find a SportEventType
     * @example
     * // Get one SportEventType
     * const sportEventType = await prisma.sportEventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportEventTypeFindUniqueArgs>(args: SelectSubset<T, SportEventTypeFindUniqueArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SportEventType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportEventTypeFindUniqueOrThrowArgs} args - Arguments to find a SportEventType
     * @example
     * // Get one SportEventType
     * const sportEventType = await prisma.sportEventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportEventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SportEventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportEventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeFindFirstArgs} args - Arguments to find a SportEventType
     * @example
     * // Get one SportEventType
     * const sportEventType = await prisma.sportEventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportEventTypeFindFirstArgs>(args?: SelectSubset<T, SportEventTypeFindFirstArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportEventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeFindFirstOrThrowArgs} args - Arguments to find a SportEventType
     * @example
     * // Get one SportEventType
     * const sportEventType = await prisma.sportEventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportEventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SportEventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SportEventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SportEventTypes
     * const sportEventTypes = await prisma.sportEventType.findMany()
     * 
     * // Get first 10 SportEventTypes
     * const sportEventTypes = await prisma.sportEventType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportEventTypeWithIdOnly = await prisma.sportEventType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportEventTypeFindManyArgs>(args?: SelectSubset<T, SportEventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SportEventType.
     * @param {SportEventTypeCreateArgs} args - Arguments to create a SportEventType.
     * @example
     * // Create one SportEventType
     * const SportEventType = await prisma.sportEventType.create({
     *   data: {
     *     // ... data to create a SportEventType
     *   }
     * })
     * 
     */
    create<T extends SportEventTypeCreateArgs>(args: SelectSubset<T, SportEventTypeCreateArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SportEventTypes.
     * @param {SportEventTypeCreateManyArgs} args - Arguments to create many SportEventTypes.
     * @example
     * // Create many SportEventTypes
     * const sportEventType = await prisma.sportEventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportEventTypeCreateManyArgs>(args?: SelectSubset<T, SportEventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SportEventTypes and returns the data saved in the database.
     * @param {SportEventTypeCreateManyAndReturnArgs} args - Arguments to create many SportEventTypes.
     * @example
     * // Create many SportEventTypes
     * const sportEventType = await prisma.sportEventType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SportEventTypes and only return the `id`
     * const sportEventTypeWithIdOnly = await prisma.sportEventType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportEventTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SportEventTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SportEventType.
     * @param {SportEventTypeDeleteArgs} args - Arguments to delete one SportEventType.
     * @example
     * // Delete one SportEventType
     * const SportEventType = await prisma.sportEventType.delete({
     *   where: {
     *     // ... filter to delete one SportEventType
     *   }
     * })
     * 
     */
    delete<T extends SportEventTypeDeleteArgs>(args: SelectSubset<T, SportEventTypeDeleteArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SportEventType.
     * @param {SportEventTypeUpdateArgs} args - Arguments to update one SportEventType.
     * @example
     * // Update one SportEventType
     * const sportEventType = await prisma.sportEventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportEventTypeUpdateArgs>(args: SelectSubset<T, SportEventTypeUpdateArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SportEventTypes.
     * @param {SportEventTypeDeleteManyArgs} args - Arguments to filter SportEventTypes to delete.
     * @example
     * // Delete a few SportEventTypes
     * const { count } = await prisma.sportEventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportEventTypeDeleteManyArgs>(args?: SelectSubset<T, SportEventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SportEventTypes
     * const sportEventType = await prisma.sportEventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportEventTypeUpdateManyArgs>(args: SelectSubset<T, SportEventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportEventTypes and returns the data updated in the database.
     * @param {SportEventTypeUpdateManyAndReturnArgs} args - Arguments to update many SportEventTypes.
     * @example
     * // Update many SportEventTypes
     * const sportEventType = await prisma.sportEventType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SportEventTypes and only return the `id`
     * const sportEventTypeWithIdOnly = await prisma.sportEventType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportEventTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SportEventTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SportEventType.
     * @param {SportEventTypeUpsertArgs} args - Arguments to update or create a SportEventType.
     * @example
     * // Update or create a SportEventType
     * const sportEventType = await prisma.sportEventType.upsert({
     *   create: {
     *     // ... data to create a SportEventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SportEventType we want to update
     *   }
     * })
     */
    upsert<T extends SportEventTypeUpsertArgs>(args: SelectSubset<T, SportEventTypeUpsertArgs<ExtArgs>>): Prisma__SportEventTypeClient<$Result.GetResult<Prisma.$SportEventTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SportEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeCountArgs} args - Arguments to filter SportEventTypes to count.
     * @example
     * // Count the number of SportEventTypes
     * const count = await prisma.sportEventType.count({
     *   where: {
     *     // ... the filter for the SportEventTypes we want to count
     *   }
     * })
    **/
    count<T extends SportEventTypeCountArgs>(
      args?: Subset<T, SportEventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportEventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SportEventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportEventTypeAggregateArgs>(args: Subset<T, SportEventTypeAggregateArgs>): Prisma.PrismaPromise<GetSportEventTypeAggregateType<T>>

    /**
     * Group by SportEventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportEventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportEventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportEventTypeGroupByArgs['orderBy'] }
        : { orderBy?: SportEventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportEventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SportEventType model
   */
  readonly fields: SportEventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SportEventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportEventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SportEventType model
   */
  interface SportEventTypeFieldRefs {
    readonly id: FieldRef<"SportEventType", 'Decimal'>
    readonly name: FieldRef<"SportEventType", 'String'>
    readonly abbr: FieldRef<"SportEventType", 'String'>
    readonly category: FieldRef<"SportEventType", 'Int'>
    readonly evaluationMetric: FieldRef<"SportEventType", 'Int'>
    readonly code: FieldRef<"SportEventType", 'String'>
    readonly sportId: FieldRef<"SportEventType", 'Decimal'>
    readonly isVisible: FieldRef<"SportEventType", 'Int'>
    readonly note: FieldRef<"SportEventType", 'String'>
    readonly ord: FieldRef<"SportEventType", 'Int'>
    readonly score: FieldRef<"SportEventType", 'Int'>
    readonly slot: FieldRef<"SportEventType", 'Int'>
    readonly createdAt: FieldRef<"SportEventType", 'DateTime'>
    readonly updatedAt: FieldRef<"SportEventType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SportEventType findUnique
   */
  export type SportEventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportEventType to fetch.
     */
    where: SportEventTypeWhereUniqueInput
  }

  /**
   * SportEventType findUniqueOrThrow
   */
  export type SportEventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportEventType to fetch.
     */
    where: SportEventTypeWhereUniqueInput
  }

  /**
   * SportEventType findFirst
   */
  export type SportEventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportEventType to fetch.
     */
    where?: SportEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportEventTypes to fetch.
     */
    orderBy?: SportEventTypeOrderByWithRelationInput | SportEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportEventTypes.
     */
    cursor?: SportEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportEventTypes.
     */
    distinct?: SportEventTypeScalarFieldEnum | SportEventTypeScalarFieldEnum[]
  }

  /**
   * SportEventType findFirstOrThrow
   */
  export type SportEventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportEventType to fetch.
     */
    where?: SportEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportEventTypes to fetch.
     */
    orderBy?: SportEventTypeOrderByWithRelationInput | SportEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportEventTypes.
     */
    cursor?: SportEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportEventTypes.
     */
    distinct?: SportEventTypeScalarFieldEnum | SportEventTypeScalarFieldEnum[]
  }

  /**
   * SportEventType findMany
   */
  export type SportEventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportEventTypes to fetch.
     */
    where?: SportEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportEventTypes to fetch.
     */
    orderBy?: SportEventTypeOrderByWithRelationInput | SportEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SportEventTypes.
     */
    cursor?: SportEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportEventTypes.
     */
    skip?: number
    distinct?: SportEventTypeScalarFieldEnum | SportEventTypeScalarFieldEnum[]
  }

  /**
   * SportEventType create
   */
  export type SportEventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a SportEventType.
     */
    data: XOR<SportEventTypeCreateInput, SportEventTypeUncheckedCreateInput>
  }

  /**
   * SportEventType createMany
   */
  export type SportEventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SportEventTypes.
     */
    data: SportEventTypeCreateManyInput | SportEventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportEventType createManyAndReturn
   */
  export type SportEventTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SportEventTypes.
     */
    data: SportEventTypeCreateManyInput | SportEventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportEventType update
   */
  export type SportEventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a SportEventType.
     */
    data: XOR<SportEventTypeUpdateInput, SportEventTypeUncheckedUpdateInput>
    /**
     * Choose, which SportEventType to update.
     */
    where: SportEventTypeWhereUniqueInput
  }

  /**
   * SportEventType updateMany
   */
  export type SportEventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SportEventTypes.
     */
    data: XOR<SportEventTypeUpdateManyMutationInput, SportEventTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportEventTypes to update
     */
    where?: SportEventTypeWhereInput
    /**
     * Limit how many SportEventTypes to update.
     */
    limit?: number
  }

  /**
   * SportEventType updateManyAndReturn
   */
  export type SportEventTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * The data used to update SportEventTypes.
     */
    data: XOR<SportEventTypeUpdateManyMutationInput, SportEventTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportEventTypes to update
     */
    where?: SportEventTypeWhereInput
    /**
     * Limit how many SportEventTypes to update.
     */
    limit?: number
  }

  /**
   * SportEventType upsert
   */
  export type SportEventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the SportEventType to update in case it exists.
     */
    where: SportEventTypeWhereUniqueInput
    /**
     * In case the SportEventType found by the `where` argument doesn't exist, create a new SportEventType with this data.
     */
    create: XOR<SportEventTypeCreateInput, SportEventTypeUncheckedCreateInput>
    /**
     * In case the SportEventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportEventTypeUpdateInput, SportEventTypeUncheckedUpdateInput>
  }

  /**
   * SportEventType delete
   */
  export type SportEventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
    /**
     * Filter which SportEventType to delete.
     */
    where: SportEventTypeWhereUniqueInput
  }

  /**
   * SportEventType deleteMany
   */
  export type SportEventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportEventTypes to delete
     */
    where?: SportEventTypeWhereInput
    /**
     * Limit how many SportEventTypes to delete.
     */
    limit?: number
  }

  /**
   * SportEventType without action
   */
  export type SportEventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportEventType
     */
    select?: SportEventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportEventType
     */
    omit?: SportEventTypeOmit<ExtArgs> | null
  }


  /**
   * Model SportGamePeriod
   */

  export type AggregateSportGamePeriod = {
    _count: SportGamePeriodCountAggregateOutputType | null
    _avg: SportGamePeriodAvgAggregateOutputType | null
    _sum: SportGamePeriodSumAggregateOutputType | null
    _min: SportGamePeriodMinAggregateOutputType | null
    _max: SportGamePeriodMaxAggregateOutputType | null
  }

  export type SportGamePeriodAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    ord: number | null
    duration: number | null
  }

  export type SportGamePeriodSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    ord: number | null
    duration: number | null
  }

  export type SportGamePeriodMinAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    ord: number | null
    duration: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportGamePeriodMaxAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    ord: number | null
    duration: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportGamePeriodCountAggregateOutputType = {
    id: number
    sportId: number
    name: number
    ord: number
    duration: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportGamePeriodAvgAggregateInputType = {
    id?: true
    sportId?: true
    ord?: true
    duration?: true
  }

  export type SportGamePeriodSumAggregateInputType = {
    id?: true
    sportId?: true
    ord?: true
    duration?: true
  }

  export type SportGamePeriodMinAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    ord?: true
    duration?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportGamePeriodMaxAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    ord?: true
    duration?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportGamePeriodCountAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    ord?: true
    duration?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportGamePeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportGamePeriod to aggregate.
     */
    where?: SportGamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportGamePeriods to fetch.
     */
    orderBy?: SportGamePeriodOrderByWithRelationInput | SportGamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportGamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportGamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportGamePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SportGamePeriods
    **/
    _count?: true | SportGamePeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportGamePeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportGamePeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportGamePeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportGamePeriodMaxAggregateInputType
  }

  export type GetSportGamePeriodAggregateType<T extends SportGamePeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateSportGamePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSportGamePeriod[P]>
      : GetScalarType<T[P], AggregateSportGamePeriod[P]>
  }




  export type SportGamePeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportGamePeriodWhereInput
    orderBy?: SportGamePeriodOrderByWithAggregationInput | SportGamePeriodOrderByWithAggregationInput[]
    by: SportGamePeriodScalarFieldEnum[] | SportGamePeriodScalarFieldEnum
    having?: SportGamePeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportGamePeriodCountAggregateInputType | true
    _avg?: SportGamePeriodAvgAggregateInputType
    _sum?: SportGamePeriodSumAggregateInputType
    _min?: SportGamePeriodMinAggregateInputType
    _max?: SportGamePeriodMaxAggregateInputType
  }

  export type SportGamePeriodGroupByOutputType = {
    id: Decimal
    sportId: Decimal
    name: string
    ord: number
    duration: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SportGamePeriodCountAggregateOutputType | null
    _avg: SportGamePeriodAvgAggregateOutputType | null
    _sum: SportGamePeriodSumAggregateOutputType | null
    _min: SportGamePeriodMinAggregateOutputType | null
    _max: SportGamePeriodMaxAggregateOutputType | null
  }

  type GetSportGamePeriodGroupByPayload<T extends SportGamePeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportGamePeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportGamePeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportGamePeriodGroupByOutputType[P]>
            : GetScalarType<T[P], SportGamePeriodGroupByOutputType[P]>
        }
      >
    >


  export type SportGamePeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    ord?: boolean
    duration?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportGamePeriod"]>

  export type SportGamePeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    ord?: boolean
    duration?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportGamePeriod"]>

  export type SportGamePeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    ord?: boolean
    duration?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportGamePeriod"]>

  export type SportGamePeriodSelectScalar = {
    id?: boolean
    sportId?: boolean
    name?: boolean
    ord?: boolean
    duration?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportGamePeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "name" | "ord" | "duration" | "note" | "createdAt" | "updatedAt", ExtArgs["result"]["sportGamePeriod"]>

  export type $SportGamePeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SportGamePeriod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sportId: Prisma.Decimal
      name: string
      ord: number
      duration: number | null
      note: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sportGamePeriod"]>
    composites: {}
  }

  type SportGamePeriodGetPayload<S extends boolean | null | undefined | SportGamePeriodDefaultArgs> = $Result.GetResult<Prisma.$SportGamePeriodPayload, S>

  type SportGamePeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportGamePeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportGamePeriodCountAggregateInputType | true
    }

  export interface SportGamePeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SportGamePeriod'], meta: { name: 'SportGamePeriod' } }
    /**
     * Find zero or one SportGamePeriod that matches the filter.
     * @param {SportGamePeriodFindUniqueArgs} args - Arguments to find a SportGamePeriod
     * @example
     * // Get one SportGamePeriod
     * const sportGamePeriod = await prisma.sportGamePeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportGamePeriodFindUniqueArgs>(args: SelectSubset<T, SportGamePeriodFindUniqueArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SportGamePeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportGamePeriodFindUniqueOrThrowArgs} args - Arguments to find a SportGamePeriod
     * @example
     * // Get one SportGamePeriod
     * const sportGamePeriod = await prisma.sportGamePeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportGamePeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, SportGamePeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportGamePeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodFindFirstArgs} args - Arguments to find a SportGamePeriod
     * @example
     * // Get one SportGamePeriod
     * const sportGamePeriod = await prisma.sportGamePeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportGamePeriodFindFirstArgs>(args?: SelectSubset<T, SportGamePeriodFindFirstArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportGamePeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodFindFirstOrThrowArgs} args - Arguments to find a SportGamePeriod
     * @example
     * // Get one SportGamePeriod
     * const sportGamePeriod = await prisma.sportGamePeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportGamePeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, SportGamePeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SportGamePeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SportGamePeriods
     * const sportGamePeriods = await prisma.sportGamePeriod.findMany()
     * 
     * // Get first 10 SportGamePeriods
     * const sportGamePeriods = await prisma.sportGamePeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportGamePeriodWithIdOnly = await prisma.sportGamePeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportGamePeriodFindManyArgs>(args?: SelectSubset<T, SportGamePeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SportGamePeriod.
     * @param {SportGamePeriodCreateArgs} args - Arguments to create a SportGamePeriod.
     * @example
     * // Create one SportGamePeriod
     * const SportGamePeriod = await prisma.sportGamePeriod.create({
     *   data: {
     *     // ... data to create a SportGamePeriod
     *   }
     * })
     * 
     */
    create<T extends SportGamePeriodCreateArgs>(args: SelectSubset<T, SportGamePeriodCreateArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SportGamePeriods.
     * @param {SportGamePeriodCreateManyArgs} args - Arguments to create many SportGamePeriods.
     * @example
     * // Create many SportGamePeriods
     * const sportGamePeriod = await prisma.sportGamePeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportGamePeriodCreateManyArgs>(args?: SelectSubset<T, SportGamePeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SportGamePeriods and returns the data saved in the database.
     * @param {SportGamePeriodCreateManyAndReturnArgs} args - Arguments to create many SportGamePeriods.
     * @example
     * // Create many SportGamePeriods
     * const sportGamePeriod = await prisma.sportGamePeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SportGamePeriods and only return the `id`
     * const sportGamePeriodWithIdOnly = await prisma.sportGamePeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportGamePeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, SportGamePeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SportGamePeriod.
     * @param {SportGamePeriodDeleteArgs} args - Arguments to delete one SportGamePeriod.
     * @example
     * // Delete one SportGamePeriod
     * const SportGamePeriod = await prisma.sportGamePeriod.delete({
     *   where: {
     *     // ... filter to delete one SportGamePeriod
     *   }
     * })
     * 
     */
    delete<T extends SportGamePeriodDeleteArgs>(args: SelectSubset<T, SportGamePeriodDeleteArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SportGamePeriod.
     * @param {SportGamePeriodUpdateArgs} args - Arguments to update one SportGamePeriod.
     * @example
     * // Update one SportGamePeriod
     * const sportGamePeriod = await prisma.sportGamePeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportGamePeriodUpdateArgs>(args: SelectSubset<T, SportGamePeriodUpdateArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SportGamePeriods.
     * @param {SportGamePeriodDeleteManyArgs} args - Arguments to filter SportGamePeriods to delete.
     * @example
     * // Delete a few SportGamePeriods
     * const { count } = await prisma.sportGamePeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportGamePeriodDeleteManyArgs>(args?: SelectSubset<T, SportGamePeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportGamePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SportGamePeriods
     * const sportGamePeriod = await prisma.sportGamePeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportGamePeriodUpdateManyArgs>(args: SelectSubset<T, SportGamePeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportGamePeriods and returns the data updated in the database.
     * @param {SportGamePeriodUpdateManyAndReturnArgs} args - Arguments to update many SportGamePeriods.
     * @example
     * // Update many SportGamePeriods
     * const sportGamePeriod = await prisma.sportGamePeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SportGamePeriods and only return the `id`
     * const sportGamePeriodWithIdOnly = await prisma.sportGamePeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportGamePeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, SportGamePeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SportGamePeriod.
     * @param {SportGamePeriodUpsertArgs} args - Arguments to update or create a SportGamePeriod.
     * @example
     * // Update or create a SportGamePeriod
     * const sportGamePeriod = await prisma.sportGamePeriod.upsert({
     *   create: {
     *     // ... data to create a SportGamePeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SportGamePeriod we want to update
     *   }
     * })
     */
    upsert<T extends SportGamePeriodUpsertArgs>(args: SelectSubset<T, SportGamePeriodUpsertArgs<ExtArgs>>): Prisma__SportGamePeriodClient<$Result.GetResult<Prisma.$SportGamePeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SportGamePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodCountArgs} args - Arguments to filter SportGamePeriods to count.
     * @example
     * // Count the number of SportGamePeriods
     * const count = await prisma.sportGamePeriod.count({
     *   where: {
     *     // ... the filter for the SportGamePeriods we want to count
     *   }
     * })
    **/
    count<T extends SportGamePeriodCountArgs>(
      args?: Subset<T, SportGamePeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportGamePeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SportGamePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportGamePeriodAggregateArgs>(args: Subset<T, SportGamePeriodAggregateArgs>): Prisma.PrismaPromise<GetSportGamePeriodAggregateType<T>>

    /**
     * Group by SportGamePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGamePeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportGamePeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportGamePeriodGroupByArgs['orderBy'] }
        : { orderBy?: SportGamePeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportGamePeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportGamePeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SportGamePeriod model
   */
  readonly fields: SportGamePeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SportGamePeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportGamePeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SportGamePeriod model
   */
  interface SportGamePeriodFieldRefs {
    readonly id: FieldRef<"SportGamePeriod", 'Decimal'>
    readonly sportId: FieldRef<"SportGamePeriod", 'Decimal'>
    readonly name: FieldRef<"SportGamePeriod", 'String'>
    readonly ord: FieldRef<"SportGamePeriod", 'Int'>
    readonly duration: FieldRef<"SportGamePeriod", 'Int'>
    readonly note: FieldRef<"SportGamePeriod", 'String'>
    readonly createdAt: FieldRef<"SportGamePeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"SportGamePeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SportGamePeriod findUnique
   */
  export type SportGamePeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * Filter, which SportGamePeriod to fetch.
     */
    where: SportGamePeriodWhereUniqueInput
  }

  /**
   * SportGamePeriod findUniqueOrThrow
   */
  export type SportGamePeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * Filter, which SportGamePeriod to fetch.
     */
    where: SportGamePeriodWhereUniqueInput
  }

  /**
   * SportGamePeriod findFirst
   */
  export type SportGamePeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * Filter, which SportGamePeriod to fetch.
     */
    where?: SportGamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportGamePeriods to fetch.
     */
    orderBy?: SportGamePeriodOrderByWithRelationInput | SportGamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportGamePeriods.
     */
    cursor?: SportGamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportGamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportGamePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportGamePeriods.
     */
    distinct?: SportGamePeriodScalarFieldEnum | SportGamePeriodScalarFieldEnum[]
  }

  /**
   * SportGamePeriod findFirstOrThrow
   */
  export type SportGamePeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * Filter, which SportGamePeriod to fetch.
     */
    where?: SportGamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportGamePeriods to fetch.
     */
    orderBy?: SportGamePeriodOrderByWithRelationInput | SportGamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportGamePeriods.
     */
    cursor?: SportGamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportGamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportGamePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportGamePeriods.
     */
    distinct?: SportGamePeriodScalarFieldEnum | SportGamePeriodScalarFieldEnum[]
  }

  /**
   * SportGamePeriod findMany
   */
  export type SportGamePeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * Filter, which SportGamePeriods to fetch.
     */
    where?: SportGamePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportGamePeriods to fetch.
     */
    orderBy?: SportGamePeriodOrderByWithRelationInput | SportGamePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SportGamePeriods.
     */
    cursor?: SportGamePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportGamePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportGamePeriods.
     */
    skip?: number
    distinct?: SportGamePeriodScalarFieldEnum | SportGamePeriodScalarFieldEnum[]
  }

  /**
   * SportGamePeriod create
   */
  export type SportGamePeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * The data needed to create a SportGamePeriod.
     */
    data: XOR<SportGamePeriodCreateInput, SportGamePeriodUncheckedCreateInput>
  }

  /**
   * SportGamePeriod createMany
   */
  export type SportGamePeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SportGamePeriods.
     */
    data: SportGamePeriodCreateManyInput | SportGamePeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportGamePeriod createManyAndReturn
   */
  export type SportGamePeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * The data used to create many SportGamePeriods.
     */
    data: SportGamePeriodCreateManyInput | SportGamePeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportGamePeriod update
   */
  export type SportGamePeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * The data needed to update a SportGamePeriod.
     */
    data: XOR<SportGamePeriodUpdateInput, SportGamePeriodUncheckedUpdateInput>
    /**
     * Choose, which SportGamePeriod to update.
     */
    where: SportGamePeriodWhereUniqueInput
  }

  /**
   * SportGamePeriod updateMany
   */
  export type SportGamePeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SportGamePeriods.
     */
    data: XOR<SportGamePeriodUpdateManyMutationInput, SportGamePeriodUncheckedUpdateManyInput>
    /**
     * Filter which SportGamePeriods to update
     */
    where?: SportGamePeriodWhereInput
    /**
     * Limit how many SportGamePeriods to update.
     */
    limit?: number
  }

  /**
   * SportGamePeriod updateManyAndReturn
   */
  export type SportGamePeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * The data used to update SportGamePeriods.
     */
    data: XOR<SportGamePeriodUpdateManyMutationInput, SportGamePeriodUncheckedUpdateManyInput>
    /**
     * Filter which SportGamePeriods to update
     */
    where?: SportGamePeriodWhereInput
    /**
     * Limit how many SportGamePeriods to update.
     */
    limit?: number
  }

  /**
   * SportGamePeriod upsert
   */
  export type SportGamePeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * The filter to search for the SportGamePeriod to update in case it exists.
     */
    where: SportGamePeriodWhereUniqueInput
    /**
     * In case the SportGamePeriod found by the `where` argument doesn't exist, create a new SportGamePeriod with this data.
     */
    create: XOR<SportGamePeriodCreateInput, SportGamePeriodUncheckedCreateInput>
    /**
     * In case the SportGamePeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportGamePeriodUpdateInput, SportGamePeriodUncheckedUpdateInput>
  }

  /**
   * SportGamePeriod delete
   */
  export type SportGamePeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
    /**
     * Filter which SportGamePeriod to delete.
     */
    where: SportGamePeriodWhereUniqueInput
  }

  /**
   * SportGamePeriod deleteMany
   */
  export type SportGamePeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportGamePeriods to delete
     */
    where?: SportGamePeriodWhereInput
    /**
     * Limit how many SportGamePeriods to delete.
     */
    limit?: number
  }

  /**
   * SportGamePeriod without action
   */
  export type SportGamePeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportGamePeriod
     */
    select?: SportGamePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportGamePeriod
     */
    omit?: SportGamePeriodOmit<ExtArgs> | null
  }


  /**
   * Model SportManagerType
   */

  export type AggregateSportManagerType = {
    _count: SportManagerTypeCountAggregateOutputType | null
    _avg: SportManagerTypeAvgAggregateOutputType | null
    _sum: SportManagerTypeSumAggregateOutputType | null
    _min: SportManagerTypeMinAggregateOutputType | null
    _max: SportManagerTypeMaxAggregateOutputType | null
  }

  export type SportManagerTypeAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SportManagerTypeSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SportManagerTypeMinAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    abbr: string | null
    color: string | null
    note: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportManagerTypeMaxAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    abbr: string | null
    color: string | null
    note: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportManagerTypeCountAggregateOutputType = {
    id: number
    sportId: number
    name: number
    abbr: number
    color: number
    note: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportManagerTypeAvgAggregateInputType = {
    id?: true
    sportId?: true
    isActive?: true
    ord?: true
  }

  export type SportManagerTypeSumAggregateInputType = {
    id?: true
    sportId?: true
    isActive?: true
    ord?: true
  }

  export type SportManagerTypeMinAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportManagerTypeMaxAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportManagerTypeCountAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportManagerTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportManagerType to aggregate.
     */
    where?: SportManagerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportManagerTypes to fetch.
     */
    orderBy?: SportManagerTypeOrderByWithRelationInput | SportManagerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportManagerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportManagerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportManagerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SportManagerTypes
    **/
    _count?: true | SportManagerTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportManagerTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportManagerTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportManagerTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportManagerTypeMaxAggregateInputType
  }

  export type GetSportManagerTypeAggregateType<T extends SportManagerTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSportManagerType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSportManagerType[P]>
      : GetScalarType<T[P], AggregateSportManagerType[P]>
  }




  export type SportManagerTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportManagerTypeWhereInput
    orderBy?: SportManagerTypeOrderByWithAggregationInput | SportManagerTypeOrderByWithAggregationInput[]
    by: SportManagerTypeScalarFieldEnum[] | SportManagerTypeScalarFieldEnum
    having?: SportManagerTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportManagerTypeCountAggregateInputType | true
    _avg?: SportManagerTypeAvgAggregateInputType
    _sum?: SportManagerTypeSumAggregateInputType
    _min?: SportManagerTypeMinAggregateInputType
    _max?: SportManagerTypeMaxAggregateInputType
  }

  export type SportManagerTypeGroupByOutputType = {
    id: Decimal
    sportId: Decimal | null
    name: string
    abbr: string
    color: string
    note: string | null
    isActive: number
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SportManagerTypeCountAggregateOutputType | null
    _avg: SportManagerTypeAvgAggregateOutputType | null
    _sum: SportManagerTypeSumAggregateOutputType | null
    _min: SportManagerTypeMinAggregateOutputType | null
    _max: SportManagerTypeMaxAggregateOutputType | null
  }

  type GetSportManagerTypeGroupByPayload<T extends SportManagerTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportManagerTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportManagerTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportManagerTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SportManagerTypeGroupByOutputType[P]>
        }
      >
    >


  export type SportManagerTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportManagerType"]>

  export type SportManagerTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportManagerType"]>

  export type SportManagerTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportManagerType"]>

  export type SportManagerTypeSelectScalar = {
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportManagerTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "name" | "abbr" | "color" | "note" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["sportManagerType"]>

  export type $SportManagerTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SportManagerType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sportId: Prisma.Decimal | null
      name: string
      abbr: string
      color: string
      note: string | null
      isActive: number
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sportManagerType"]>
    composites: {}
  }

  type SportManagerTypeGetPayload<S extends boolean | null | undefined | SportManagerTypeDefaultArgs> = $Result.GetResult<Prisma.$SportManagerTypePayload, S>

  type SportManagerTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportManagerTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportManagerTypeCountAggregateInputType | true
    }

  export interface SportManagerTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SportManagerType'], meta: { name: 'SportManagerType' } }
    /**
     * Find zero or one SportManagerType that matches the filter.
     * @param {SportManagerTypeFindUniqueArgs} args - Arguments to find a SportManagerType
     * @example
     * // Get one SportManagerType
     * const sportManagerType = await prisma.sportManagerType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportManagerTypeFindUniqueArgs>(args: SelectSubset<T, SportManagerTypeFindUniqueArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SportManagerType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportManagerTypeFindUniqueOrThrowArgs} args - Arguments to find a SportManagerType
     * @example
     * // Get one SportManagerType
     * const sportManagerType = await prisma.sportManagerType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportManagerTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SportManagerTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportManagerType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeFindFirstArgs} args - Arguments to find a SportManagerType
     * @example
     * // Get one SportManagerType
     * const sportManagerType = await prisma.sportManagerType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportManagerTypeFindFirstArgs>(args?: SelectSubset<T, SportManagerTypeFindFirstArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportManagerType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeFindFirstOrThrowArgs} args - Arguments to find a SportManagerType
     * @example
     * // Get one SportManagerType
     * const sportManagerType = await prisma.sportManagerType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportManagerTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SportManagerTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SportManagerTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SportManagerTypes
     * const sportManagerTypes = await prisma.sportManagerType.findMany()
     * 
     * // Get first 10 SportManagerTypes
     * const sportManagerTypes = await prisma.sportManagerType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportManagerTypeWithIdOnly = await prisma.sportManagerType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportManagerTypeFindManyArgs>(args?: SelectSubset<T, SportManagerTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SportManagerType.
     * @param {SportManagerTypeCreateArgs} args - Arguments to create a SportManagerType.
     * @example
     * // Create one SportManagerType
     * const SportManagerType = await prisma.sportManagerType.create({
     *   data: {
     *     // ... data to create a SportManagerType
     *   }
     * })
     * 
     */
    create<T extends SportManagerTypeCreateArgs>(args: SelectSubset<T, SportManagerTypeCreateArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SportManagerTypes.
     * @param {SportManagerTypeCreateManyArgs} args - Arguments to create many SportManagerTypes.
     * @example
     * // Create many SportManagerTypes
     * const sportManagerType = await prisma.sportManagerType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportManagerTypeCreateManyArgs>(args?: SelectSubset<T, SportManagerTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SportManagerTypes and returns the data saved in the database.
     * @param {SportManagerTypeCreateManyAndReturnArgs} args - Arguments to create many SportManagerTypes.
     * @example
     * // Create many SportManagerTypes
     * const sportManagerType = await prisma.sportManagerType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SportManagerTypes and only return the `id`
     * const sportManagerTypeWithIdOnly = await prisma.sportManagerType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportManagerTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SportManagerTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SportManagerType.
     * @param {SportManagerTypeDeleteArgs} args - Arguments to delete one SportManagerType.
     * @example
     * // Delete one SportManagerType
     * const SportManagerType = await prisma.sportManagerType.delete({
     *   where: {
     *     // ... filter to delete one SportManagerType
     *   }
     * })
     * 
     */
    delete<T extends SportManagerTypeDeleteArgs>(args: SelectSubset<T, SportManagerTypeDeleteArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SportManagerType.
     * @param {SportManagerTypeUpdateArgs} args - Arguments to update one SportManagerType.
     * @example
     * // Update one SportManagerType
     * const sportManagerType = await prisma.sportManagerType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportManagerTypeUpdateArgs>(args: SelectSubset<T, SportManagerTypeUpdateArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SportManagerTypes.
     * @param {SportManagerTypeDeleteManyArgs} args - Arguments to filter SportManagerTypes to delete.
     * @example
     * // Delete a few SportManagerTypes
     * const { count } = await prisma.sportManagerType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportManagerTypeDeleteManyArgs>(args?: SelectSubset<T, SportManagerTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportManagerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SportManagerTypes
     * const sportManagerType = await prisma.sportManagerType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportManagerTypeUpdateManyArgs>(args: SelectSubset<T, SportManagerTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportManagerTypes and returns the data updated in the database.
     * @param {SportManagerTypeUpdateManyAndReturnArgs} args - Arguments to update many SportManagerTypes.
     * @example
     * // Update many SportManagerTypes
     * const sportManagerType = await prisma.sportManagerType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SportManagerTypes and only return the `id`
     * const sportManagerTypeWithIdOnly = await prisma.sportManagerType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportManagerTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SportManagerTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SportManagerType.
     * @param {SportManagerTypeUpsertArgs} args - Arguments to update or create a SportManagerType.
     * @example
     * // Update or create a SportManagerType
     * const sportManagerType = await prisma.sportManagerType.upsert({
     *   create: {
     *     // ... data to create a SportManagerType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SportManagerType we want to update
     *   }
     * })
     */
    upsert<T extends SportManagerTypeUpsertArgs>(args: SelectSubset<T, SportManagerTypeUpsertArgs<ExtArgs>>): Prisma__SportManagerTypeClient<$Result.GetResult<Prisma.$SportManagerTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SportManagerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeCountArgs} args - Arguments to filter SportManagerTypes to count.
     * @example
     * // Count the number of SportManagerTypes
     * const count = await prisma.sportManagerType.count({
     *   where: {
     *     // ... the filter for the SportManagerTypes we want to count
     *   }
     * })
    **/
    count<T extends SportManagerTypeCountArgs>(
      args?: Subset<T, SportManagerTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportManagerTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SportManagerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportManagerTypeAggregateArgs>(args: Subset<T, SportManagerTypeAggregateArgs>): Prisma.PrismaPromise<GetSportManagerTypeAggregateType<T>>

    /**
     * Group by SportManagerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportManagerTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportManagerTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportManagerTypeGroupByArgs['orderBy'] }
        : { orderBy?: SportManagerTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportManagerTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportManagerTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SportManagerType model
   */
  readonly fields: SportManagerTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SportManagerType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportManagerTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SportManagerType model
   */
  interface SportManagerTypeFieldRefs {
    readonly id: FieldRef<"SportManagerType", 'Decimal'>
    readonly sportId: FieldRef<"SportManagerType", 'Decimal'>
    readonly name: FieldRef<"SportManagerType", 'String'>
    readonly abbr: FieldRef<"SportManagerType", 'String'>
    readonly color: FieldRef<"SportManagerType", 'String'>
    readonly note: FieldRef<"SportManagerType", 'String'>
    readonly isActive: FieldRef<"SportManagerType", 'Int'>
    readonly ord: FieldRef<"SportManagerType", 'Int'>
    readonly createdAt: FieldRef<"SportManagerType", 'DateTime'>
    readonly updatedAt: FieldRef<"SportManagerType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SportManagerType findUnique
   */
  export type SportManagerTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportManagerType to fetch.
     */
    where: SportManagerTypeWhereUniqueInput
  }

  /**
   * SportManagerType findUniqueOrThrow
   */
  export type SportManagerTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportManagerType to fetch.
     */
    where: SportManagerTypeWhereUniqueInput
  }

  /**
   * SportManagerType findFirst
   */
  export type SportManagerTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportManagerType to fetch.
     */
    where?: SportManagerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportManagerTypes to fetch.
     */
    orderBy?: SportManagerTypeOrderByWithRelationInput | SportManagerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportManagerTypes.
     */
    cursor?: SportManagerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportManagerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportManagerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportManagerTypes.
     */
    distinct?: SportManagerTypeScalarFieldEnum | SportManagerTypeScalarFieldEnum[]
  }

  /**
   * SportManagerType findFirstOrThrow
   */
  export type SportManagerTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportManagerType to fetch.
     */
    where?: SportManagerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportManagerTypes to fetch.
     */
    orderBy?: SportManagerTypeOrderByWithRelationInput | SportManagerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportManagerTypes.
     */
    cursor?: SportManagerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportManagerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportManagerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportManagerTypes.
     */
    distinct?: SportManagerTypeScalarFieldEnum | SportManagerTypeScalarFieldEnum[]
  }

  /**
   * SportManagerType findMany
   */
  export type SportManagerTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportManagerTypes to fetch.
     */
    where?: SportManagerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportManagerTypes to fetch.
     */
    orderBy?: SportManagerTypeOrderByWithRelationInput | SportManagerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SportManagerTypes.
     */
    cursor?: SportManagerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportManagerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportManagerTypes.
     */
    skip?: number
    distinct?: SportManagerTypeScalarFieldEnum | SportManagerTypeScalarFieldEnum[]
  }

  /**
   * SportManagerType create
   */
  export type SportManagerTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a SportManagerType.
     */
    data: XOR<SportManagerTypeCreateInput, SportManagerTypeUncheckedCreateInput>
  }

  /**
   * SportManagerType createMany
   */
  export type SportManagerTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SportManagerTypes.
     */
    data: SportManagerTypeCreateManyInput | SportManagerTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportManagerType createManyAndReturn
   */
  export type SportManagerTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SportManagerTypes.
     */
    data: SportManagerTypeCreateManyInput | SportManagerTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportManagerType update
   */
  export type SportManagerTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a SportManagerType.
     */
    data: XOR<SportManagerTypeUpdateInput, SportManagerTypeUncheckedUpdateInput>
    /**
     * Choose, which SportManagerType to update.
     */
    where: SportManagerTypeWhereUniqueInput
  }

  /**
   * SportManagerType updateMany
   */
  export type SportManagerTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SportManagerTypes.
     */
    data: XOR<SportManagerTypeUpdateManyMutationInput, SportManagerTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportManagerTypes to update
     */
    where?: SportManagerTypeWhereInput
    /**
     * Limit how many SportManagerTypes to update.
     */
    limit?: number
  }

  /**
   * SportManagerType updateManyAndReturn
   */
  export type SportManagerTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * The data used to update SportManagerTypes.
     */
    data: XOR<SportManagerTypeUpdateManyMutationInput, SportManagerTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportManagerTypes to update
     */
    where?: SportManagerTypeWhereInput
    /**
     * Limit how many SportManagerTypes to update.
     */
    limit?: number
  }

  /**
   * SportManagerType upsert
   */
  export type SportManagerTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the SportManagerType to update in case it exists.
     */
    where: SportManagerTypeWhereUniqueInput
    /**
     * In case the SportManagerType found by the `where` argument doesn't exist, create a new SportManagerType with this data.
     */
    create: XOR<SportManagerTypeCreateInput, SportManagerTypeUncheckedCreateInput>
    /**
     * In case the SportManagerType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportManagerTypeUpdateInput, SportManagerTypeUncheckedUpdateInput>
  }

  /**
   * SportManagerType delete
   */
  export type SportManagerTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
    /**
     * Filter which SportManagerType to delete.
     */
    where: SportManagerTypeWhereUniqueInput
  }

  /**
   * SportManagerType deleteMany
   */
  export type SportManagerTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportManagerTypes to delete
     */
    where?: SportManagerTypeWhereInput
    /**
     * Limit how many SportManagerTypes to delete.
     */
    limit?: number
  }

  /**
   * SportManagerType without action
   */
  export type SportManagerTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportManagerType
     */
    select?: SportManagerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportManagerType
     */
    omit?: SportManagerTypeOmit<ExtArgs> | null
  }


  /**
   * Model SportPlayerPosition
   */

  export type AggregateSportPlayerPosition = {
    _count: SportPlayerPositionCountAggregateOutputType | null
    _avg: SportPlayerPositionAvgAggregateOutputType | null
    _sum: SportPlayerPositionSumAggregateOutputType | null
    _min: SportPlayerPositionMinAggregateOutputType | null
    _max: SportPlayerPositionMaxAggregateOutputType | null
  }

  export type SportPlayerPositionAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    ord: number | null
  }

  export type SportPlayerPositionSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    ord: number | null
  }

  export type SportPlayerPositionMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    note: string | null
    sportId: Decimal | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportPlayerPositionMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    abbr: string | null
    note: string | null
    sportId: Decimal | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportPlayerPositionCountAggregateOutputType = {
    id: number
    name: number
    abbr: number
    note: number
    sportId: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportPlayerPositionAvgAggregateInputType = {
    id?: true
    sportId?: true
    ord?: true
  }

  export type SportPlayerPositionSumAggregateInputType = {
    id?: true
    sportId?: true
    ord?: true
  }

  export type SportPlayerPositionMinAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    sportId?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportPlayerPositionMaxAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    sportId?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportPlayerPositionCountAggregateInputType = {
    id?: true
    name?: true
    abbr?: true
    note?: true
    sportId?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportPlayerPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportPlayerPosition to aggregate.
     */
    where?: SportPlayerPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportPlayerPositions to fetch.
     */
    orderBy?: SportPlayerPositionOrderByWithRelationInput | SportPlayerPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportPlayerPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportPlayerPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportPlayerPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SportPlayerPositions
    **/
    _count?: true | SportPlayerPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportPlayerPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportPlayerPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportPlayerPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportPlayerPositionMaxAggregateInputType
  }

  export type GetSportPlayerPositionAggregateType<T extends SportPlayerPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateSportPlayerPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSportPlayerPosition[P]>
      : GetScalarType<T[P], AggregateSportPlayerPosition[P]>
  }




  export type SportPlayerPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportPlayerPositionWhereInput
    orderBy?: SportPlayerPositionOrderByWithAggregationInput | SportPlayerPositionOrderByWithAggregationInput[]
    by: SportPlayerPositionScalarFieldEnum[] | SportPlayerPositionScalarFieldEnum
    having?: SportPlayerPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportPlayerPositionCountAggregateInputType | true
    _avg?: SportPlayerPositionAvgAggregateInputType
    _sum?: SportPlayerPositionSumAggregateInputType
    _min?: SportPlayerPositionMinAggregateInputType
    _max?: SportPlayerPositionMaxAggregateInputType
  }

  export type SportPlayerPositionGroupByOutputType = {
    id: Decimal
    name: string
    abbr: string
    note: string | null
    sportId: Decimal
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SportPlayerPositionCountAggregateOutputType | null
    _avg: SportPlayerPositionAvgAggregateOutputType | null
    _sum: SportPlayerPositionSumAggregateOutputType | null
    _min: SportPlayerPositionMinAggregateOutputType | null
    _max: SportPlayerPositionMaxAggregateOutputType | null
  }

  type GetSportPlayerPositionGroupByPayload<T extends SportPlayerPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportPlayerPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportPlayerPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportPlayerPositionGroupByOutputType[P]>
            : GetScalarType<T[P], SportPlayerPositionGroupByOutputType[P]>
        }
      >
    >


  export type SportPlayerPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    sportId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportPlayerPosition"]>

  export type SportPlayerPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    sportId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportPlayerPosition"]>

  export type SportPlayerPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    sportId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportPlayerPosition"]>

  export type SportPlayerPositionSelectScalar = {
    id?: boolean
    name?: boolean
    abbr?: boolean
    note?: boolean
    sportId?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportPlayerPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "abbr" | "note" | "sportId" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["sportPlayerPosition"]>

  export type $SportPlayerPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SportPlayerPosition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      abbr: string
      note: string | null
      sportId: Prisma.Decimal
      ord: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sportPlayerPosition"]>
    composites: {}
  }

  type SportPlayerPositionGetPayload<S extends boolean | null | undefined | SportPlayerPositionDefaultArgs> = $Result.GetResult<Prisma.$SportPlayerPositionPayload, S>

  type SportPlayerPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportPlayerPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportPlayerPositionCountAggregateInputType | true
    }

  export interface SportPlayerPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SportPlayerPosition'], meta: { name: 'SportPlayerPosition' } }
    /**
     * Find zero or one SportPlayerPosition that matches the filter.
     * @param {SportPlayerPositionFindUniqueArgs} args - Arguments to find a SportPlayerPosition
     * @example
     * // Get one SportPlayerPosition
     * const sportPlayerPosition = await prisma.sportPlayerPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportPlayerPositionFindUniqueArgs>(args: SelectSubset<T, SportPlayerPositionFindUniqueArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SportPlayerPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportPlayerPositionFindUniqueOrThrowArgs} args - Arguments to find a SportPlayerPosition
     * @example
     * // Get one SportPlayerPosition
     * const sportPlayerPosition = await prisma.sportPlayerPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportPlayerPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, SportPlayerPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportPlayerPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionFindFirstArgs} args - Arguments to find a SportPlayerPosition
     * @example
     * // Get one SportPlayerPosition
     * const sportPlayerPosition = await prisma.sportPlayerPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportPlayerPositionFindFirstArgs>(args?: SelectSubset<T, SportPlayerPositionFindFirstArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportPlayerPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionFindFirstOrThrowArgs} args - Arguments to find a SportPlayerPosition
     * @example
     * // Get one SportPlayerPosition
     * const sportPlayerPosition = await prisma.sportPlayerPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportPlayerPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, SportPlayerPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SportPlayerPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SportPlayerPositions
     * const sportPlayerPositions = await prisma.sportPlayerPosition.findMany()
     * 
     * // Get first 10 SportPlayerPositions
     * const sportPlayerPositions = await prisma.sportPlayerPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportPlayerPositionWithIdOnly = await prisma.sportPlayerPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportPlayerPositionFindManyArgs>(args?: SelectSubset<T, SportPlayerPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SportPlayerPosition.
     * @param {SportPlayerPositionCreateArgs} args - Arguments to create a SportPlayerPosition.
     * @example
     * // Create one SportPlayerPosition
     * const SportPlayerPosition = await prisma.sportPlayerPosition.create({
     *   data: {
     *     // ... data to create a SportPlayerPosition
     *   }
     * })
     * 
     */
    create<T extends SportPlayerPositionCreateArgs>(args: SelectSubset<T, SportPlayerPositionCreateArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SportPlayerPositions.
     * @param {SportPlayerPositionCreateManyArgs} args - Arguments to create many SportPlayerPositions.
     * @example
     * // Create many SportPlayerPositions
     * const sportPlayerPosition = await prisma.sportPlayerPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportPlayerPositionCreateManyArgs>(args?: SelectSubset<T, SportPlayerPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SportPlayerPositions and returns the data saved in the database.
     * @param {SportPlayerPositionCreateManyAndReturnArgs} args - Arguments to create many SportPlayerPositions.
     * @example
     * // Create many SportPlayerPositions
     * const sportPlayerPosition = await prisma.sportPlayerPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SportPlayerPositions and only return the `id`
     * const sportPlayerPositionWithIdOnly = await prisma.sportPlayerPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportPlayerPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, SportPlayerPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SportPlayerPosition.
     * @param {SportPlayerPositionDeleteArgs} args - Arguments to delete one SportPlayerPosition.
     * @example
     * // Delete one SportPlayerPosition
     * const SportPlayerPosition = await prisma.sportPlayerPosition.delete({
     *   where: {
     *     // ... filter to delete one SportPlayerPosition
     *   }
     * })
     * 
     */
    delete<T extends SportPlayerPositionDeleteArgs>(args: SelectSubset<T, SportPlayerPositionDeleteArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SportPlayerPosition.
     * @param {SportPlayerPositionUpdateArgs} args - Arguments to update one SportPlayerPosition.
     * @example
     * // Update one SportPlayerPosition
     * const sportPlayerPosition = await prisma.sportPlayerPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportPlayerPositionUpdateArgs>(args: SelectSubset<T, SportPlayerPositionUpdateArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SportPlayerPositions.
     * @param {SportPlayerPositionDeleteManyArgs} args - Arguments to filter SportPlayerPositions to delete.
     * @example
     * // Delete a few SportPlayerPositions
     * const { count } = await prisma.sportPlayerPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportPlayerPositionDeleteManyArgs>(args?: SelectSubset<T, SportPlayerPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportPlayerPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SportPlayerPositions
     * const sportPlayerPosition = await prisma.sportPlayerPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportPlayerPositionUpdateManyArgs>(args: SelectSubset<T, SportPlayerPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportPlayerPositions and returns the data updated in the database.
     * @param {SportPlayerPositionUpdateManyAndReturnArgs} args - Arguments to update many SportPlayerPositions.
     * @example
     * // Update many SportPlayerPositions
     * const sportPlayerPosition = await prisma.sportPlayerPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SportPlayerPositions and only return the `id`
     * const sportPlayerPositionWithIdOnly = await prisma.sportPlayerPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportPlayerPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, SportPlayerPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SportPlayerPosition.
     * @param {SportPlayerPositionUpsertArgs} args - Arguments to update or create a SportPlayerPosition.
     * @example
     * // Update or create a SportPlayerPosition
     * const sportPlayerPosition = await prisma.sportPlayerPosition.upsert({
     *   create: {
     *     // ... data to create a SportPlayerPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SportPlayerPosition we want to update
     *   }
     * })
     */
    upsert<T extends SportPlayerPositionUpsertArgs>(args: SelectSubset<T, SportPlayerPositionUpsertArgs<ExtArgs>>): Prisma__SportPlayerPositionClient<$Result.GetResult<Prisma.$SportPlayerPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SportPlayerPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionCountArgs} args - Arguments to filter SportPlayerPositions to count.
     * @example
     * // Count the number of SportPlayerPositions
     * const count = await prisma.sportPlayerPosition.count({
     *   where: {
     *     // ... the filter for the SportPlayerPositions we want to count
     *   }
     * })
    **/
    count<T extends SportPlayerPositionCountArgs>(
      args?: Subset<T, SportPlayerPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportPlayerPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SportPlayerPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportPlayerPositionAggregateArgs>(args: Subset<T, SportPlayerPositionAggregateArgs>): Prisma.PrismaPromise<GetSportPlayerPositionAggregateType<T>>

    /**
     * Group by SportPlayerPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportPlayerPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportPlayerPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportPlayerPositionGroupByArgs['orderBy'] }
        : { orderBy?: SportPlayerPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportPlayerPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportPlayerPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SportPlayerPosition model
   */
  readonly fields: SportPlayerPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SportPlayerPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportPlayerPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SportPlayerPosition model
   */
  interface SportPlayerPositionFieldRefs {
    readonly id: FieldRef<"SportPlayerPosition", 'Decimal'>
    readonly name: FieldRef<"SportPlayerPosition", 'String'>
    readonly abbr: FieldRef<"SportPlayerPosition", 'String'>
    readonly note: FieldRef<"SportPlayerPosition", 'String'>
    readonly sportId: FieldRef<"SportPlayerPosition", 'Decimal'>
    readonly ord: FieldRef<"SportPlayerPosition", 'Int'>
    readonly createdAt: FieldRef<"SportPlayerPosition", 'DateTime'>
    readonly updatedAt: FieldRef<"SportPlayerPosition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SportPlayerPosition findUnique
   */
  export type SportPlayerPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * Filter, which SportPlayerPosition to fetch.
     */
    where: SportPlayerPositionWhereUniqueInput
  }

  /**
   * SportPlayerPosition findUniqueOrThrow
   */
  export type SportPlayerPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * Filter, which SportPlayerPosition to fetch.
     */
    where: SportPlayerPositionWhereUniqueInput
  }

  /**
   * SportPlayerPosition findFirst
   */
  export type SportPlayerPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * Filter, which SportPlayerPosition to fetch.
     */
    where?: SportPlayerPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportPlayerPositions to fetch.
     */
    orderBy?: SportPlayerPositionOrderByWithRelationInput | SportPlayerPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportPlayerPositions.
     */
    cursor?: SportPlayerPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportPlayerPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportPlayerPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportPlayerPositions.
     */
    distinct?: SportPlayerPositionScalarFieldEnum | SportPlayerPositionScalarFieldEnum[]
  }

  /**
   * SportPlayerPosition findFirstOrThrow
   */
  export type SportPlayerPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * Filter, which SportPlayerPosition to fetch.
     */
    where?: SportPlayerPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportPlayerPositions to fetch.
     */
    orderBy?: SportPlayerPositionOrderByWithRelationInput | SportPlayerPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportPlayerPositions.
     */
    cursor?: SportPlayerPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportPlayerPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportPlayerPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportPlayerPositions.
     */
    distinct?: SportPlayerPositionScalarFieldEnum | SportPlayerPositionScalarFieldEnum[]
  }

  /**
   * SportPlayerPosition findMany
   */
  export type SportPlayerPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * Filter, which SportPlayerPositions to fetch.
     */
    where?: SportPlayerPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportPlayerPositions to fetch.
     */
    orderBy?: SportPlayerPositionOrderByWithRelationInput | SportPlayerPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SportPlayerPositions.
     */
    cursor?: SportPlayerPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportPlayerPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportPlayerPositions.
     */
    skip?: number
    distinct?: SportPlayerPositionScalarFieldEnum | SportPlayerPositionScalarFieldEnum[]
  }

  /**
   * SportPlayerPosition create
   */
  export type SportPlayerPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * The data needed to create a SportPlayerPosition.
     */
    data: XOR<SportPlayerPositionCreateInput, SportPlayerPositionUncheckedCreateInput>
  }

  /**
   * SportPlayerPosition createMany
   */
  export type SportPlayerPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SportPlayerPositions.
     */
    data: SportPlayerPositionCreateManyInput | SportPlayerPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportPlayerPosition createManyAndReturn
   */
  export type SportPlayerPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * The data used to create many SportPlayerPositions.
     */
    data: SportPlayerPositionCreateManyInput | SportPlayerPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportPlayerPosition update
   */
  export type SportPlayerPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * The data needed to update a SportPlayerPosition.
     */
    data: XOR<SportPlayerPositionUpdateInput, SportPlayerPositionUncheckedUpdateInput>
    /**
     * Choose, which SportPlayerPosition to update.
     */
    where: SportPlayerPositionWhereUniqueInput
  }

  /**
   * SportPlayerPosition updateMany
   */
  export type SportPlayerPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SportPlayerPositions.
     */
    data: XOR<SportPlayerPositionUpdateManyMutationInput, SportPlayerPositionUncheckedUpdateManyInput>
    /**
     * Filter which SportPlayerPositions to update
     */
    where?: SportPlayerPositionWhereInput
    /**
     * Limit how many SportPlayerPositions to update.
     */
    limit?: number
  }

  /**
   * SportPlayerPosition updateManyAndReturn
   */
  export type SportPlayerPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * The data used to update SportPlayerPositions.
     */
    data: XOR<SportPlayerPositionUpdateManyMutationInput, SportPlayerPositionUncheckedUpdateManyInput>
    /**
     * Filter which SportPlayerPositions to update
     */
    where?: SportPlayerPositionWhereInput
    /**
     * Limit how many SportPlayerPositions to update.
     */
    limit?: number
  }

  /**
   * SportPlayerPosition upsert
   */
  export type SportPlayerPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * The filter to search for the SportPlayerPosition to update in case it exists.
     */
    where: SportPlayerPositionWhereUniqueInput
    /**
     * In case the SportPlayerPosition found by the `where` argument doesn't exist, create a new SportPlayerPosition with this data.
     */
    create: XOR<SportPlayerPositionCreateInput, SportPlayerPositionUncheckedCreateInput>
    /**
     * In case the SportPlayerPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportPlayerPositionUpdateInput, SportPlayerPositionUncheckedUpdateInput>
  }

  /**
   * SportPlayerPosition delete
   */
  export type SportPlayerPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
    /**
     * Filter which SportPlayerPosition to delete.
     */
    where: SportPlayerPositionWhereUniqueInput
  }

  /**
   * SportPlayerPosition deleteMany
   */
  export type SportPlayerPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportPlayerPositions to delete
     */
    where?: SportPlayerPositionWhereInput
    /**
     * Limit how many SportPlayerPositions to delete.
     */
    limit?: number
  }

  /**
   * SportPlayerPosition without action
   */
  export type SportPlayerPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportPlayerPosition
     */
    select?: SportPlayerPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportPlayerPosition
     */
    omit?: SportPlayerPositionOmit<ExtArgs> | null
  }


  /**
   * Model SportRefereeType
   */

  export type AggregateSportRefereeType = {
    _count: SportRefereeTypeCountAggregateOutputType | null
    _avg: SportRefereeTypeAvgAggregateOutputType | null
    _sum: SportRefereeTypeSumAggregateOutputType | null
    _min: SportRefereeTypeMinAggregateOutputType | null
    _max: SportRefereeTypeMaxAggregateOutputType | null
  }

  export type SportRefereeTypeAvgAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SportRefereeTypeSumAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SportRefereeTypeMinAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    abbr: string | null
    color: string | null
    note: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportRefereeTypeMaxAggregateOutputType = {
    id: Decimal | null
    sportId: Decimal | null
    name: string | null
    abbr: string | null
    color: string | null
    note: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SportRefereeTypeCountAggregateOutputType = {
    id: number
    sportId: number
    name: number
    abbr: number
    color: number
    note: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SportRefereeTypeAvgAggregateInputType = {
    id?: true
    sportId?: true
    isActive?: true
    ord?: true
  }

  export type SportRefereeTypeSumAggregateInputType = {
    id?: true
    sportId?: true
    isActive?: true
    ord?: true
  }

  export type SportRefereeTypeMinAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportRefereeTypeMaxAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SportRefereeTypeCountAggregateInputType = {
    id?: true
    sportId?: true
    name?: true
    abbr?: true
    color?: true
    note?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SportRefereeTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportRefereeType to aggregate.
     */
    where?: SportRefereeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportRefereeTypes to fetch.
     */
    orderBy?: SportRefereeTypeOrderByWithRelationInput | SportRefereeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportRefereeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportRefereeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportRefereeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SportRefereeTypes
    **/
    _count?: true | SportRefereeTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportRefereeTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportRefereeTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportRefereeTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportRefereeTypeMaxAggregateInputType
  }

  export type GetSportRefereeTypeAggregateType<T extends SportRefereeTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSportRefereeType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSportRefereeType[P]>
      : GetScalarType<T[P], AggregateSportRefereeType[P]>
  }




  export type SportRefereeTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportRefereeTypeWhereInput
    orderBy?: SportRefereeTypeOrderByWithAggregationInput | SportRefereeTypeOrderByWithAggregationInput[]
    by: SportRefereeTypeScalarFieldEnum[] | SportRefereeTypeScalarFieldEnum
    having?: SportRefereeTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportRefereeTypeCountAggregateInputType | true
    _avg?: SportRefereeTypeAvgAggregateInputType
    _sum?: SportRefereeTypeSumAggregateInputType
    _min?: SportRefereeTypeMinAggregateInputType
    _max?: SportRefereeTypeMaxAggregateInputType
  }

  export type SportRefereeTypeGroupByOutputType = {
    id: Decimal
    sportId: Decimal
    name: string
    abbr: string
    color: string
    note: string | null
    isActive: number
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SportRefereeTypeCountAggregateOutputType | null
    _avg: SportRefereeTypeAvgAggregateOutputType | null
    _sum: SportRefereeTypeSumAggregateOutputType | null
    _min: SportRefereeTypeMinAggregateOutputType | null
    _max: SportRefereeTypeMaxAggregateOutputType | null
  }

  type GetSportRefereeTypeGroupByPayload<T extends SportRefereeTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportRefereeTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportRefereeTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportRefereeTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SportRefereeTypeGroupByOutputType[P]>
        }
      >
    >


  export type SportRefereeTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportRefereeType"]>

  export type SportRefereeTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportRefereeType"]>

  export type SportRefereeTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sportRefereeType"]>

  export type SportRefereeTypeSelectScalar = {
    id?: boolean
    sportId?: boolean
    name?: boolean
    abbr?: boolean
    color?: boolean
    note?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SportRefereeTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sportId" | "name" | "abbr" | "color" | "note" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["sportRefereeType"]>

  export type $SportRefereeTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SportRefereeType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      sportId: Prisma.Decimal
      name: string
      abbr: string
      color: string
      note: string | null
      isActive: number
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sportRefereeType"]>
    composites: {}
  }

  type SportRefereeTypeGetPayload<S extends boolean | null | undefined | SportRefereeTypeDefaultArgs> = $Result.GetResult<Prisma.$SportRefereeTypePayload, S>

  type SportRefereeTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportRefereeTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportRefereeTypeCountAggregateInputType | true
    }

  export interface SportRefereeTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SportRefereeType'], meta: { name: 'SportRefereeType' } }
    /**
     * Find zero or one SportRefereeType that matches the filter.
     * @param {SportRefereeTypeFindUniqueArgs} args - Arguments to find a SportRefereeType
     * @example
     * // Get one SportRefereeType
     * const sportRefereeType = await prisma.sportRefereeType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportRefereeTypeFindUniqueArgs>(args: SelectSubset<T, SportRefereeTypeFindUniqueArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SportRefereeType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportRefereeTypeFindUniqueOrThrowArgs} args - Arguments to find a SportRefereeType
     * @example
     * // Get one SportRefereeType
     * const sportRefereeType = await prisma.sportRefereeType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportRefereeTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SportRefereeTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportRefereeType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeFindFirstArgs} args - Arguments to find a SportRefereeType
     * @example
     * // Get one SportRefereeType
     * const sportRefereeType = await prisma.sportRefereeType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportRefereeTypeFindFirstArgs>(args?: SelectSubset<T, SportRefereeTypeFindFirstArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SportRefereeType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeFindFirstOrThrowArgs} args - Arguments to find a SportRefereeType
     * @example
     * // Get one SportRefereeType
     * const sportRefereeType = await prisma.sportRefereeType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportRefereeTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SportRefereeTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SportRefereeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SportRefereeTypes
     * const sportRefereeTypes = await prisma.sportRefereeType.findMany()
     * 
     * // Get first 10 SportRefereeTypes
     * const sportRefereeTypes = await prisma.sportRefereeType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportRefereeTypeWithIdOnly = await prisma.sportRefereeType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportRefereeTypeFindManyArgs>(args?: SelectSubset<T, SportRefereeTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SportRefereeType.
     * @param {SportRefereeTypeCreateArgs} args - Arguments to create a SportRefereeType.
     * @example
     * // Create one SportRefereeType
     * const SportRefereeType = await prisma.sportRefereeType.create({
     *   data: {
     *     // ... data to create a SportRefereeType
     *   }
     * })
     * 
     */
    create<T extends SportRefereeTypeCreateArgs>(args: SelectSubset<T, SportRefereeTypeCreateArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SportRefereeTypes.
     * @param {SportRefereeTypeCreateManyArgs} args - Arguments to create many SportRefereeTypes.
     * @example
     * // Create many SportRefereeTypes
     * const sportRefereeType = await prisma.sportRefereeType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportRefereeTypeCreateManyArgs>(args?: SelectSubset<T, SportRefereeTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SportRefereeTypes and returns the data saved in the database.
     * @param {SportRefereeTypeCreateManyAndReturnArgs} args - Arguments to create many SportRefereeTypes.
     * @example
     * // Create many SportRefereeTypes
     * const sportRefereeType = await prisma.sportRefereeType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SportRefereeTypes and only return the `id`
     * const sportRefereeTypeWithIdOnly = await prisma.sportRefereeType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportRefereeTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SportRefereeTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SportRefereeType.
     * @param {SportRefereeTypeDeleteArgs} args - Arguments to delete one SportRefereeType.
     * @example
     * // Delete one SportRefereeType
     * const SportRefereeType = await prisma.sportRefereeType.delete({
     *   where: {
     *     // ... filter to delete one SportRefereeType
     *   }
     * })
     * 
     */
    delete<T extends SportRefereeTypeDeleteArgs>(args: SelectSubset<T, SportRefereeTypeDeleteArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SportRefereeType.
     * @param {SportRefereeTypeUpdateArgs} args - Arguments to update one SportRefereeType.
     * @example
     * // Update one SportRefereeType
     * const sportRefereeType = await prisma.sportRefereeType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportRefereeTypeUpdateArgs>(args: SelectSubset<T, SportRefereeTypeUpdateArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SportRefereeTypes.
     * @param {SportRefereeTypeDeleteManyArgs} args - Arguments to filter SportRefereeTypes to delete.
     * @example
     * // Delete a few SportRefereeTypes
     * const { count } = await prisma.sportRefereeType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportRefereeTypeDeleteManyArgs>(args?: SelectSubset<T, SportRefereeTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportRefereeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SportRefereeTypes
     * const sportRefereeType = await prisma.sportRefereeType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportRefereeTypeUpdateManyArgs>(args: SelectSubset<T, SportRefereeTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SportRefereeTypes and returns the data updated in the database.
     * @param {SportRefereeTypeUpdateManyAndReturnArgs} args - Arguments to update many SportRefereeTypes.
     * @example
     * // Update many SportRefereeTypes
     * const sportRefereeType = await prisma.sportRefereeType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SportRefereeTypes and only return the `id`
     * const sportRefereeTypeWithIdOnly = await prisma.sportRefereeType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportRefereeTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SportRefereeTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SportRefereeType.
     * @param {SportRefereeTypeUpsertArgs} args - Arguments to update or create a SportRefereeType.
     * @example
     * // Update or create a SportRefereeType
     * const sportRefereeType = await prisma.sportRefereeType.upsert({
     *   create: {
     *     // ... data to create a SportRefereeType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SportRefereeType we want to update
     *   }
     * })
     */
    upsert<T extends SportRefereeTypeUpsertArgs>(args: SelectSubset<T, SportRefereeTypeUpsertArgs<ExtArgs>>): Prisma__SportRefereeTypeClient<$Result.GetResult<Prisma.$SportRefereeTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SportRefereeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeCountArgs} args - Arguments to filter SportRefereeTypes to count.
     * @example
     * // Count the number of SportRefereeTypes
     * const count = await prisma.sportRefereeType.count({
     *   where: {
     *     // ... the filter for the SportRefereeTypes we want to count
     *   }
     * })
    **/
    count<T extends SportRefereeTypeCountArgs>(
      args?: Subset<T, SportRefereeTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportRefereeTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SportRefereeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportRefereeTypeAggregateArgs>(args: Subset<T, SportRefereeTypeAggregateArgs>): Prisma.PrismaPromise<GetSportRefereeTypeAggregateType<T>>

    /**
     * Group by SportRefereeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportRefereeTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportRefereeTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportRefereeTypeGroupByArgs['orderBy'] }
        : { orderBy?: SportRefereeTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportRefereeTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportRefereeTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SportRefereeType model
   */
  readonly fields: SportRefereeTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SportRefereeType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportRefereeTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SportRefereeType model
   */
  interface SportRefereeTypeFieldRefs {
    readonly id: FieldRef<"SportRefereeType", 'Decimal'>
    readonly sportId: FieldRef<"SportRefereeType", 'Decimal'>
    readonly name: FieldRef<"SportRefereeType", 'String'>
    readonly abbr: FieldRef<"SportRefereeType", 'String'>
    readonly color: FieldRef<"SportRefereeType", 'String'>
    readonly note: FieldRef<"SportRefereeType", 'String'>
    readonly isActive: FieldRef<"SportRefereeType", 'Int'>
    readonly ord: FieldRef<"SportRefereeType", 'Int'>
    readonly createdAt: FieldRef<"SportRefereeType", 'DateTime'>
    readonly updatedAt: FieldRef<"SportRefereeType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SportRefereeType findUnique
   */
  export type SportRefereeTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportRefereeType to fetch.
     */
    where: SportRefereeTypeWhereUniqueInput
  }

  /**
   * SportRefereeType findUniqueOrThrow
   */
  export type SportRefereeTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportRefereeType to fetch.
     */
    where: SportRefereeTypeWhereUniqueInput
  }

  /**
   * SportRefereeType findFirst
   */
  export type SportRefereeTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportRefereeType to fetch.
     */
    where?: SportRefereeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportRefereeTypes to fetch.
     */
    orderBy?: SportRefereeTypeOrderByWithRelationInput | SportRefereeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportRefereeTypes.
     */
    cursor?: SportRefereeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportRefereeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportRefereeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportRefereeTypes.
     */
    distinct?: SportRefereeTypeScalarFieldEnum | SportRefereeTypeScalarFieldEnum[]
  }

  /**
   * SportRefereeType findFirstOrThrow
   */
  export type SportRefereeTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportRefereeType to fetch.
     */
    where?: SportRefereeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportRefereeTypes to fetch.
     */
    orderBy?: SportRefereeTypeOrderByWithRelationInput | SportRefereeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SportRefereeTypes.
     */
    cursor?: SportRefereeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportRefereeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportRefereeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SportRefereeTypes.
     */
    distinct?: SportRefereeTypeScalarFieldEnum | SportRefereeTypeScalarFieldEnum[]
  }

  /**
   * SportRefereeType findMany
   */
  export type SportRefereeTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * Filter, which SportRefereeTypes to fetch.
     */
    where?: SportRefereeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SportRefereeTypes to fetch.
     */
    orderBy?: SportRefereeTypeOrderByWithRelationInput | SportRefereeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SportRefereeTypes.
     */
    cursor?: SportRefereeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SportRefereeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SportRefereeTypes.
     */
    skip?: number
    distinct?: SportRefereeTypeScalarFieldEnum | SportRefereeTypeScalarFieldEnum[]
  }

  /**
   * SportRefereeType create
   */
  export type SportRefereeTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a SportRefereeType.
     */
    data: XOR<SportRefereeTypeCreateInput, SportRefereeTypeUncheckedCreateInput>
  }

  /**
   * SportRefereeType createMany
   */
  export type SportRefereeTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SportRefereeTypes.
     */
    data: SportRefereeTypeCreateManyInput | SportRefereeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportRefereeType createManyAndReturn
   */
  export type SportRefereeTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SportRefereeTypes.
     */
    data: SportRefereeTypeCreateManyInput | SportRefereeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SportRefereeType update
   */
  export type SportRefereeTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a SportRefereeType.
     */
    data: XOR<SportRefereeTypeUpdateInput, SportRefereeTypeUncheckedUpdateInput>
    /**
     * Choose, which SportRefereeType to update.
     */
    where: SportRefereeTypeWhereUniqueInput
  }

  /**
   * SportRefereeType updateMany
   */
  export type SportRefereeTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SportRefereeTypes.
     */
    data: XOR<SportRefereeTypeUpdateManyMutationInput, SportRefereeTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportRefereeTypes to update
     */
    where?: SportRefereeTypeWhereInput
    /**
     * Limit how many SportRefereeTypes to update.
     */
    limit?: number
  }

  /**
   * SportRefereeType updateManyAndReturn
   */
  export type SportRefereeTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * The data used to update SportRefereeTypes.
     */
    data: XOR<SportRefereeTypeUpdateManyMutationInput, SportRefereeTypeUncheckedUpdateManyInput>
    /**
     * Filter which SportRefereeTypes to update
     */
    where?: SportRefereeTypeWhereInput
    /**
     * Limit how many SportRefereeTypes to update.
     */
    limit?: number
  }

  /**
   * SportRefereeType upsert
   */
  export type SportRefereeTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the SportRefereeType to update in case it exists.
     */
    where: SportRefereeTypeWhereUniqueInput
    /**
     * In case the SportRefereeType found by the `where` argument doesn't exist, create a new SportRefereeType with this data.
     */
    create: XOR<SportRefereeTypeCreateInput, SportRefereeTypeUncheckedCreateInput>
    /**
     * In case the SportRefereeType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportRefereeTypeUpdateInput, SportRefereeTypeUncheckedUpdateInput>
  }

  /**
   * SportRefereeType delete
   */
  export type SportRefereeTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
    /**
     * Filter which SportRefereeType to delete.
     */
    where: SportRefereeTypeWhereUniqueInput
  }

  /**
   * SportRefereeType deleteMany
   */
  export type SportRefereeTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SportRefereeTypes to delete
     */
    where?: SportRefereeTypeWhereInput
    /**
     * Limit how many SportRefereeTypes to delete.
     */
    limit?: number
  }

  /**
   * SportRefereeType without action
   */
  export type SportRefereeTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportRefereeType
     */
    select?: SportRefereeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SportRefereeType
     */
    omit?: SportRefereeTypeOmit<ExtArgs> | null
  }


  /**
   * Model SubFeature
   */

  export type AggregateSubFeature = {
    _count: SubFeatureCountAggregateOutputType | null
    _avg: SubFeatureAvgAggregateOutputType | null
    _sum: SubFeatureSumAggregateOutputType | null
    _min: SubFeatureMinAggregateOutputType | null
    _max: SubFeatureMaxAggregateOutputType | null
  }

  export type SubFeatureAvgAggregateOutputType = {
    id: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SubFeatureSumAggregateOutputType = {
    id: Decimal | null
    isActive: number | null
    ord: number | null
  }

  export type SubFeatureMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    description: string | null
    category: string | null
    icon: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubFeatureMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    description: string | null
    category: string | null
    icon: string | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubFeatureCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    icon: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubFeatureAvgAggregateInputType = {
    id?: true
    isActive?: true
    ord?: true
  }

  export type SubFeatureSumAggregateInputType = {
    id?: true
    isActive?: true
    ord?: true
  }

  export type SubFeatureMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubFeatureMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubFeatureCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    icon?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubFeature to aggregate.
     */
    where?: SubFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubFeatures to fetch.
     */
    orderBy?: SubFeatureOrderByWithRelationInput | SubFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubFeatures
    **/
    _count?: true | SubFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubFeatureMaxAggregateInputType
  }

  export type GetSubFeatureAggregateType<T extends SubFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSubFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubFeature[P]>
      : GetScalarType<T[P], AggregateSubFeature[P]>
  }




  export type SubFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubFeatureWhereInput
    orderBy?: SubFeatureOrderByWithAggregationInput | SubFeatureOrderByWithAggregationInput[]
    by: SubFeatureScalarFieldEnum[] | SubFeatureScalarFieldEnum
    having?: SubFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubFeatureCountAggregateInputType | true
    _avg?: SubFeatureAvgAggregateInputType
    _sum?: SubFeatureSumAggregateInputType
    _min?: SubFeatureMinAggregateInputType
    _max?: SubFeatureMaxAggregateInputType
  }

  export type SubFeatureGroupByOutputType = {
    id: Decimal
    name: string
    description: string | null
    category: string | null
    icon: string | null
    isActive: number
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubFeatureCountAggregateOutputType | null
    _avg: SubFeatureAvgAggregateOutputType | null
    _sum: SubFeatureSumAggregateOutputType | null
    _min: SubFeatureMinAggregateOutputType | null
    _max: SubFeatureMaxAggregateOutputType | null
  }

  type GetSubFeatureGroupByPayload<T extends SubFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], SubFeatureGroupByOutputType[P]>
        }
      >
    >


  export type SubFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subFeature"]>

  export type SubFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subFeature"]>

  export type SubFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subFeature"]>

  export type SubFeatureSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    icon?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "icon" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["subFeature"]>

  export type $SubFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubFeature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      description: string | null
      category: string | null
      icon: string | null
      isActive: number
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["subFeature"]>
    composites: {}
  }

  type SubFeatureGetPayload<S extends boolean | null | undefined | SubFeatureDefaultArgs> = $Result.GetResult<Prisma.$SubFeaturePayload, S>

  type SubFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubFeatureCountAggregateInputType | true
    }

  export interface SubFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubFeature'], meta: { name: 'SubFeature' } }
    /**
     * Find zero or one SubFeature that matches the filter.
     * @param {SubFeatureFindUniqueArgs} args - Arguments to find a SubFeature
     * @example
     * // Get one SubFeature
     * const subFeature = await prisma.subFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubFeatureFindUniqueArgs>(args: SelectSubset<T, SubFeatureFindUniqueArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubFeatureFindUniqueOrThrowArgs} args - Arguments to find a SubFeature
     * @example
     * // Get one SubFeature
     * const subFeature = await prisma.subFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SubFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureFindFirstArgs} args - Arguments to find a SubFeature
     * @example
     * // Get one SubFeature
     * const subFeature = await prisma.subFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubFeatureFindFirstArgs>(args?: SelectSubset<T, SubFeatureFindFirstArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureFindFirstOrThrowArgs} args - Arguments to find a SubFeature
     * @example
     * // Get one SubFeature
     * const subFeature = await prisma.subFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SubFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubFeatures
     * const subFeatures = await prisma.subFeature.findMany()
     * 
     * // Get first 10 SubFeatures
     * const subFeatures = await prisma.subFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subFeatureWithIdOnly = await prisma.subFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubFeatureFindManyArgs>(args?: SelectSubset<T, SubFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubFeature.
     * @param {SubFeatureCreateArgs} args - Arguments to create a SubFeature.
     * @example
     * // Create one SubFeature
     * const SubFeature = await prisma.subFeature.create({
     *   data: {
     *     // ... data to create a SubFeature
     *   }
     * })
     * 
     */
    create<T extends SubFeatureCreateArgs>(args: SelectSubset<T, SubFeatureCreateArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubFeatures.
     * @param {SubFeatureCreateManyArgs} args - Arguments to create many SubFeatures.
     * @example
     * // Create many SubFeatures
     * const subFeature = await prisma.subFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubFeatureCreateManyArgs>(args?: SelectSubset<T, SubFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubFeatures and returns the data saved in the database.
     * @param {SubFeatureCreateManyAndReturnArgs} args - Arguments to create many SubFeatures.
     * @example
     * // Create many SubFeatures
     * const subFeature = await prisma.subFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubFeatures and only return the `id`
     * const subFeatureWithIdOnly = await prisma.subFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, SubFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubFeature.
     * @param {SubFeatureDeleteArgs} args - Arguments to delete one SubFeature.
     * @example
     * // Delete one SubFeature
     * const SubFeature = await prisma.subFeature.delete({
     *   where: {
     *     // ... filter to delete one SubFeature
     *   }
     * })
     * 
     */
    delete<T extends SubFeatureDeleteArgs>(args: SelectSubset<T, SubFeatureDeleteArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubFeature.
     * @param {SubFeatureUpdateArgs} args - Arguments to update one SubFeature.
     * @example
     * // Update one SubFeature
     * const subFeature = await prisma.subFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubFeatureUpdateArgs>(args: SelectSubset<T, SubFeatureUpdateArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubFeatures.
     * @param {SubFeatureDeleteManyArgs} args - Arguments to filter SubFeatures to delete.
     * @example
     * // Delete a few SubFeatures
     * const { count } = await prisma.subFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubFeatureDeleteManyArgs>(args?: SelectSubset<T, SubFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubFeatures
     * const subFeature = await prisma.subFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubFeatureUpdateManyArgs>(args: SelectSubset<T, SubFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubFeatures and returns the data updated in the database.
     * @param {SubFeatureUpdateManyAndReturnArgs} args - Arguments to update many SubFeatures.
     * @example
     * // Update many SubFeatures
     * const subFeature = await prisma.subFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubFeatures and only return the `id`
     * const subFeatureWithIdOnly = await prisma.subFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, SubFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubFeature.
     * @param {SubFeatureUpsertArgs} args - Arguments to update or create a SubFeature.
     * @example
     * // Update or create a SubFeature
     * const subFeature = await prisma.subFeature.upsert({
     *   create: {
     *     // ... data to create a SubFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubFeature we want to update
     *   }
     * })
     */
    upsert<T extends SubFeatureUpsertArgs>(args: SelectSubset<T, SubFeatureUpsertArgs<ExtArgs>>): Prisma__SubFeatureClient<$Result.GetResult<Prisma.$SubFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureCountArgs} args - Arguments to filter SubFeatures to count.
     * @example
     * // Count the number of SubFeatures
     * const count = await prisma.subFeature.count({
     *   where: {
     *     // ... the filter for the SubFeatures we want to count
     *   }
     * })
    **/
    count<T extends SubFeatureCountArgs>(
      args?: Subset<T, SubFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubFeatureAggregateArgs>(args: Subset<T, SubFeatureAggregateArgs>): Prisma.PrismaPromise<GetSubFeatureAggregateType<T>>

    /**
     * Group by SubFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubFeatureGroupByArgs['orderBy'] }
        : { orderBy?: SubFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubFeature model
   */
  readonly fields: SubFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubFeature model
   */
  interface SubFeatureFieldRefs {
    readonly id: FieldRef<"SubFeature", 'Decimal'>
    readonly name: FieldRef<"SubFeature", 'String'>
    readonly description: FieldRef<"SubFeature", 'String'>
    readonly category: FieldRef<"SubFeature", 'String'>
    readonly icon: FieldRef<"SubFeature", 'String'>
    readonly isActive: FieldRef<"SubFeature", 'Int'>
    readonly ord: FieldRef<"SubFeature", 'Int'>
    readonly createdAt: FieldRef<"SubFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"SubFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubFeature findUnique
   */
  export type SubFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubFeature to fetch.
     */
    where: SubFeatureWhereUniqueInput
  }

  /**
   * SubFeature findUniqueOrThrow
   */
  export type SubFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubFeature to fetch.
     */
    where: SubFeatureWhereUniqueInput
  }

  /**
   * SubFeature findFirst
   */
  export type SubFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubFeature to fetch.
     */
    where?: SubFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubFeatures to fetch.
     */
    orderBy?: SubFeatureOrderByWithRelationInput | SubFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubFeatures.
     */
    cursor?: SubFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubFeatures.
     */
    distinct?: SubFeatureScalarFieldEnum | SubFeatureScalarFieldEnum[]
  }

  /**
   * SubFeature findFirstOrThrow
   */
  export type SubFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubFeature to fetch.
     */
    where?: SubFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubFeatures to fetch.
     */
    orderBy?: SubFeatureOrderByWithRelationInput | SubFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubFeatures.
     */
    cursor?: SubFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubFeatures.
     */
    distinct?: SubFeatureScalarFieldEnum | SubFeatureScalarFieldEnum[]
  }

  /**
   * SubFeature findMany
   */
  export type SubFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubFeatures to fetch.
     */
    where?: SubFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubFeatures to fetch.
     */
    orderBy?: SubFeatureOrderByWithRelationInput | SubFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubFeatures.
     */
    cursor?: SubFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubFeatures.
     */
    skip?: number
    distinct?: SubFeatureScalarFieldEnum | SubFeatureScalarFieldEnum[]
  }

  /**
   * SubFeature create
   */
  export type SubFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * The data needed to create a SubFeature.
     */
    data: XOR<SubFeatureCreateInput, SubFeatureUncheckedCreateInput>
  }

  /**
   * SubFeature createMany
   */
  export type SubFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubFeatures.
     */
    data: SubFeatureCreateManyInput | SubFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubFeature createManyAndReturn
   */
  export type SubFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many SubFeatures.
     */
    data: SubFeatureCreateManyInput | SubFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubFeature update
   */
  export type SubFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * The data needed to update a SubFeature.
     */
    data: XOR<SubFeatureUpdateInput, SubFeatureUncheckedUpdateInput>
    /**
     * Choose, which SubFeature to update.
     */
    where: SubFeatureWhereUniqueInput
  }

  /**
   * SubFeature updateMany
   */
  export type SubFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubFeatures.
     */
    data: XOR<SubFeatureUpdateManyMutationInput, SubFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubFeatures to update
     */
    where?: SubFeatureWhereInput
    /**
     * Limit how many SubFeatures to update.
     */
    limit?: number
  }

  /**
   * SubFeature updateManyAndReturn
   */
  export type SubFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * The data used to update SubFeatures.
     */
    data: XOR<SubFeatureUpdateManyMutationInput, SubFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubFeatures to update
     */
    where?: SubFeatureWhereInput
    /**
     * Limit how many SubFeatures to update.
     */
    limit?: number
  }

  /**
   * SubFeature upsert
   */
  export type SubFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * The filter to search for the SubFeature to update in case it exists.
     */
    where: SubFeatureWhereUniqueInput
    /**
     * In case the SubFeature found by the `where` argument doesn't exist, create a new SubFeature with this data.
     */
    create: XOR<SubFeatureCreateInput, SubFeatureUncheckedCreateInput>
    /**
     * In case the SubFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubFeatureUpdateInput, SubFeatureUncheckedUpdateInput>
  }

  /**
   * SubFeature delete
   */
  export type SubFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
    /**
     * Filter which SubFeature to delete.
     */
    where: SubFeatureWhereUniqueInput
  }

  /**
   * SubFeature deleteMany
   */
  export type SubFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubFeatures to delete
     */
    where?: SubFeatureWhereInput
    /**
     * Limit how many SubFeatures to delete.
     */
    limit?: number
  }

  /**
   * SubFeature without action
   */
  export type SubFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubFeature
     */
    select?: SubFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubFeature
     */
    omit?: SubFeatureOmit<ExtArgs> | null
  }


  /**
   * Model SubForTeam
   */

  export type AggregateSubForTeam = {
    _count: SubForTeamCountAggregateOutputType | null
    _avg: SubForTeamAvgAggregateOutputType | null
    _sum: SubForTeamSumAggregateOutputType | null
    _min: SubForTeamMinAggregateOutputType | null
    _max: SubForTeamMaxAggregateOutputType | null
  }

  export type SubForTeamAvgAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    planId: Decimal | null
    autoRenew: number | null
    ord: number | null
  }

  export type SubForTeamSumAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    planId: Decimal | null
    autoRenew: number | null
    ord: number | null
  }

  export type SubForTeamMinAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    planId: Decimal | null
    status: string | null
    startedAt: Date | null
    expiresAt: Date | null
    autoRenew: number | null
    paymentMethod: string | null
    lastPaymentAt: Date | null
    nextPaymentAt: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubForTeamMaxAggregateOutputType = {
    id: Decimal | null
    teamId: Decimal | null
    planId: Decimal | null
    status: string | null
    startedAt: Date | null
    expiresAt: Date | null
    autoRenew: number | null
    paymentMethod: string | null
    lastPaymentAt: Date | null
    nextPaymentAt: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubForTeamCountAggregateOutputType = {
    id: number
    teamId: number
    planId: number
    status: number
    startedAt: number
    expiresAt: number
    autoRenew: number
    paymentMethod: number
    lastPaymentAt: number
    nextPaymentAt: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubForTeamAvgAggregateInputType = {
    id?: true
    teamId?: true
    planId?: true
    autoRenew?: true
    ord?: true
  }

  export type SubForTeamSumAggregateInputType = {
    id?: true
    teamId?: true
    planId?: true
    autoRenew?: true
    ord?: true
  }

  export type SubForTeamMinAggregateInputType = {
    id?: true
    teamId?: true
    planId?: true
    status?: true
    startedAt?: true
    expiresAt?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentAt?: true
    nextPaymentAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubForTeamMaxAggregateInputType = {
    id?: true
    teamId?: true
    planId?: true
    status?: true
    startedAt?: true
    expiresAt?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentAt?: true
    nextPaymentAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubForTeamCountAggregateInputType = {
    id?: true
    teamId?: true
    planId?: true
    status?: true
    startedAt?: true
    expiresAt?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentAt?: true
    nextPaymentAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubForTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubForTeam to aggregate.
     */
    where?: SubForTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForTeams to fetch.
     */
    orderBy?: SubForTeamOrderByWithRelationInput | SubForTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubForTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubForTeams
    **/
    _count?: true | SubForTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubForTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubForTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubForTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubForTeamMaxAggregateInputType
  }

  export type GetSubForTeamAggregateType<T extends SubForTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateSubForTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubForTeam[P]>
      : GetScalarType<T[P], AggregateSubForTeam[P]>
  }




  export type SubForTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubForTeamWhereInput
    orderBy?: SubForTeamOrderByWithAggregationInput | SubForTeamOrderByWithAggregationInput[]
    by: SubForTeamScalarFieldEnum[] | SubForTeamScalarFieldEnum
    having?: SubForTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubForTeamCountAggregateInputType | true
    _avg?: SubForTeamAvgAggregateInputType
    _sum?: SubForTeamSumAggregateInputType
    _min?: SubForTeamMinAggregateInputType
    _max?: SubForTeamMaxAggregateInputType
  }

  export type SubForTeamGroupByOutputType = {
    id: Decimal
    teamId: Decimal
    planId: Decimal
    status: string
    startedAt: Date
    expiresAt: Date | null
    autoRenew: number
    paymentMethod: string | null
    lastPaymentAt: Date | null
    nextPaymentAt: Date | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubForTeamCountAggregateOutputType | null
    _avg: SubForTeamAvgAggregateOutputType | null
    _sum: SubForTeamSumAggregateOutputType | null
    _min: SubForTeamMinAggregateOutputType | null
    _max: SubForTeamMaxAggregateOutputType | null
  }

  type GetSubForTeamGroupByPayload<T extends SubForTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubForTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubForTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubForTeamGroupByOutputType[P]>
            : GetScalarType<T[P], SubForTeamGroupByOutputType[P]>
        }
      >
    >


  export type SubForTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subForTeam"]>

  export type SubForTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subForTeam"]>

  export type SubForTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subForTeam"]>

  export type SubForTeamSelectScalar = {
    id?: boolean
    teamId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubForTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "planId" | "status" | "startedAt" | "expiresAt" | "autoRenew" | "paymentMethod" | "lastPaymentAt" | "nextPaymentAt" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["subForTeam"]>

  export type $SubForTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubForTeam"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      teamId: Prisma.Decimal
      planId: Prisma.Decimal
      status: string
      startedAt: Date
      expiresAt: Date | null
      autoRenew: number
      paymentMethod: string | null
      lastPaymentAt: Date | null
      nextPaymentAt: Date | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["subForTeam"]>
    composites: {}
  }

  type SubForTeamGetPayload<S extends boolean | null | undefined | SubForTeamDefaultArgs> = $Result.GetResult<Prisma.$SubForTeamPayload, S>

  type SubForTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubForTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubForTeamCountAggregateInputType | true
    }

  export interface SubForTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubForTeam'], meta: { name: 'SubForTeam' } }
    /**
     * Find zero or one SubForTeam that matches the filter.
     * @param {SubForTeamFindUniqueArgs} args - Arguments to find a SubForTeam
     * @example
     * // Get one SubForTeam
     * const subForTeam = await prisma.subForTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubForTeamFindUniqueArgs>(args: SelectSubset<T, SubForTeamFindUniqueArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubForTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubForTeamFindUniqueOrThrowArgs} args - Arguments to find a SubForTeam
     * @example
     * // Get one SubForTeam
     * const subForTeam = await prisma.subForTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubForTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, SubForTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubForTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamFindFirstArgs} args - Arguments to find a SubForTeam
     * @example
     * // Get one SubForTeam
     * const subForTeam = await prisma.subForTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubForTeamFindFirstArgs>(args?: SelectSubset<T, SubForTeamFindFirstArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubForTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamFindFirstOrThrowArgs} args - Arguments to find a SubForTeam
     * @example
     * // Get one SubForTeam
     * const subForTeam = await prisma.subForTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubForTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, SubForTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubForTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubForTeams
     * const subForTeams = await prisma.subForTeam.findMany()
     * 
     * // Get first 10 SubForTeams
     * const subForTeams = await prisma.subForTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subForTeamWithIdOnly = await prisma.subForTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubForTeamFindManyArgs>(args?: SelectSubset<T, SubForTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubForTeam.
     * @param {SubForTeamCreateArgs} args - Arguments to create a SubForTeam.
     * @example
     * // Create one SubForTeam
     * const SubForTeam = await prisma.subForTeam.create({
     *   data: {
     *     // ... data to create a SubForTeam
     *   }
     * })
     * 
     */
    create<T extends SubForTeamCreateArgs>(args: SelectSubset<T, SubForTeamCreateArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubForTeams.
     * @param {SubForTeamCreateManyArgs} args - Arguments to create many SubForTeams.
     * @example
     * // Create many SubForTeams
     * const subForTeam = await prisma.subForTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubForTeamCreateManyArgs>(args?: SelectSubset<T, SubForTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubForTeams and returns the data saved in the database.
     * @param {SubForTeamCreateManyAndReturnArgs} args - Arguments to create many SubForTeams.
     * @example
     * // Create many SubForTeams
     * const subForTeam = await prisma.subForTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubForTeams and only return the `id`
     * const subForTeamWithIdOnly = await prisma.subForTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubForTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, SubForTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubForTeam.
     * @param {SubForTeamDeleteArgs} args - Arguments to delete one SubForTeam.
     * @example
     * // Delete one SubForTeam
     * const SubForTeam = await prisma.subForTeam.delete({
     *   where: {
     *     // ... filter to delete one SubForTeam
     *   }
     * })
     * 
     */
    delete<T extends SubForTeamDeleteArgs>(args: SelectSubset<T, SubForTeamDeleteArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubForTeam.
     * @param {SubForTeamUpdateArgs} args - Arguments to update one SubForTeam.
     * @example
     * // Update one SubForTeam
     * const subForTeam = await prisma.subForTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubForTeamUpdateArgs>(args: SelectSubset<T, SubForTeamUpdateArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubForTeams.
     * @param {SubForTeamDeleteManyArgs} args - Arguments to filter SubForTeams to delete.
     * @example
     * // Delete a few SubForTeams
     * const { count } = await prisma.subForTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubForTeamDeleteManyArgs>(args?: SelectSubset<T, SubForTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubForTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubForTeams
     * const subForTeam = await prisma.subForTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubForTeamUpdateManyArgs>(args: SelectSubset<T, SubForTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubForTeams and returns the data updated in the database.
     * @param {SubForTeamUpdateManyAndReturnArgs} args - Arguments to update many SubForTeams.
     * @example
     * // Update many SubForTeams
     * const subForTeam = await prisma.subForTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubForTeams and only return the `id`
     * const subForTeamWithIdOnly = await prisma.subForTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubForTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, SubForTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubForTeam.
     * @param {SubForTeamUpsertArgs} args - Arguments to update or create a SubForTeam.
     * @example
     * // Update or create a SubForTeam
     * const subForTeam = await prisma.subForTeam.upsert({
     *   create: {
     *     // ... data to create a SubForTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubForTeam we want to update
     *   }
     * })
     */
    upsert<T extends SubForTeamUpsertArgs>(args: SelectSubset<T, SubForTeamUpsertArgs<ExtArgs>>): Prisma__SubForTeamClient<$Result.GetResult<Prisma.$SubForTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubForTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamCountArgs} args - Arguments to filter SubForTeams to count.
     * @example
     * // Count the number of SubForTeams
     * const count = await prisma.subForTeam.count({
     *   where: {
     *     // ... the filter for the SubForTeams we want to count
     *   }
     * })
    **/
    count<T extends SubForTeamCountArgs>(
      args?: Subset<T, SubForTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubForTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubForTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubForTeamAggregateArgs>(args: Subset<T, SubForTeamAggregateArgs>): Prisma.PrismaPromise<GetSubForTeamAggregateType<T>>

    /**
     * Group by SubForTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubForTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubForTeamGroupByArgs['orderBy'] }
        : { orderBy?: SubForTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubForTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubForTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubForTeam model
   */
  readonly fields: SubForTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubForTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubForTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubForTeam model
   */
  interface SubForTeamFieldRefs {
    readonly id: FieldRef<"SubForTeam", 'Decimal'>
    readonly teamId: FieldRef<"SubForTeam", 'Decimal'>
    readonly planId: FieldRef<"SubForTeam", 'Decimal'>
    readonly status: FieldRef<"SubForTeam", 'String'>
    readonly startedAt: FieldRef<"SubForTeam", 'DateTime'>
    readonly expiresAt: FieldRef<"SubForTeam", 'DateTime'>
    readonly autoRenew: FieldRef<"SubForTeam", 'Int'>
    readonly paymentMethod: FieldRef<"SubForTeam", 'String'>
    readonly lastPaymentAt: FieldRef<"SubForTeam", 'DateTime'>
    readonly nextPaymentAt: FieldRef<"SubForTeam", 'DateTime'>
    readonly notes: FieldRef<"SubForTeam", 'String'>
    readonly ord: FieldRef<"SubForTeam", 'Int'>
    readonly createdAt: FieldRef<"SubForTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"SubForTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubForTeam findUnique
   */
  export type SubForTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * Filter, which SubForTeam to fetch.
     */
    where: SubForTeamWhereUniqueInput
  }

  /**
   * SubForTeam findUniqueOrThrow
   */
  export type SubForTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * Filter, which SubForTeam to fetch.
     */
    where: SubForTeamWhereUniqueInput
  }

  /**
   * SubForTeam findFirst
   */
  export type SubForTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * Filter, which SubForTeam to fetch.
     */
    where?: SubForTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForTeams to fetch.
     */
    orderBy?: SubForTeamOrderByWithRelationInput | SubForTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubForTeams.
     */
    cursor?: SubForTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubForTeams.
     */
    distinct?: SubForTeamScalarFieldEnum | SubForTeamScalarFieldEnum[]
  }

  /**
   * SubForTeam findFirstOrThrow
   */
  export type SubForTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * Filter, which SubForTeam to fetch.
     */
    where?: SubForTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForTeams to fetch.
     */
    orderBy?: SubForTeamOrderByWithRelationInput | SubForTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubForTeams.
     */
    cursor?: SubForTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubForTeams.
     */
    distinct?: SubForTeamScalarFieldEnum | SubForTeamScalarFieldEnum[]
  }

  /**
   * SubForTeam findMany
   */
  export type SubForTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * Filter, which SubForTeams to fetch.
     */
    where?: SubForTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForTeams to fetch.
     */
    orderBy?: SubForTeamOrderByWithRelationInput | SubForTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubForTeams.
     */
    cursor?: SubForTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForTeams.
     */
    skip?: number
    distinct?: SubForTeamScalarFieldEnum | SubForTeamScalarFieldEnum[]
  }

  /**
   * SubForTeam create
   */
  export type SubForTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * The data needed to create a SubForTeam.
     */
    data: XOR<SubForTeamCreateInput, SubForTeamUncheckedCreateInput>
  }

  /**
   * SubForTeam createMany
   */
  export type SubForTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubForTeams.
     */
    data: SubForTeamCreateManyInput | SubForTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubForTeam createManyAndReturn
   */
  export type SubForTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * The data used to create many SubForTeams.
     */
    data: SubForTeamCreateManyInput | SubForTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubForTeam update
   */
  export type SubForTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * The data needed to update a SubForTeam.
     */
    data: XOR<SubForTeamUpdateInput, SubForTeamUncheckedUpdateInput>
    /**
     * Choose, which SubForTeam to update.
     */
    where: SubForTeamWhereUniqueInput
  }

  /**
   * SubForTeam updateMany
   */
  export type SubForTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubForTeams.
     */
    data: XOR<SubForTeamUpdateManyMutationInput, SubForTeamUncheckedUpdateManyInput>
    /**
     * Filter which SubForTeams to update
     */
    where?: SubForTeamWhereInput
    /**
     * Limit how many SubForTeams to update.
     */
    limit?: number
  }

  /**
   * SubForTeam updateManyAndReturn
   */
  export type SubForTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * The data used to update SubForTeams.
     */
    data: XOR<SubForTeamUpdateManyMutationInput, SubForTeamUncheckedUpdateManyInput>
    /**
     * Filter which SubForTeams to update
     */
    where?: SubForTeamWhereInput
    /**
     * Limit how many SubForTeams to update.
     */
    limit?: number
  }

  /**
   * SubForTeam upsert
   */
  export type SubForTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * The filter to search for the SubForTeam to update in case it exists.
     */
    where: SubForTeamWhereUniqueInput
    /**
     * In case the SubForTeam found by the `where` argument doesn't exist, create a new SubForTeam with this data.
     */
    create: XOR<SubForTeamCreateInput, SubForTeamUncheckedCreateInput>
    /**
     * In case the SubForTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubForTeamUpdateInput, SubForTeamUncheckedUpdateInput>
  }

  /**
   * SubForTeam delete
   */
  export type SubForTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
    /**
     * Filter which SubForTeam to delete.
     */
    where: SubForTeamWhereUniqueInput
  }

  /**
   * SubForTeam deleteMany
   */
  export type SubForTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubForTeams to delete
     */
    where?: SubForTeamWhereInput
    /**
     * Limit how many SubForTeams to delete.
     */
    limit?: number
  }

  /**
   * SubForTeam without action
   */
  export type SubForTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForTeam
     */
    select?: SubForTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForTeam
     */
    omit?: SubForTeamOmit<ExtArgs> | null
  }


  /**
   * Model SubForUser
   */

  export type AggregateSubForUser = {
    _count: SubForUserCountAggregateOutputType | null
    _avg: SubForUserAvgAggregateOutputType | null
    _sum: SubForUserSumAggregateOutputType | null
    _min: SubForUserMinAggregateOutputType | null
    _max: SubForUserMaxAggregateOutputType | null
  }

  export type SubForUserAvgAggregateOutputType = {
    id: Decimal | null
    userId: Decimal | null
    planId: Decimal | null
    autoRenew: number | null
    ord: number | null
  }

  export type SubForUserSumAggregateOutputType = {
    id: Decimal | null
    userId: Decimal | null
    planId: Decimal | null
    autoRenew: number | null
    ord: number | null
  }

  export type SubForUserMinAggregateOutputType = {
    id: Decimal | null
    userId: Decimal | null
    planId: Decimal | null
    status: string | null
    startedAt: Date | null
    expiresAt: Date | null
    autoRenew: number | null
    paymentMethod: string | null
    lastPaymentAt: Date | null
    nextPaymentAt: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubForUserMaxAggregateOutputType = {
    id: Decimal | null
    userId: Decimal | null
    planId: Decimal | null
    status: string | null
    startedAt: Date | null
    expiresAt: Date | null
    autoRenew: number | null
    paymentMethod: string | null
    lastPaymentAt: Date | null
    nextPaymentAt: Date | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubForUserCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    status: number
    startedAt: number
    expiresAt: number
    autoRenew: number
    paymentMethod: number
    lastPaymentAt: number
    nextPaymentAt: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubForUserAvgAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    autoRenew?: true
    ord?: true
  }

  export type SubForUserSumAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    autoRenew?: true
    ord?: true
  }

  export type SubForUserMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    startedAt?: true
    expiresAt?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentAt?: true
    nextPaymentAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubForUserMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    startedAt?: true
    expiresAt?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentAt?: true
    nextPaymentAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubForUserCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    startedAt?: true
    expiresAt?: true
    autoRenew?: true
    paymentMethod?: true
    lastPaymentAt?: true
    nextPaymentAt?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubForUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubForUser to aggregate.
     */
    where?: SubForUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForUsers to fetch.
     */
    orderBy?: SubForUserOrderByWithRelationInput | SubForUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubForUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubForUsers
    **/
    _count?: true | SubForUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubForUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubForUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubForUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubForUserMaxAggregateInputType
  }

  export type GetSubForUserAggregateType<T extends SubForUserAggregateArgs> = {
        [P in keyof T & keyof AggregateSubForUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubForUser[P]>
      : GetScalarType<T[P], AggregateSubForUser[P]>
  }




  export type SubForUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubForUserWhereInput
    orderBy?: SubForUserOrderByWithAggregationInput | SubForUserOrderByWithAggregationInput[]
    by: SubForUserScalarFieldEnum[] | SubForUserScalarFieldEnum
    having?: SubForUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubForUserCountAggregateInputType | true
    _avg?: SubForUserAvgAggregateInputType
    _sum?: SubForUserSumAggregateInputType
    _min?: SubForUserMinAggregateInputType
    _max?: SubForUserMaxAggregateInputType
  }

  export type SubForUserGroupByOutputType = {
    id: Decimal
    userId: Decimal
    planId: Decimal
    status: string
    startedAt: Date
    expiresAt: Date | null
    autoRenew: number
    paymentMethod: string | null
    lastPaymentAt: Date | null
    nextPaymentAt: Date | null
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubForUserCountAggregateOutputType | null
    _avg: SubForUserAvgAggregateOutputType | null
    _sum: SubForUserSumAggregateOutputType | null
    _min: SubForUserMinAggregateOutputType | null
    _max: SubForUserMaxAggregateOutputType | null
  }

  type GetSubForUserGroupByPayload<T extends SubForUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubForUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubForUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubForUserGroupByOutputType[P]>
            : GetScalarType<T[P], SubForUserGroupByOutputType[P]>
        }
      >
    >


  export type SubForUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subForUser"]>

  export type SubForUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subForUser"]>

  export type SubForUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subForUser"]>

  export type SubForUserSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    autoRenew?: boolean
    paymentMethod?: boolean
    lastPaymentAt?: boolean
    nextPaymentAt?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubForUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "status" | "startedAt" | "expiresAt" | "autoRenew" | "paymentMethod" | "lastPaymentAt" | "nextPaymentAt" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["subForUser"]>

  export type $SubForUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubForUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      userId: Prisma.Decimal
      planId: Prisma.Decimal
      status: string
      startedAt: Date
      expiresAt: Date | null
      autoRenew: number
      paymentMethod: string | null
      lastPaymentAt: Date | null
      nextPaymentAt: Date | null
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["subForUser"]>
    composites: {}
  }

  type SubForUserGetPayload<S extends boolean | null | undefined | SubForUserDefaultArgs> = $Result.GetResult<Prisma.$SubForUserPayload, S>

  type SubForUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubForUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubForUserCountAggregateInputType | true
    }

  export interface SubForUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubForUser'], meta: { name: 'SubForUser' } }
    /**
     * Find zero or one SubForUser that matches the filter.
     * @param {SubForUserFindUniqueArgs} args - Arguments to find a SubForUser
     * @example
     * // Get one SubForUser
     * const subForUser = await prisma.subForUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubForUserFindUniqueArgs>(args: SelectSubset<T, SubForUserFindUniqueArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubForUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubForUserFindUniqueOrThrowArgs} args - Arguments to find a SubForUser
     * @example
     * // Get one SubForUser
     * const subForUser = await prisma.subForUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubForUserFindUniqueOrThrowArgs>(args: SelectSubset<T, SubForUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubForUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserFindFirstArgs} args - Arguments to find a SubForUser
     * @example
     * // Get one SubForUser
     * const subForUser = await prisma.subForUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubForUserFindFirstArgs>(args?: SelectSubset<T, SubForUserFindFirstArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubForUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserFindFirstOrThrowArgs} args - Arguments to find a SubForUser
     * @example
     * // Get one SubForUser
     * const subForUser = await prisma.subForUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubForUserFindFirstOrThrowArgs>(args?: SelectSubset<T, SubForUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubForUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubForUsers
     * const subForUsers = await prisma.subForUser.findMany()
     * 
     * // Get first 10 SubForUsers
     * const subForUsers = await prisma.subForUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subForUserWithIdOnly = await prisma.subForUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubForUserFindManyArgs>(args?: SelectSubset<T, SubForUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubForUser.
     * @param {SubForUserCreateArgs} args - Arguments to create a SubForUser.
     * @example
     * // Create one SubForUser
     * const SubForUser = await prisma.subForUser.create({
     *   data: {
     *     // ... data to create a SubForUser
     *   }
     * })
     * 
     */
    create<T extends SubForUserCreateArgs>(args: SelectSubset<T, SubForUserCreateArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubForUsers.
     * @param {SubForUserCreateManyArgs} args - Arguments to create many SubForUsers.
     * @example
     * // Create many SubForUsers
     * const subForUser = await prisma.subForUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubForUserCreateManyArgs>(args?: SelectSubset<T, SubForUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubForUsers and returns the data saved in the database.
     * @param {SubForUserCreateManyAndReturnArgs} args - Arguments to create many SubForUsers.
     * @example
     * // Create many SubForUsers
     * const subForUser = await prisma.subForUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubForUsers and only return the `id`
     * const subForUserWithIdOnly = await prisma.subForUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubForUserCreateManyAndReturnArgs>(args?: SelectSubset<T, SubForUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubForUser.
     * @param {SubForUserDeleteArgs} args - Arguments to delete one SubForUser.
     * @example
     * // Delete one SubForUser
     * const SubForUser = await prisma.subForUser.delete({
     *   where: {
     *     // ... filter to delete one SubForUser
     *   }
     * })
     * 
     */
    delete<T extends SubForUserDeleteArgs>(args: SelectSubset<T, SubForUserDeleteArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubForUser.
     * @param {SubForUserUpdateArgs} args - Arguments to update one SubForUser.
     * @example
     * // Update one SubForUser
     * const subForUser = await prisma.subForUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubForUserUpdateArgs>(args: SelectSubset<T, SubForUserUpdateArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubForUsers.
     * @param {SubForUserDeleteManyArgs} args - Arguments to filter SubForUsers to delete.
     * @example
     * // Delete a few SubForUsers
     * const { count } = await prisma.subForUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubForUserDeleteManyArgs>(args?: SelectSubset<T, SubForUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubForUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubForUsers
     * const subForUser = await prisma.subForUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubForUserUpdateManyArgs>(args: SelectSubset<T, SubForUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubForUsers and returns the data updated in the database.
     * @param {SubForUserUpdateManyAndReturnArgs} args - Arguments to update many SubForUsers.
     * @example
     * // Update many SubForUsers
     * const subForUser = await prisma.subForUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubForUsers and only return the `id`
     * const subForUserWithIdOnly = await prisma.subForUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubForUserUpdateManyAndReturnArgs>(args: SelectSubset<T, SubForUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubForUser.
     * @param {SubForUserUpsertArgs} args - Arguments to update or create a SubForUser.
     * @example
     * // Update or create a SubForUser
     * const subForUser = await prisma.subForUser.upsert({
     *   create: {
     *     // ... data to create a SubForUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubForUser we want to update
     *   }
     * })
     */
    upsert<T extends SubForUserUpsertArgs>(args: SelectSubset<T, SubForUserUpsertArgs<ExtArgs>>): Prisma__SubForUserClient<$Result.GetResult<Prisma.$SubForUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubForUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserCountArgs} args - Arguments to filter SubForUsers to count.
     * @example
     * // Count the number of SubForUsers
     * const count = await prisma.subForUser.count({
     *   where: {
     *     // ... the filter for the SubForUsers we want to count
     *   }
     * })
    **/
    count<T extends SubForUserCountArgs>(
      args?: Subset<T, SubForUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubForUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubForUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubForUserAggregateArgs>(args: Subset<T, SubForUserAggregateArgs>): Prisma.PrismaPromise<GetSubForUserAggregateType<T>>

    /**
     * Group by SubForUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubForUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubForUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubForUserGroupByArgs['orderBy'] }
        : { orderBy?: SubForUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubForUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubForUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubForUser model
   */
  readonly fields: SubForUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubForUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubForUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubForUser model
   */
  interface SubForUserFieldRefs {
    readonly id: FieldRef<"SubForUser", 'Decimal'>
    readonly userId: FieldRef<"SubForUser", 'Decimal'>
    readonly planId: FieldRef<"SubForUser", 'Decimal'>
    readonly status: FieldRef<"SubForUser", 'String'>
    readonly startedAt: FieldRef<"SubForUser", 'DateTime'>
    readonly expiresAt: FieldRef<"SubForUser", 'DateTime'>
    readonly autoRenew: FieldRef<"SubForUser", 'Int'>
    readonly paymentMethod: FieldRef<"SubForUser", 'String'>
    readonly lastPaymentAt: FieldRef<"SubForUser", 'DateTime'>
    readonly nextPaymentAt: FieldRef<"SubForUser", 'DateTime'>
    readonly notes: FieldRef<"SubForUser", 'String'>
    readonly ord: FieldRef<"SubForUser", 'Int'>
    readonly createdAt: FieldRef<"SubForUser", 'DateTime'>
    readonly updatedAt: FieldRef<"SubForUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubForUser findUnique
   */
  export type SubForUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * Filter, which SubForUser to fetch.
     */
    where: SubForUserWhereUniqueInput
  }

  /**
   * SubForUser findUniqueOrThrow
   */
  export type SubForUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * Filter, which SubForUser to fetch.
     */
    where: SubForUserWhereUniqueInput
  }

  /**
   * SubForUser findFirst
   */
  export type SubForUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * Filter, which SubForUser to fetch.
     */
    where?: SubForUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForUsers to fetch.
     */
    orderBy?: SubForUserOrderByWithRelationInput | SubForUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubForUsers.
     */
    cursor?: SubForUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubForUsers.
     */
    distinct?: SubForUserScalarFieldEnum | SubForUserScalarFieldEnum[]
  }

  /**
   * SubForUser findFirstOrThrow
   */
  export type SubForUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * Filter, which SubForUser to fetch.
     */
    where?: SubForUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForUsers to fetch.
     */
    orderBy?: SubForUserOrderByWithRelationInput | SubForUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubForUsers.
     */
    cursor?: SubForUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubForUsers.
     */
    distinct?: SubForUserScalarFieldEnum | SubForUserScalarFieldEnum[]
  }

  /**
   * SubForUser findMany
   */
  export type SubForUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * Filter, which SubForUsers to fetch.
     */
    where?: SubForUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubForUsers to fetch.
     */
    orderBy?: SubForUserOrderByWithRelationInput | SubForUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubForUsers.
     */
    cursor?: SubForUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubForUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubForUsers.
     */
    skip?: number
    distinct?: SubForUserScalarFieldEnum | SubForUserScalarFieldEnum[]
  }

  /**
   * SubForUser create
   */
  export type SubForUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * The data needed to create a SubForUser.
     */
    data: XOR<SubForUserCreateInput, SubForUserUncheckedCreateInput>
  }

  /**
   * SubForUser createMany
   */
  export type SubForUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubForUsers.
     */
    data: SubForUserCreateManyInput | SubForUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubForUser createManyAndReturn
   */
  export type SubForUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * The data used to create many SubForUsers.
     */
    data: SubForUserCreateManyInput | SubForUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubForUser update
   */
  export type SubForUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * The data needed to update a SubForUser.
     */
    data: XOR<SubForUserUpdateInput, SubForUserUncheckedUpdateInput>
    /**
     * Choose, which SubForUser to update.
     */
    where: SubForUserWhereUniqueInput
  }

  /**
   * SubForUser updateMany
   */
  export type SubForUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubForUsers.
     */
    data: XOR<SubForUserUpdateManyMutationInput, SubForUserUncheckedUpdateManyInput>
    /**
     * Filter which SubForUsers to update
     */
    where?: SubForUserWhereInput
    /**
     * Limit how many SubForUsers to update.
     */
    limit?: number
  }

  /**
   * SubForUser updateManyAndReturn
   */
  export type SubForUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * The data used to update SubForUsers.
     */
    data: XOR<SubForUserUpdateManyMutationInput, SubForUserUncheckedUpdateManyInput>
    /**
     * Filter which SubForUsers to update
     */
    where?: SubForUserWhereInput
    /**
     * Limit how many SubForUsers to update.
     */
    limit?: number
  }

  /**
   * SubForUser upsert
   */
  export type SubForUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * The filter to search for the SubForUser to update in case it exists.
     */
    where: SubForUserWhereUniqueInput
    /**
     * In case the SubForUser found by the `where` argument doesn't exist, create a new SubForUser with this data.
     */
    create: XOR<SubForUserCreateInput, SubForUserUncheckedCreateInput>
    /**
     * In case the SubForUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubForUserUpdateInput, SubForUserUncheckedUpdateInput>
  }

  /**
   * SubForUser delete
   */
  export type SubForUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
    /**
     * Filter which SubForUser to delete.
     */
    where: SubForUserWhereUniqueInput
  }

  /**
   * SubForUser deleteMany
   */
  export type SubForUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubForUsers to delete
     */
    where?: SubForUserWhereInput
    /**
     * Limit how many SubForUsers to delete.
     */
    limit?: number
  }

  /**
   * SubForUser without action
   */
  export type SubForUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubForUser
     */
    select?: SubForUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubForUser
     */
    omit?: SubForUserOmit<ExtArgs> | null
  }


  /**
   * Model SubPlan
   */

  export type AggregateSubPlan = {
    _count: SubPlanCountAggregateOutputType | null
    _avg: SubPlanAvgAggregateOutputType | null
    _sum: SubPlanSumAggregateOutputType | null
    _min: SubPlanMinAggregateOutputType | null
    _max: SubPlanMaxAggregateOutputType | null
  }

  export type SubPlanAvgAggregateOutputType = {
    id: Decimal | null
    price: Decimal | null
    isPopular: number | null
    maxTeams: number | null
    maxPlayers: number | null
    maxCoaches: number | null
    maxReferees: number | null
    storageLimitGb: number | null
    isActive: number | null
    ord: number | null
  }

  export type SubPlanSumAggregateOutputType = {
    id: Decimal | null
    price: Decimal | null
    isPopular: number | null
    maxTeams: number | null
    maxPlayers: number | null
    maxCoaches: number | null
    maxReferees: number | null
    storageLimitGb: number | null
    isActive: number | null
    ord: number | null
  }

  export type SubPlanMinAggregateOutputType = {
    id: Decimal | null
    name: string | null
    planType: string | null
    price: Decimal | null
    isPopular: number | null
    description: string | null
    features: string | null
    maxTeams: number | null
    maxPlayers: number | null
    maxCoaches: number | null
    maxReferees: number | null
    storageLimitGb: number | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubPlanMaxAggregateOutputType = {
    id: Decimal | null
    name: string | null
    planType: string | null
    price: Decimal | null
    isPopular: number | null
    description: string | null
    features: string | null
    maxTeams: number | null
    maxPlayers: number | null
    maxCoaches: number | null
    maxReferees: number | null
    storageLimitGb: number | null
    isActive: number | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubPlanCountAggregateOutputType = {
    id: number
    name: number
    planType: number
    price: number
    isPopular: number
    description: number
    features: number
    maxTeams: number
    maxPlayers: number
    maxCoaches: number
    maxReferees: number
    storageLimitGb: number
    isActive: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubPlanAvgAggregateInputType = {
    id?: true
    price?: true
    isPopular?: true
    maxTeams?: true
    maxPlayers?: true
    maxCoaches?: true
    maxReferees?: true
    storageLimitGb?: true
    isActive?: true
    ord?: true
  }

  export type SubPlanSumAggregateInputType = {
    id?: true
    price?: true
    isPopular?: true
    maxTeams?: true
    maxPlayers?: true
    maxCoaches?: true
    maxReferees?: true
    storageLimitGb?: true
    isActive?: true
    ord?: true
  }

  export type SubPlanMinAggregateInputType = {
    id?: true
    name?: true
    planType?: true
    price?: true
    isPopular?: true
    description?: true
    features?: true
    maxTeams?: true
    maxPlayers?: true
    maxCoaches?: true
    maxReferees?: true
    storageLimitGb?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubPlanMaxAggregateInputType = {
    id?: true
    name?: true
    planType?: true
    price?: true
    isPopular?: true
    description?: true
    features?: true
    maxTeams?: true
    maxPlayers?: true
    maxCoaches?: true
    maxReferees?: true
    storageLimitGb?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubPlanCountAggregateInputType = {
    id?: true
    name?: true
    planType?: true
    price?: true
    isPopular?: true
    description?: true
    features?: true
    maxTeams?: true
    maxPlayers?: true
    maxCoaches?: true
    maxReferees?: true
    storageLimitGb?: true
    isActive?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubPlan to aggregate.
     */
    where?: SubPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlans to fetch.
     */
    orderBy?: SubPlanOrderByWithRelationInput | SubPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubPlans
    **/
    _count?: true | SubPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubPlanMaxAggregateInputType
  }

  export type GetSubPlanAggregateType<T extends SubPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSubPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubPlan[P]>
      : GetScalarType<T[P], AggregateSubPlan[P]>
  }




  export type SubPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubPlanWhereInput
    orderBy?: SubPlanOrderByWithAggregationInput | SubPlanOrderByWithAggregationInput[]
    by: SubPlanScalarFieldEnum[] | SubPlanScalarFieldEnum
    having?: SubPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubPlanCountAggregateInputType | true
    _avg?: SubPlanAvgAggregateInputType
    _sum?: SubPlanSumAggregateInputType
    _min?: SubPlanMinAggregateInputType
    _max?: SubPlanMaxAggregateInputType
  }

  export type SubPlanGroupByOutputType = {
    id: Decimal
    name: string
    planType: string
    price: Decimal
    isPopular: number
    description: string | null
    features: string | null
    maxTeams: number | null
    maxPlayers: number | null
    maxCoaches: number | null
    maxReferees: number | null
    storageLimitGb: number | null
    isActive: number
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubPlanCountAggregateOutputType | null
    _avg: SubPlanAvgAggregateOutputType | null
    _sum: SubPlanSumAggregateOutputType | null
    _min: SubPlanMinAggregateOutputType | null
    _max: SubPlanMaxAggregateOutputType | null
  }

  type GetSubPlanGroupByPayload<T extends SubPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SubPlanGroupByOutputType[P]>
        }
      >
    >


  export type SubPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    planType?: boolean
    price?: boolean
    isPopular?: boolean
    description?: boolean
    features?: boolean
    maxTeams?: boolean
    maxPlayers?: boolean
    maxCoaches?: boolean
    maxReferees?: boolean
    storageLimitGb?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subPlan"]>

  export type SubPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    planType?: boolean
    price?: boolean
    isPopular?: boolean
    description?: boolean
    features?: boolean
    maxTeams?: boolean
    maxPlayers?: boolean
    maxCoaches?: boolean
    maxReferees?: boolean
    storageLimitGb?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subPlan"]>

  export type SubPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    planType?: boolean
    price?: boolean
    isPopular?: boolean
    description?: boolean
    features?: boolean
    maxTeams?: boolean
    maxPlayers?: boolean
    maxCoaches?: boolean
    maxReferees?: boolean
    storageLimitGb?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subPlan"]>

  export type SubPlanSelectScalar = {
    id?: boolean
    name?: boolean
    planType?: boolean
    price?: boolean
    isPopular?: boolean
    description?: boolean
    features?: boolean
    maxTeams?: boolean
    maxPlayers?: boolean
    maxCoaches?: boolean
    maxReferees?: boolean
    storageLimitGb?: boolean
    isActive?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "planType" | "price" | "isPopular" | "description" | "features" | "maxTeams" | "maxPlayers" | "maxCoaches" | "maxReferees" | "storageLimitGb" | "isActive" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["subPlan"]>

  export type $SubPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubPlan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      name: string
      planType: string
      price: Prisma.Decimal
      isPopular: number
      description: string | null
      features: string | null
      maxTeams: number | null
      maxPlayers: number | null
      maxCoaches: number | null
      maxReferees: number | null
      storageLimitGb: number | null
      isActive: number
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["subPlan"]>
    composites: {}
  }

  type SubPlanGetPayload<S extends boolean | null | undefined | SubPlanDefaultArgs> = $Result.GetResult<Prisma.$SubPlanPayload, S>

  type SubPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubPlanCountAggregateInputType | true
    }

  export interface SubPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubPlan'], meta: { name: 'SubPlan' } }
    /**
     * Find zero or one SubPlan that matches the filter.
     * @param {SubPlanFindUniqueArgs} args - Arguments to find a SubPlan
     * @example
     * // Get one SubPlan
     * const subPlan = await prisma.subPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubPlanFindUniqueArgs>(args: SelectSubset<T, SubPlanFindUniqueArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubPlanFindUniqueOrThrowArgs} args - Arguments to find a SubPlan
     * @example
     * // Get one SubPlan
     * const subPlan = await prisma.subPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SubPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFindFirstArgs} args - Arguments to find a SubPlan
     * @example
     * // Get one SubPlan
     * const subPlan = await prisma.subPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubPlanFindFirstArgs>(args?: SelectSubset<T, SubPlanFindFirstArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFindFirstOrThrowArgs} args - Arguments to find a SubPlan
     * @example
     * // Get one SubPlan
     * const subPlan = await prisma.subPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SubPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubPlans
     * const subPlans = await prisma.subPlan.findMany()
     * 
     * // Get first 10 SubPlans
     * const subPlans = await prisma.subPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subPlanWithIdOnly = await prisma.subPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubPlanFindManyArgs>(args?: SelectSubset<T, SubPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubPlan.
     * @param {SubPlanCreateArgs} args - Arguments to create a SubPlan.
     * @example
     * // Create one SubPlan
     * const SubPlan = await prisma.subPlan.create({
     *   data: {
     *     // ... data to create a SubPlan
     *   }
     * })
     * 
     */
    create<T extends SubPlanCreateArgs>(args: SelectSubset<T, SubPlanCreateArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubPlans.
     * @param {SubPlanCreateManyArgs} args - Arguments to create many SubPlans.
     * @example
     * // Create many SubPlans
     * const subPlan = await prisma.subPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubPlanCreateManyArgs>(args?: SelectSubset<T, SubPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubPlans and returns the data saved in the database.
     * @param {SubPlanCreateManyAndReturnArgs} args - Arguments to create many SubPlans.
     * @example
     * // Create many SubPlans
     * const subPlan = await prisma.subPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubPlans and only return the `id`
     * const subPlanWithIdOnly = await prisma.subPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SubPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubPlan.
     * @param {SubPlanDeleteArgs} args - Arguments to delete one SubPlan.
     * @example
     * // Delete one SubPlan
     * const SubPlan = await prisma.subPlan.delete({
     *   where: {
     *     // ... filter to delete one SubPlan
     *   }
     * })
     * 
     */
    delete<T extends SubPlanDeleteArgs>(args: SelectSubset<T, SubPlanDeleteArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubPlan.
     * @param {SubPlanUpdateArgs} args - Arguments to update one SubPlan.
     * @example
     * // Update one SubPlan
     * const subPlan = await prisma.subPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubPlanUpdateArgs>(args: SelectSubset<T, SubPlanUpdateArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubPlans.
     * @param {SubPlanDeleteManyArgs} args - Arguments to filter SubPlans to delete.
     * @example
     * // Delete a few SubPlans
     * const { count } = await prisma.subPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubPlanDeleteManyArgs>(args?: SelectSubset<T, SubPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubPlans
     * const subPlan = await prisma.subPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubPlanUpdateManyArgs>(args: SelectSubset<T, SubPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubPlans and returns the data updated in the database.
     * @param {SubPlanUpdateManyAndReturnArgs} args - Arguments to update many SubPlans.
     * @example
     * // Update many SubPlans
     * const subPlan = await prisma.subPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubPlans and only return the `id`
     * const subPlanWithIdOnly = await prisma.subPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SubPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubPlan.
     * @param {SubPlanUpsertArgs} args - Arguments to update or create a SubPlan.
     * @example
     * // Update or create a SubPlan
     * const subPlan = await prisma.subPlan.upsert({
     *   create: {
     *     // ... data to create a SubPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubPlanUpsertArgs>(args: SelectSubset<T, SubPlanUpsertArgs<ExtArgs>>): Prisma__SubPlanClient<$Result.GetResult<Prisma.$SubPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanCountArgs} args - Arguments to filter SubPlans to count.
     * @example
     * // Count the number of SubPlans
     * const count = await prisma.subPlan.count({
     *   where: {
     *     // ... the filter for the SubPlans we want to count
     *   }
     * })
    **/
    count<T extends SubPlanCountArgs>(
      args?: Subset<T, SubPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubPlanAggregateArgs>(args: Subset<T, SubPlanAggregateArgs>): Prisma.PrismaPromise<GetSubPlanAggregateType<T>>

    /**
     * Group by SubPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubPlan model
   */
  readonly fields: SubPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubPlan model
   */
  interface SubPlanFieldRefs {
    readonly id: FieldRef<"SubPlan", 'Decimal'>
    readonly name: FieldRef<"SubPlan", 'String'>
    readonly planType: FieldRef<"SubPlan", 'String'>
    readonly price: FieldRef<"SubPlan", 'Decimal'>
    readonly isPopular: FieldRef<"SubPlan", 'Int'>
    readonly description: FieldRef<"SubPlan", 'String'>
    readonly features: FieldRef<"SubPlan", 'String'>
    readonly maxTeams: FieldRef<"SubPlan", 'Int'>
    readonly maxPlayers: FieldRef<"SubPlan", 'Int'>
    readonly maxCoaches: FieldRef<"SubPlan", 'Int'>
    readonly maxReferees: FieldRef<"SubPlan", 'Int'>
    readonly storageLimitGb: FieldRef<"SubPlan", 'Int'>
    readonly isActive: FieldRef<"SubPlan", 'Int'>
    readonly ord: FieldRef<"SubPlan", 'Int'>
    readonly createdAt: FieldRef<"SubPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SubPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubPlan findUnique
   */
  export type SubPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * Filter, which SubPlan to fetch.
     */
    where: SubPlanWhereUniqueInput
  }

  /**
   * SubPlan findUniqueOrThrow
   */
  export type SubPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * Filter, which SubPlan to fetch.
     */
    where: SubPlanWhereUniqueInput
  }

  /**
   * SubPlan findFirst
   */
  export type SubPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * Filter, which SubPlan to fetch.
     */
    where?: SubPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlans to fetch.
     */
    orderBy?: SubPlanOrderByWithRelationInput | SubPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubPlans.
     */
    cursor?: SubPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubPlans.
     */
    distinct?: SubPlanScalarFieldEnum | SubPlanScalarFieldEnum[]
  }

  /**
   * SubPlan findFirstOrThrow
   */
  export type SubPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * Filter, which SubPlan to fetch.
     */
    where?: SubPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlans to fetch.
     */
    orderBy?: SubPlanOrderByWithRelationInput | SubPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubPlans.
     */
    cursor?: SubPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubPlans.
     */
    distinct?: SubPlanScalarFieldEnum | SubPlanScalarFieldEnum[]
  }

  /**
   * SubPlan findMany
   */
  export type SubPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * Filter, which SubPlans to fetch.
     */
    where?: SubPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlans to fetch.
     */
    orderBy?: SubPlanOrderByWithRelationInput | SubPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubPlans.
     */
    cursor?: SubPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlans.
     */
    skip?: number
    distinct?: SubPlanScalarFieldEnum | SubPlanScalarFieldEnum[]
  }

  /**
   * SubPlan create
   */
  export type SubPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * The data needed to create a SubPlan.
     */
    data: XOR<SubPlanCreateInput, SubPlanUncheckedCreateInput>
  }

  /**
   * SubPlan createMany
   */
  export type SubPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubPlans.
     */
    data: SubPlanCreateManyInput | SubPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubPlan createManyAndReturn
   */
  export type SubPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SubPlans.
     */
    data: SubPlanCreateManyInput | SubPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubPlan update
   */
  export type SubPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * The data needed to update a SubPlan.
     */
    data: XOR<SubPlanUpdateInput, SubPlanUncheckedUpdateInput>
    /**
     * Choose, which SubPlan to update.
     */
    where: SubPlanWhereUniqueInput
  }

  /**
   * SubPlan updateMany
   */
  export type SubPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubPlans.
     */
    data: XOR<SubPlanUpdateManyMutationInput, SubPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubPlans to update
     */
    where?: SubPlanWhereInput
    /**
     * Limit how many SubPlans to update.
     */
    limit?: number
  }

  /**
   * SubPlan updateManyAndReturn
   */
  export type SubPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * The data used to update SubPlans.
     */
    data: XOR<SubPlanUpdateManyMutationInput, SubPlanUncheckedUpdateManyInput>
    /**
     * Filter which SubPlans to update
     */
    where?: SubPlanWhereInput
    /**
     * Limit how many SubPlans to update.
     */
    limit?: number
  }

  /**
   * SubPlan upsert
   */
  export type SubPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * The filter to search for the SubPlan to update in case it exists.
     */
    where: SubPlanWhereUniqueInput
    /**
     * In case the SubPlan found by the `where` argument doesn't exist, create a new SubPlan with this data.
     */
    create: XOR<SubPlanCreateInput, SubPlanUncheckedCreateInput>
    /**
     * In case the SubPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubPlanUpdateInput, SubPlanUncheckedUpdateInput>
  }

  /**
   * SubPlan delete
   */
  export type SubPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
    /**
     * Filter which SubPlan to delete.
     */
    where: SubPlanWhereUniqueInput
  }

  /**
   * SubPlan deleteMany
   */
  export type SubPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubPlans to delete
     */
    where?: SubPlanWhereInput
    /**
     * Limit how many SubPlans to delete.
     */
    limit?: number
  }

  /**
   * SubPlan without action
   */
  export type SubPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlan
     */
    select?: SubPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlan
     */
    omit?: SubPlanOmit<ExtArgs> | null
  }


  /**
   * Model SubPlanFeature
   */

  export type AggregateSubPlanFeature = {
    _count: SubPlanFeatureCountAggregateOutputType | null
    _avg: SubPlanFeatureAvgAggregateOutputType | null
    _sum: SubPlanFeatureSumAggregateOutputType | null
    _min: SubPlanFeatureMinAggregateOutputType | null
    _max: SubPlanFeatureMaxAggregateOutputType | null
  }

  export type SubPlanFeatureAvgAggregateOutputType = {
    id: Decimal | null
    planId: Decimal | null
    featureId: Decimal | null
    isIncluded: number | null
    ord: number | null
  }

  export type SubPlanFeatureSumAggregateOutputType = {
    id: Decimal | null
    planId: Decimal | null
    featureId: Decimal | null
    isIncluded: number | null
    ord: number | null
  }

  export type SubPlanFeatureMinAggregateOutputType = {
    id: Decimal | null
    planId: Decimal | null
    featureId: Decimal | null
    isIncluded: number | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubPlanFeatureMaxAggregateOutputType = {
    id: Decimal | null
    planId: Decimal | null
    featureId: Decimal | null
    isIncluded: number | null
    notes: string | null
    ord: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubPlanFeatureCountAggregateOutputType = {
    id: number
    planId: number
    featureId: number
    isIncluded: number
    notes: number
    ord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubPlanFeatureAvgAggregateInputType = {
    id?: true
    planId?: true
    featureId?: true
    isIncluded?: true
    ord?: true
  }

  export type SubPlanFeatureSumAggregateInputType = {
    id?: true
    planId?: true
    featureId?: true
    isIncluded?: true
    ord?: true
  }

  export type SubPlanFeatureMinAggregateInputType = {
    id?: true
    planId?: true
    featureId?: true
    isIncluded?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubPlanFeatureMaxAggregateInputType = {
    id?: true
    planId?: true
    featureId?: true
    isIncluded?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubPlanFeatureCountAggregateInputType = {
    id?: true
    planId?: true
    featureId?: true
    isIncluded?: true
    notes?: true
    ord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubPlanFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubPlanFeature to aggregate.
     */
    where?: SubPlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlanFeatures to fetch.
     */
    orderBy?: SubPlanFeatureOrderByWithRelationInput | SubPlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubPlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubPlanFeatures
    **/
    _count?: true | SubPlanFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubPlanFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubPlanFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubPlanFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubPlanFeatureMaxAggregateInputType
  }

  export type GetSubPlanFeatureAggregateType<T extends SubPlanFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSubPlanFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubPlanFeature[P]>
      : GetScalarType<T[P], AggregateSubPlanFeature[P]>
  }




  export type SubPlanFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubPlanFeatureWhereInput
    orderBy?: SubPlanFeatureOrderByWithAggregationInput | SubPlanFeatureOrderByWithAggregationInput[]
    by: SubPlanFeatureScalarFieldEnum[] | SubPlanFeatureScalarFieldEnum
    having?: SubPlanFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubPlanFeatureCountAggregateInputType | true
    _avg?: SubPlanFeatureAvgAggregateInputType
    _sum?: SubPlanFeatureSumAggregateInputType
    _min?: SubPlanFeatureMinAggregateInputType
    _max?: SubPlanFeatureMaxAggregateInputType
  }

  export type SubPlanFeatureGroupByOutputType = {
    id: Decimal
    planId: Decimal
    featureId: Decimal
    isIncluded: number
    notes: string | null
    ord: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubPlanFeatureCountAggregateOutputType | null
    _avg: SubPlanFeatureAvgAggregateOutputType | null
    _sum: SubPlanFeatureSumAggregateOutputType | null
    _min: SubPlanFeatureMinAggregateOutputType | null
    _max: SubPlanFeatureMaxAggregateOutputType | null
  }

  type GetSubPlanFeatureGroupByPayload<T extends SubPlanFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubPlanFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubPlanFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubPlanFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], SubPlanFeatureGroupByOutputType[P]>
        }
      >
    >


  export type SubPlanFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureId?: boolean
    isIncluded?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subPlanFeature"]>

  export type SubPlanFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureId?: boolean
    isIncluded?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subPlanFeature"]>

  export type SubPlanFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    featureId?: boolean
    isIncluded?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subPlanFeature"]>

  export type SubPlanFeatureSelectScalar = {
    id?: boolean
    planId?: boolean
    featureId?: boolean
    isIncluded?: boolean
    notes?: boolean
    ord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubPlanFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "featureId" | "isIncluded" | "notes" | "ord" | "createdAt" | "updatedAt", ExtArgs["result"]["subPlanFeature"]>

  export type $SubPlanFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubPlanFeature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      planId: Prisma.Decimal
      featureId: Prisma.Decimal
      isIncluded: number
      notes: string | null
      ord: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["subPlanFeature"]>
    composites: {}
  }

  type SubPlanFeatureGetPayload<S extends boolean | null | undefined | SubPlanFeatureDefaultArgs> = $Result.GetResult<Prisma.$SubPlanFeaturePayload, S>

  type SubPlanFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubPlanFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubPlanFeatureCountAggregateInputType | true
    }

  export interface SubPlanFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubPlanFeature'], meta: { name: 'SubPlanFeature' } }
    /**
     * Find zero or one SubPlanFeature that matches the filter.
     * @param {SubPlanFeatureFindUniqueArgs} args - Arguments to find a SubPlanFeature
     * @example
     * // Get one SubPlanFeature
     * const subPlanFeature = await prisma.subPlanFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubPlanFeatureFindUniqueArgs>(args: SelectSubset<T, SubPlanFeatureFindUniqueArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubPlanFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubPlanFeatureFindUniqueOrThrowArgs} args - Arguments to find a SubPlanFeature
     * @example
     * // Get one SubPlanFeature
     * const subPlanFeature = await prisma.subPlanFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubPlanFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SubPlanFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubPlanFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureFindFirstArgs} args - Arguments to find a SubPlanFeature
     * @example
     * // Get one SubPlanFeature
     * const subPlanFeature = await prisma.subPlanFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubPlanFeatureFindFirstArgs>(args?: SelectSubset<T, SubPlanFeatureFindFirstArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubPlanFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureFindFirstOrThrowArgs} args - Arguments to find a SubPlanFeature
     * @example
     * // Get one SubPlanFeature
     * const subPlanFeature = await prisma.subPlanFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubPlanFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SubPlanFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubPlanFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubPlanFeatures
     * const subPlanFeatures = await prisma.subPlanFeature.findMany()
     * 
     * // Get first 10 SubPlanFeatures
     * const subPlanFeatures = await prisma.subPlanFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subPlanFeatureWithIdOnly = await prisma.subPlanFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubPlanFeatureFindManyArgs>(args?: SelectSubset<T, SubPlanFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubPlanFeature.
     * @param {SubPlanFeatureCreateArgs} args - Arguments to create a SubPlanFeature.
     * @example
     * // Create one SubPlanFeature
     * const SubPlanFeature = await prisma.subPlanFeature.create({
     *   data: {
     *     // ... data to create a SubPlanFeature
     *   }
     * })
     * 
     */
    create<T extends SubPlanFeatureCreateArgs>(args: SelectSubset<T, SubPlanFeatureCreateArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubPlanFeatures.
     * @param {SubPlanFeatureCreateManyArgs} args - Arguments to create many SubPlanFeatures.
     * @example
     * // Create many SubPlanFeatures
     * const subPlanFeature = await prisma.subPlanFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubPlanFeatureCreateManyArgs>(args?: SelectSubset<T, SubPlanFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubPlanFeatures and returns the data saved in the database.
     * @param {SubPlanFeatureCreateManyAndReturnArgs} args - Arguments to create many SubPlanFeatures.
     * @example
     * // Create many SubPlanFeatures
     * const subPlanFeature = await prisma.subPlanFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubPlanFeatures and only return the `id`
     * const subPlanFeatureWithIdOnly = await prisma.subPlanFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubPlanFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, SubPlanFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubPlanFeature.
     * @param {SubPlanFeatureDeleteArgs} args - Arguments to delete one SubPlanFeature.
     * @example
     * // Delete one SubPlanFeature
     * const SubPlanFeature = await prisma.subPlanFeature.delete({
     *   where: {
     *     // ... filter to delete one SubPlanFeature
     *   }
     * })
     * 
     */
    delete<T extends SubPlanFeatureDeleteArgs>(args: SelectSubset<T, SubPlanFeatureDeleteArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubPlanFeature.
     * @param {SubPlanFeatureUpdateArgs} args - Arguments to update one SubPlanFeature.
     * @example
     * // Update one SubPlanFeature
     * const subPlanFeature = await prisma.subPlanFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubPlanFeatureUpdateArgs>(args: SelectSubset<T, SubPlanFeatureUpdateArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubPlanFeatures.
     * @param {SubPlanFeatureDeleteManyArgs} args - Arguments to filter SubPlanFeatures to delete.
     * @example
     * // Delete a few SubPlanFeatures
     * const { count } = await prisma.subPlanFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubPlanFeatureDeleteManyArgs>(args?: SelectSubset<T, SubPlanFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubPlanFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubPlanFeatures
     * const subPlanFeature = await prisma.subPlanFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubPlanFeatureUpdateManyArgs>(args: SelectSubset<T, SubPlanFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubPlanFeatures and returns the data updated in the database.
     * @param {SubPlanFeatureUpdateManyAndReturnArgs} args - Arguments to update many SubPlanFeatures.
     * @example
     * // Update many SubPlanFeatures
     * const subPlanFeature = await prisma.subPlanFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubPlanFeatures and only return the `id`
     * const subPlanFeatureWithIdOnly = await prisma.subPlanFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubPlanFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, SubPlanFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubPlanFeature.
     * @param {SubPlanFeatureUpsertArgs} args - Arguments to update or create a SubPlanFeature.
     * @example
     * // Update or create a SubPlanFeature
     * const subPlanFeature = await prisma.subPlanFeature.upsert({
     *   create: {
     *     // ... data to create a SubPlanFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubPlanFeature we want to update
     *   }
     * })
     */
    upsert<T extends SubPlanFeatureUpsertArgs>(args: SelectSubset<T, SubPlanFeatureUpsertArgs<ExtArgs>>): Prisma__SubPlanFeatureClient<$Result.GetResult<Prisma.$SubPlanFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubPlanFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureCountArgs} args - Arguments to filter SubPlanFeatures to count.
     * @example
     * // Count the number of SubPlanFeatures
     * const count = await prisma.subPlanFeature.count({
     *   where: {
     *     // ... the filter for the SubPlanFeatures we want to count
     *   }
     * })
    **/
    count<T extends SubPlanFeatureCountArgs>(
      args?: Subset<T, SubPlanFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubPlanFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubPlanFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubPlanFeatureAggregateArgs>(args: Subset<T, SubPlanFeatureAggregateArgs>): Prisma.PrismaPromise<GetSubPlanFeatureAggregateType<T>>

    /**
     * Group by SubPlanFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubPlanFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubPlanFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubPlanFeatureGroupByArgs['orderBy'] }
        : { orderBy?: SubPlanFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubPlanFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubPlanFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubPlanFeature model
   */
  readonly fields: SubPlanFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubPlanFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubPlanFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubPlanFeature model
   */
  interface SubPlanFeatureFieldRefs {
    readonly id: FieldRef<"SubPlanFeature", 'Decimal'>
    readonly planId: FieldRef<"SubPlanFeature", 'Decimal'>
    readonly featureId: FieldRef<"SubPlanFeature", 'Decimal'>
    readonly isIncluded: FieldRef<"SubPlanFeature", 'Int'>
    readonly notes: FieldRef<"SubPlanFeature", 'String'>
    readonly ord: FieldRef<"SubPlanFeature", 'Int'>
    readonly createdAt: FieldRef<"SubPlanFeature", 'DateTime'>
    readonly updatedAt: FieldRef<"SubPlanFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubPlanFeature findUnique
   */
  export type SubPlanFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubPlanFeature to fetch.
     */
    where: SubPlanFeatureWhereUniqueInput
  }

  /**
   * SubPlanFeature findUniqueOrThrow
   */
  export type SubPlanFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubPlanFeature to fetch.
     */
    where: SubPlanFeatureWhereUniqueInput
  }

  /**
   * SubPlanFeature findFirst
   */
  export type SubPlanFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubPlanFeature to fetch.
     */
    where?: SubPlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlanFeatures to fetch.
     */
    orderBy?: SubPlanFeatureOrderByWithRelationInput | SubPlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubPlanFeatures.
     */
    cursor?: SubPlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubPlanFeatures.
     */
    distinct?: SubPlanFeatureScalarFieldEnum | SubPlanFeatureScalarFieldEnum[]
  }

  /**
   * SubPlanFeature findFirstOrThrow
   */
  export type SubPlanFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubPlanFeature to fetch.
     */
    where?: SubPlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlanFeatures to fetch.
     */
    orderBy?: SubPlanFeatureOrderByWithRelationInput | SubPlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubPlanFeatures.
     */
    cursor?: SubPlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlanFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubPlanFeatures.
     */
    distinct?: SubPlanFeatureScalarFieldEnum | SubPlanFeatureScalarFieldEnum[]
  }

  /**
   * SubPlanFeature findMany
   */
  export type SubPlanFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * Filter, which SubPlanFeatures to fetch.
     */
    where?: SubPlanFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubPlanFeatures to fetch.
     */
    orderBy?: SubPlanFeatureOrderByWithRelationInput | SubPlanFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubPlanFeatures.
     */
    cursor?: SubPlanFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubPlanFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubPlanFeatures.
     */
    skip?: number
    distinct?: SubPlanFeatureScalarFieldEnum | SubPlanFeatureScalarFieldEnum[]
  }

  /**
   * SubPlanFeature create
   */
  export type SubPlanFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * The data needed to create a SubPlanFeature.
     */
    data: XOR<SubPlanFeatureCreateInput, SubPlanFeatureUncheckedCreateInput>
  }

  /**
   * SubPlanFeature createMany
   */
  export type SubPlanFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubPlanFeatures.
     */
    data: SubPlanFeatureCreateManyInput | SubPlanFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubPlanFeature createManyAndReturn
   */
  export type SubPlanFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many SubPlanFeatures.
     */
    data: SubPlanFeatureCreateManyInput | SubPlanFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubPlanFeature update
   */
  export type SubPlanFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * The data needed to update a SubPlanFeature.
     */
    data: XOR<SubPlanFeatureUpdateInput, SubPlanFeatureUncheckedUpdateInput>
    /**
     * Choose, which SubPlanFeature to update.
     */
    where: SubPlanFeatureWhereUniqueInput
  }

  /**
   * SubPlanFeature updateMany
   */
  export type SubPlanFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubPlanFeatures.
     */
    data: XOR<SubPlanFeatureUpdateManyMutationInput, SubPlanFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubPlanFeatures to update
     */
    where?: SubPlanFeatureWhereInput
    /**
     * Limit how many SubPlanFeatures to update.
     */
    limit?: number
  }

  /**
   * SubPlanFeature updateManyAndReturn
   */
  export type SubPlanFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * The data used to update SubPlanFeatures.
     */
    data: XOR<SubPlanFeatureUpdateManyMutationInput, SubPlanFeatureUncheckedUpdateManyInput>
    /**
     * Filter which SubPlanFeatures to update
     */
    where?: SubPlanFeatureWhereInput
    /**
     * Limit how many SubPlanFeatures to update.
     */
    limit?: number
  }

  /**
   * SubPlanFeature upsert
   */
  export type SubPlanFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * The filter to search for the SubPlanFeature to update in case it exists.
     */
    where: SubPlanFeatureWhereUniqueInput
    /**
     * In case the SubPlanFeature found by the `where` argument doesn't exist, create a new SubPlanFeature with this data.
     */
    create: XOR<SubPlanFeatureCreateInput, SubPlanFeatureUncheckedCreateInput>
    /**
     * In case the SubPlanFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubPlanFeatureUpdateInput, SubPlanFeatureUncheckedUpdateInput>
  }

  /**
   * SubPlanFeature delete
   */
  export type SubPlanFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
    /**
     * Filter which SubPlanFeature to delete.
     */
    where: SubPlanFeatureWhereUniqueInput
  }

  /**
   * SubPlanFeature deleteMany
   */
  export type SubPlanFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubPlanFeatures to delete
     */
    where?: SubPlanFeatureWhereInput
    /**
     * Limit how many SubPlanFeatures to delete.
     */
    limit?: number
  }

  /**
   * SubPlanFeature without action
   */
  export type SubPlanFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubPlanFeature
     */
    select?: SubPlanFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubPlanFeature
     */
    omit?: SubPlanFeatureOmit<ExtArgs> | null
  }


  /**
   * Model SysUser
   */

  export type AggregateSysUser = {
    _count: SysUserCountAggregateOutputType | null
    _avg: SysUserAvgAggregateOutputType | null
    _sum: SysUserSumAggregateOutputType | null
    _min: SysUserMinAggregateOutputType | null
    _max: SysUserMaxAggregateOutputType | null
  }

  export type SysUserAvgAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
  }

  export type SysUserSumAggregateOutputType = {
    id: Decimal | null
    personId: Decimal | null
  }

  export type SysUserMinAggregateOutputType = {
    id: Decimal | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerifiedAt: Date | null
    password: string | null
    status: string | null
    personId: Decimal | null
    rememberToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SysUserMaxAggregateOutputType = {
    id: Decimal | null
    firstName: string | null
    lastName: string | null
    email: string | null
    emailVerifiedAt: Date | null
    password: string | null
    status: string | null
    personId: Decimal | null
    rememberToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SysUserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    emailVerifiedAt: number
    password: number
    status: number
    personId: number
    rememberToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SysUserAvgAggregateInputType = {
    id?: true
    personId?: true
  }

  export type SysUserSumAggregateInputType = {
    id?: true
    personId?: true
  }

  export type SysUserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerifiedAt?: true
    password?: true
    status?: true
    personId?: true
    rememberToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SysUserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerifiedAt?: true
    password?: true
    status?: true
    personId?: true
    rememberToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SysUserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    emailVerifiedAt?: true
    password?: true
    status?: true
    personId?: true
    rememberToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SysUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SysUser to aggregate.
     */
    where?: SysUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SysUsers to fetch.
     */
    orderBy?: SysUserOrderByWithRelationInput | SysUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SysUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SysUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SysUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SysUsers
    **/
    _count?: true | SysUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysUserMaxAggregateInputType
  }

  export type GetSysUserAggregateType<T extends SysUserAggregateArgs> = {
        [P in keyof T & keyof AggregateSysUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysUser[P]>
      : GetScalarType<T[P], AggregateSysUser[P]>
  }




  export type SysUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SysUserWhereInput
    orderBy?: SysUserOrderByWithAggregationInput | SysUserOrderByWithAggregationInput[]
    by: SysUserScalarFieldEnum[] | SysUserScalarFieldEnum
    having?: SysUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysUserCountAggregateInputType | true
    _avg?: SysUserAvgAggregateInputType
    _sum?: SysUserSumAggregateInputType
    _min?: SysUserMinAggregateInputType
    _max?: SysUserMaxAggregateInputType
  }

  export type SysUserGroupByOutputType = {
    id: Decimal
    firstName: string
    lastName: string
    email: string
    emailVerifiedAt: Date | null
    password: string
    status: string
    personId: Decimal | null
    rememberToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SysUserCountAggregateOutputType | null
    _avg: SysUserAvgAggregateOutputType | null
    _sum: SysUserSumAggregateOutputType | null
    _min: SysUserMinAggregateOutputType | null
    _max: SysUserMaxAggregateOutputType | null
  }

  type GetSysUserGroupByPayload<T extends SysUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysUserGroupByOutputType[P]>
            : GetScalarType<T[P], SysUserGroupByOutputType[P]>
        }
      >
    >


  export type SysUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    status?: boolean
    personId?: boolean
    rememberToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sysUser"]>

  export type SysUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    status?: boolean
    personId?: boolean
    rememberToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sysUser"]>

  export type SysUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    status?: boolean
    personId?: boolean
    rememberToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sysUser"]>

  export type SysUserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    status?: boolean
    personId?: boolean
    rememberToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SysUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "emailVerifiedAt" | "password" | "status" | "personId" | "rememberToken" | "createdAt" | "updatedAt", ExtArgs["result"]["sysUser"]>

  export type $SysUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SysUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Prisma.Decimal
      firstName: string
      lastName: string
      email: string
      emailVerifiedAt: Date | null
      password: string
      status: string
      personId: Prisma.Decimal | null
      rememberToken: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["sysUser"]>
    composites: {}
  }

  type SysUserGetPayload<S extends boolean | null | undefined | SysUserDefaultArgs> = $Result.GetResult<Prisma.$SysUserPayload, S>

  type SysUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SysUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SysUserCountAggregateInputType | true
    }

  export interface SysUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SysUser'], meta: { name: 'SysUser' } }
    /**
     * Find zero or one SysUser that matches the filter.
     * @param {SysUserFindUniqueArgs} args - Arguments to find a SysUser
     * @example
     * // Get one SysUser
     * const sysUser = await prisma.sysUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SysUserFindUniqueArgs>(args: SelectSubset<T, SysUserFindUniqueArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SysUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SysUserFindUniqueOrThrowArgs} args - Arguments to find a SysUser
     * @example
     * // Get one SysUser
     * const sysUser = await prisma.sysUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SysUserFindUniqueOrThrowArgs>(args: SelectSubset<T, SysUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SysUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserFindFirstArgs} args - Arguments to find a SysUser
     * @example
     * // Get one SysUser
     * const sysUser = await prisma.sysUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SysUserFindFirstArgs>(args?: SelectSubset<T, SysUserFindFirstArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SysUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserFindFirstOrThrowArgs} args - Arguments to find a SysUser
     * @example
     * // Get one SysUser
     * const sysUser = await prisma.sysUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SysUserFindFirstOrThrowArgs>(args?: SelectSubset<T, SysUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SysUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SysUsers
     * const sysUsers = await prisma.sysUser.findMany()
     * 
     * // Get first 10 SysUsers
     * const sysUsers = await prisma.sysUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sysUserWithIdOnly = await prisma.sysUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SysUserFindManyArgs>(args?: SelectSubset<T, SysUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SysUser.
     * @param {SysUserCreateArgs} args - Arguments to create a SysUser.
     * @example
     * // Create one SysUser
     * const SysUser = await prisma.sysUser.create({
     *   data: {
     *     // ... data to create a SysUser
     *   }
     * })
     * 
     */
    create<T extends SysUserCreateArgs>(args: SelectSubset<T, SysUserCreateArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SysUsers.
     * @param {SysUserCreateManyArgs} args - Arguments to create many SysUsers.
     * @example
     * // Create many SysUsers
     * const sysUser = await prisma.sysUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SysUserCreateManyArgs>(args?: SelectSubset<T, SysUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SysUsers and returns the data saved in the database.
     * @param {SysUserCreateManyAndReturnArgs} args - Arguments to create many SysUsers.
     * @example
     * // Create many SysUsers
     * const sysUser = await prisma.sysUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SysUsers and only return the `id`
     * const sysUserWithIdOnly = await prisma.sysUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SysUserCreateManyAndReturnArgs>(args?: SelectSubset<T, SysUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SysUser.
     * @param {SysUserDeleteArgs} args - Arguments to delete one SysUser.
     * @example
     * // Delete one SysUser
     * const SysUser = await prisma.sysUser.delete({
     *   where: {
     *     // ... filter to delete one SysUser
     *   }
     * })
     * 
     */
    delete<T extends SysUserDeleteArgs>(args: SelectSubset<T, SysUserDeleteArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SysUser.
     * @param {SysUserUpdateArgs} args - Arguments to update one SysUser.
     * @example
     * // Update one SysUser
     * const sysUser = await prisma.sysUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SysUserUpdateArgs>(args: SelectSubset<T, SysUserUpdateArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SysUsers.
     * @param {SysUserDeleteManyArgs} args - Arguments to filter SysUsers to delete.
     * @example
     * // Delete a few SysUsers
     * const { count } = await prisma.sysUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SysUserDeleteManyArgs>(args?: SelectSubset<T, SysUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SysUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SysUsers
     * const sysUser = await prisma.sysUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SysUserUpdateManyArgs>(args: SelectSubset<T, SysUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SysUsers and returns the data updated in the database.
     * @param {SysUserUpdateManyAndReturnArgs} args - Arguments to update many SysUsers.
     * @example
     * // Update many SysUsers
     * const sysUser = await prisma.sysUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SysUsers and only return the `id`
     * const sysUserWithIdOnly = await prisma.sysUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SysUserUpdateManyAndReturnArgs>(args: SelectSubset<T, SysUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SysUser.
     * @param {SysUserUpsertArgs} args - Arguments to update or create a SysUser.
     * @example
     * // Update or create a SysUser
     * const sysUser = await prisma.sysUser.upsert({
     *   create: {
     *     // ... data to create a SysUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SysUser we want to update
     *   }
     * })
     */
    upsert<T extends SysUserUpsertArgs>(args: SelectSubset<T, SysUserUpsertArgs<ExtArgs>>): Prisma__SysUserClient<$Result.GetResult<Prisma.$SysUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SysUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserCountArgs} args - Arguments to filter SysUsers to count.
     * @example
     * // Count the number of SysUsers
     * const count = await prisma.sysUser.count({
     *   where: {
     *     // ... the filter for the SysUsers we want to count
     *   }
     * })
    **/
    count<T extends SysUserCountArgs>(
      args?: Subset<T, SysUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SysUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysUserAggregateArgs>(args: Subset<T, SysUserAggregateArgs>): Prisma.PrismaPromise<GetSysUserAggregateType<T>>

    /**
     * Group by SysUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SysUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SysUserGroupByArgs['orderBy'] }
        : { orderBy?: SysUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SysUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SysUser model
   */
  readonly fields: SysUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SysUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SysUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SysUser model
   */
  interface SysUserFieldRefs {
    readonly id: FieldRef<"SysUser", 'Decimal'>
    readonly firstName: FieldRef<"SysUser", 'String'>
    readonly lastName: FieldRef<"SysUser", 'String'>
    readonly email: FieldRef<"SysUser", 'String'>
    readonly emailVerifiedAt: FieldRef<"SysUser", 'DateTime'>
    readonly password: FieldRef<"SysUser", 'String'>
    readonly status: FieldRef<"SysUser", 'String'>
    readonly personId: FieldRef<"SysUser", 'Decimal'>
    readonly rememberToken: FieldRef<"SysUser", 'String'>
    readonly createdAt: FieldRef<"SysUser", 'DateTime'>
    readonly updatedAt: FieldRef<"SysUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SysUser findUnique
   */
  export type SysUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * Filter, which SysUser to fetch.
     */
    where: SysUserWhereUniqueInput
  }

  /**
   * SysUser findUniqueOrThrow
   */
  export type SysUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * Filter, which SysUser to fetch.
     */
    where: SysUserWhereUniqueInput
  }

  /**
   * SysUser findFirst
   */
  export type SysUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * Filter, which SysUser to fetch.
     */
    where?: SysUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SysUsers to fetch.
     */
    orderBy?: SysUserOrderByWithRelationInput | SysUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SysUsers.
     */
    cursor?: SysUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SysUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SysUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SysUsers.
     */
    distinct?: SysUserScalarFieldEnum | SysUserScalarFieldEnum[]
  }

  /**
   * SysUser findFirstOrThrow
   */
  export type SysUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * Filter, which SysUser to fetch.
     */
    where?: SysUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SysUsers to fetch.
     */
    orderBy?: SysUserOrderByWithRelationInput | SysUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SysUsers.
     */
    cursor?: SysUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SysUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SysUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SysUsers.
     */
    distinct?: SysUserScalarFieldEnum | SysUserScalarFieldEnum[]
  }

  /**
   * SysUser findMany
   */
  export type SysUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * Filter, which SysUsers to fetch.
     */
    where?: SysUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SysUsers to fetch.
     */
    orderBy?: SysUserOrderByWithRelationInput | SysUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SysUsers.
     */
    cursor?: SysUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SysUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SysUsers.
     */
    skip?: number
    distinct?: SysUserScalarFieldEnum | SysUserScalarFieldEnum[]
  }

  /**
   * SysUser create
   */
  export type SysUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * The data needed to create a SysUser.
     */
    data: XOR<SysUserCreateInput, SysUserUncheckedCreateInput>
  }

  /**
   * SysUser createMany
   */
  export type SysUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SysUsers.
     */
    data: SysUserCreateManyInput | SysUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SysUser createManyAndReturn
   */
  export type SysUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * The data used to create many SysUsers.
     */
    data: SysUserCreateManyInput | SysUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SysUser update
   */
  export type SysUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * The data needed to update a SysUser.
     */
    data: XOR<SysUserUpdateInput, SysUserUncheckedUpdateInput>
    /**
     * Choose, which SysUser to update.
     */
    where: SysUserWhereUniqueInput
  }

  /**
   * SysUser updateMany
   */
  export type SysUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SysUsers.
     */
    data: XOR<SysUserUpdateManyMutationInput, SysUserUncheckedUpdateManyInput>
    /**
     * Filter which SysUsers to update
     */
    where?: SysUserWhereInput
    /**
     * Limit how many SysUsers to update.
     */
    limit?: number
  }

  /**
   * SysUser updateManyAndReturn
   */
  export type SysUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * The data used to update SysUsers.
     */
    data: XOR<SysUserUpdateManyMutationInput, SysUserUncheckedUpdateManyInput>
    /**
     * Filter which SysUsers to update
     */
    where?: SysUserWhereInput
    /**
     * Limit how many SysUsers to update.
     */
    limit?: number
  }

  /**
   * SysUser upsert
   */
  export type SysUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * The filter to search for the SysUser to update in case it exists.
     */
    where: SysUserWhereUniqueInput
    /**
     * In case the SysUser found by the `where` argument doesn't exist, create a new SysUser with this data.
     */
    create: XOR<SysUserCreateInput, SysUserUncheckedCreateInput>
    /**
     * In case the SysUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SysUserUpdateInput, SysUserUncheckedUpdateInput>
  }

  /**
   * SysUser delete
   */
  export type SysUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
    /**
     * Filter which SysUser to delete.
     */
    where: SysUserWhereUniqueInput
  }

  /**
   * SysUser deleteMany
   */
  export type SysUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SysUsers to delete
     */
    where?: SysUserWhereInput
    /**
     * Limit how many SysUsers to delete.
     */
    limit?: number
  }

  /**
   * SysUser without action
   */
  export type SysUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SysUser
     */
    select?: SysUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SysUser
     */
    omit?: SysUserOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BaseCompetitionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    sportId: 'sportId',
    description: 'description',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BaseCompetitionScalarFieldEnum = (typeof BaseCompetitionScalarFieldEnum)[keyof typeof BaseCompetitionScalarFieldEnum]


  export const BaseCountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    code: 'code',
    note: 'note',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BaseCountryScalarFieldEnum = (typeof BaseCountryScalarFieldEnum)[keyof typeof BaseCountryScalarFieldEnum]


  export const BaseFieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    isActive: 'isActive',
    sportIds: 'sportIds',
    countryId: 'countryId',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BaseFieldScalarFieldEnum = (typeof BaseFieldScalarFieldEnum)[keyof typeof BaseFieldScalarFieldEnum]


  export const BaseGroupLevelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    minAge: 'minAge',
    maxAge: 'maxAge',
    skillLevel: 'skillLevel',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BaseGroupLevelScalarFieldEnum = (typeof BaseGroupLevelScalarFieldEnum)[keyof typeof BaseGroupLevelScalarFieldEnum]


  export const BaseSportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BaseSportScalarFieldEnum = (typeof BaseSportScalarFieldEnum)[keyof typeof BaseSportScalarFieldEnum]


  export const GameEventScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    competitionId: 'competitionId',
    eventDate: 'eventDate',
    venue: 'venue',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameEventScalarFieldEnum = (typeof GameEventScalarFieldEnum)[keyof typeof GameEventScalarFieldEnum]


  export const GameMatcheScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    homeTeamId: 'homeTeamId',
    awayTeamId: 'awayTeamId',
    homeTeamScore: 'homeTeamScore',
    awayTeamScore: 'awayTeamScore',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameMatcheScalarFieldEnum = (typeof GameMatcheScalarFieldEnum)[keyof typeof GameMatcheScalarFieldEnum]


  export const MatchEventScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    playerId: 'playerId',
    teamId: 'teamId',
    eventType: 'eventType',
    minute: 'minute',
    second: 'second',
    description: 'description',
    eventData: 'eventData',
    fieldX: 'fieldX',
    fieldY: 'fieldY',
    isConfirmed: 'isConfirmed',
    createdBy: 'createdBy',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchEventScalarFieldEnum = (typeof MatchEventScalarFieldEnum)[keyof typeof MatchEventScalarFieldEnum]


  export const MatchLineupScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    teamId: 'teamId',
    formation: 'formation',
    lineupData: 'lineupData',
    announcedAt: 'announcedAt',
    isConfirmed: 'isConfirmed',
    createdBy: 'createdBy',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchLineupScalarFieldEnum = (typeof MatchLineupScalarFieldEnum)[keyof typeof MatchLineupScalarFieldEnum]


  export const MatchMediaScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    mediaType: 'mediaType',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    description: 'description',
    category: 'category',
    isPublic: 'isPublic',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchMediaScalarFieldEnum = (typeof MatchMediaScalarFieldEnum)[keyof typeof MatchMediaScalarFieldEnum]


  export const MatchRosterScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    playerId: 'playerId',
    teamId: 'teamId',
    isStarting: 'isStarting',
    isSubstitute: 'isSubstitute',
    position: 'position',
    jerseyNumber: 'jerseyNumber',
    substitutionInMinute: 'substitutionInMinute',
    substitutionOutMinute: 'substitutionOutMinute',
    substitutionReason: 'substitutionReason',
    minutesPlayed: 'minutesPlayed',
    status: 'status',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchRosterScalarFieldEnum = (typeof MatchRosterScalarFieldEnum)[keyof typeof MatchRosterScalarFieldEnum]


  export const MatchStatisticScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    playerId: 'playerId',
    teamId: 'teamId',
    minutesPlayed: 'minutesPlayed',
    goals: 'goals',
    assists: 'assists',
    shots: 'shots',
    shots_on_target: 'shots_on_target',
    passes: 'passes',
    passesCompleted: 'passesCompleted',
    passAccuracy: 'passAccuracy',
    tackles: 'tackles',
    interceptions: 'interceptions',
    clearances: 'clearances',
    blocks: 'blocks',
    yellowCards: 'yellowCards',
    redCards: 'redCards',
    foulsCommitted: 'foulsCommitted',
    foulsWon: 'foulsWon',
    saves: 'saves',
    goalsConceded: 'goalsConceded',
    cleanSheets: 'cleanSheets',
    rating: 'rating',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchStatisticScalarFieldEnum = (typeof MatchStatisticScalarFieldEnum)[keyof typeof MatchStatisticScalarFieldEnum]


  export const MemberClubAdminScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    clubId: 'clubId',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberClubAdminScalarFieldEnum = (typeof MemberClubAdminScalarFieldEnum)[keyof typeof MemberClubAdminScalarFieldEnum]


  export const MemberCoacheScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    licenseNumber: 'licenseNumber',
    certification: 'certification',
    specialization: 'specialization',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberCoacheScalarFieldEnum = (typeof MemberCoacheScalarFieldEnum)[keyof typeof MemberCoacheScalarFieldEnum]


  export const MemberParentScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    status: 'status',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberParentScalarFieldEnum = (typeof MemberParentScalarFieldEnum)[keyof typeof MemberParentScalarFieldEnum]


  export const MemberPersonScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    dob: 'dob',
    gender: 'gender',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    countryId: 'countryId',
    photoPath: 'photoPath',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberPersonScalarFieldEnum = (typeof MemberPersonScalarFieldEnum)[keyof typeof MemberPersonScalarFieldEnum]


  export const MemberPlayerScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    height: 'height',
    weight: 'weight',
    preferredFoot: 'preferredFoot',
    contractStart: 'contractStart',
    contractEnd: 'contractEnd',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberPlayerScalarFieldEnum = (typeof MemberPlayerScalarFieldEnum)[keyof typeof MemberPlayerScalarFieldEnum]


  export const MemberRefereeScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    licenseNumber: 'licenseNumber',
    licenseLevel: 'licenseLevel',
    certification: 'certification',
    refereeType: 'refereeType',
    specialization: 'specialization',
    languages: 'languages',
    matchFee: 'matchFee',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberRefereeScalarFieldEnum = (typeof MemberRefereeScalarFieldEnum)[keyof typeof MemberRefereeScalarFieldEnum]


  export const MemberSponsorScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    website: 'website',
    sponsorLevel: 'sponsorLevel',
    sponsorshipAmount: 'sponsorshipAmount',
    contractStart: 'contractStart',
    contractEnd: 'contractEnd',
    benefits: 'benefits',
    logoPath: 'logoPath',
    status: 'status',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberSponsorScalarFieldEnum = (typeof MemberSponsorScalarFieldEnum)[keyof typeof MemberSponsorScalarFieldEnum]


  export const MemberTeamManagerScalarFieldEnum: {
    id: 'id',
    personId: 'personId',
    appointedDate: 'appointedDate',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberTeamManagerScalarFieldEnum = (typeof MemberTeamManagerScalarFieldEnum)[keyof typeof MemberTeamManagerScalarFieldEnum]


  export const OrgClubScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    description: 'description',
    foundedDate: 'foundedDate',
    address: 'address',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    status: 'status',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrgClubScalarFieldEnum = (typeof OrgClubScalarFieldEnum)[keyof typeof OrgClubScalarFieldEnum]


  export const OrgLeagueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    description: 'description',
    gameModeId: 'gameModeId',
    groupLevelId: 'groupLevelId',
    season: 'season',
    startDate: 'startDate',
    endDate: 'endDate',
    registrationDeadline: 'registrationDeadline',
    maxTeams: 'maxTeams',
    entryFee: 'entryFee',
    subscribeEmail: 'subscribeEmail',
    rules: 'rules',
    status: 'status',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrgLeagueScalarFieldEnum = (typeof OrgLeagueScalarFieldEnum)[keyof typeof OrgLeagueScalarFieldEnum]


  export const OrgTeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    clubId: 'clubId',
    sportId: 'sportId',
    leagueId: 'leagueId',
    ageGroup: 'ageGroup',
    gender: 'gender',
    skillLevel: 'skillLevel',
    color1: 'color1',
    color2: 'color2',
    maxPlayers: 'maxPlayers',
    status: 'status',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrgTeamScalarFieldEnum = (typeof OrgTeamScalarFieldEnum)[keyof typeof OrgTeamScalarFieldEnum]


  export const PlanGameScalarFieldEnum: {
    id: 'id',
    leagueId: 'leagueId',
    gameName: 'gameName',
    homeTeamId: 'homeTeamId',
    awayTeamId: 'awayTeamId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    duration: 'duration',
    uniform: 'uniform',
    locationId: 'locationId',
    isScrimmage: 'isScrimmage',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanGameScalarFieldEnum = (typeof PlanGameScalarFieldEnum)[keyof typeof PlanGameScalarFieldEnum]


  export const PlanMeetingScalarFieldEnum: {
    id: 'id',
    meetingCategory: 'meetingCategory',
    teamId: 'teamId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    title: 'title',
    content: 'content',
    locationId: 'locationId',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanMeetingScalarFieldEnum = (typeof PlanMeetingScalarFieldEnum)[keyof typeof PlanMeetingScalarFieldEnum]


  export const PlanTrainingScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    startDatetime: 'startDatetime',
    endDatetime: 'endDatetime',
    trainingContent: 'trainingContent',
    isAllMembers: 'isAllMembers',
    locationId: 'locationId',
    recurringType: 'recurringType',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanTrainingScalarFieldEnum = (typeof PlanTrainingScalarFieldEnum)[keyof typeof PlanTrainingScalarFieldEnum]


  export const RelClubClubAdminScalarFieldEnum: {
    id: 'id',
    clubId: 'clubId',
    adminId: 'adminId',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    status: 'status',
    role: 'role',
    salary: 'salary',
    contractStart: 'contractStart',
    contractEnd: 'contractEnd',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelClubClubAdminScalarFieldEnum = (typeof RelClubClubAdminScalarFieldEnum)[keyof typeof RelClubClubAdminScalarFieldEnum]


  export const RelCompetitionGroupLevelScalarFieldEnum: {
    id: 'id',
    competitionId: 'competitionId',
    groupLevelId: 'groupLevelId',
    isPrimary: 'isPrimary',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelCompetitionGroupLevelScalarFieldEnum = (typeof RelCompetitionGroupLevelScalarFieldEnum)[keyof typeof RelCompetitionGroupLevelScalarFieldEnum]


  export const RelFieldSportScalarFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    sportId: 'sportId',
    isPrimary: 'isPrimary',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelFieldSportScalarFieldEnum = (typeof RelFieldSportScalarFieldEnum)[keyof typeof RelFieldSportScalarFieldEnum]


  export const RelMatchRefereeScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    refereeId: 'refereeId',
    assignedAt: 'assignedAt',
    confirmedAt: 'confirmedAt',
    cancelledAt: 'cancelledAt',
    status: 'status',
    matchFee: 'matchFee',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelMatchRefereeScalarFieldEnum = (typeof RelMatchRefereeScalarFieldEnum)[keyof typeof RelMatchRefereeScalarFieldEnum]


  export const RelPlayerParentScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    parentId: 'parentId',
    assignedAt: 'assignedAt',
    removedAt: 'removedAt',
    relationship: 'relationship',
    isPrimaryContact: 'isPrimaryContact',
    canPickup: 'canPickup',
    receivesNotifications: 'receivesNotifications',
    occupation: 'occupation',
    employer: 'employer',
    workPhone: 'workPhone',
    status: 'status',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelPlayerParentScalarFieldEnum = (typeof RelPlayerParentScalarFieldEnum)[keyof typeof RelPlayerParentScalarFieldEnum]


  export const RelSponsorClubScalarFieldEnum: {
    id: 'id',
    sponsorId: 'sponsorId',
    clubId: 'clubId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    sponsorshipAmount: 'sponsorshipAmount',
    benefits: 'benefits',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelSponsorClubScalarFieldEnum = (typeof RelSponsorClubScalarFieldEnum)[keyof typeof RelSponsorClubScalarFieldEnum]


  export const RelSponsorLeagueScalarFieldEnum: {
    id: 'id',
    sponsorId: 'sponsorId',
    leagueId: 'leagueId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    sponsorshipAmount: 'sponsorshipAmount',
    benefits: 'benefits',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelSponsorLeagueScalarFieldEnum = (typeof RelSponsorLeagueScalarFieldEnum)[keyof typeof RelSponsorLeagueScalarFieldEnum]


  export const RelSponsorTeamScalarFieldEnum: {
    id: 'id',
    sponsorId: 'sponsorId',
    teamId: 'teamId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    sponsorshipAmount: 'sponsorshipAmount',
    benefits: 'benefits',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelSponsorTeamScalarFieldEnum = (typeof RelSponsorTeamScalarFieldEnum)[keyof typeof RelSponsorTeamScalarFieldEnum]


  export const RelTeamCoachScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    coachId: 'coachId',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    status: 'status',
    coachTypeId: 'coachTypeId',
    salary: 'salary',
    contractStart: 'contractStart',
    contractEnd: 'contractEnd',
    responsibilities: 'responsibilities',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelTeamCoachScalarFieldEnum = (typeof RelTeamCoachScalarFieldEnum)[keyof typeof RelTeamCoachScalarFieldEnum]


  export const RelTeamPlayerScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    playerId: 'playerId',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    status: 'status',
    jerseyNumber: 'jerseyNumber',
    positionId: 'positionId',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelTeamPlayerScalarFieldEnum = (typeof RelTeamPlayerScalarFieldEnum)[keyof typeof RelTeamPlayerScalarFieldEnum]


  export const RelTeamTeamManagerScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    managerId: 'managerId',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    status: 'status',
    managerTypeId: 'managerTypeId',
    salary: 'salary',
    contractStart: 'contractStart',
    contractEnd: 'contractEnd',
    responsibilities: 'responsibilities',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelTeamTeamManagerScalarFieldEnum = (typeof RelTeamTeamManagerScalarFieldEnum)[keyof typeof RelTeamTeamManagerScalarFieldEnum]


  export const SportCoachTypeScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    name: 'name',
    abbr: 'abbr',
    color: 'color',
    note: 'note',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportCoachTypeScalarFieldEnum = (typeof SportCoachTypeScalarFieldEnum)[keyof typeof SportCoachTypeScalarFieldEnum]


  export const SportEventTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    category: 'category',
    evaluationMetric: 'evaluationMetric',
    code: 'code',
    sportId: 'sportId',
    isVisible: 'isVisible',
    note: 'note',
    ord: 'ord',
    score: 'score',
    slot: 'slot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportEventTypeScalarFieldEnum = (typeof SportEventTypeScalarFieldEnum)[keyof typeof SportEventTypeScalarFieldEnum]


  export const SportGamePeriodScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    name: 'name',
    ord: 'ord',
    duration: 'duration',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportGamePeriodScalarFieldEnum = (typeof SportGamePeriodScalarFieldEnum)[keyof typeof SportGamePeriodScalarFieldEnum]


  export const SportManagerTypeScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    name: 'name',
    abbr: 'abbr',
    color: 'color',
    note: 'note',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportManagerTypeScalarFieldEnum = (typeof SportManagerTypeScalarFieldEnum)[keyof typeof SportManagerTypeScalarFieldEnum]


  export const SportPlayerPositionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    sportId: 'sportId',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportPlayerPositionScalarFieldEnum = (typeof SportPlayerPositionScalarFieldEnum)[keyof typeof SportPlayerPositionScalarFieldEnum]


  export const SportRefereeTypeScalarFieldEnum: {
    id: 'id',
    sportId: 'sportId',
    name: 'name',
    abbr: 'abbr',
    color: 'color',
    note: 'note',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SportRefereeTypeScalarFieldEnum = (typeof SportRefereeTypeScalarFieldEnum)[keyof typeof SportRefereeTypeScalarFieldEnum]


  export const SubFeatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    icon: 'icon',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubFeatureScalarFieldEnum = (typeof SubFeatureScalarFieldEnum)[keyof typeof SubFeatureScalarFieldEnum]


  export const SubForTeamScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    planId: 'planId',
    status: 'status',
    startedAt: 'startedAt',
    expiresAt: 'expiresAt',
    autoRenew: 'autoRenew',
    paymentMethod: 'paymentMethod',
    lastPaymentAt: 'lastPaymentAt',
    nextPaymentAt: 'nextPaymentAt',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubForTeamScalarFieldEnum = (typeof SubForTeamScalarFieldEnum)[keyof typeof SubForTeamScalarFieldEnum]


  export const SubForUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    status: 'status',
    startedAt: 'startedAt',
    expiresAt: 'expiresAt',
    autoRenew: 'autoRenew',
    paymentMethod: 'paymentMethod',
    lastPaymentAt: 'lastPaymentAt',
    nextPaymentAt: 'nextPaymentAt',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubForUserScalarFieldEnum = (typeof SubForUserScalarFieldEnum)[keyof typeof SubForUserScalarFieldEnum]


  export const SubPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    planType: 'planType',
    price: 'price',
    isPopular: 'isPopular',
    description: 'description',
    features: 'features',
    maxTeams: 'maxTeams',
    maxPlayers: 'maxPlayers',
    maxCoaches: 'maxCoaches',
    maxReferees: 'maxReferees',
    storageLimitGb: 'storageLimitGb',
    isActive: 'isActive',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubPlanScalarFieldEnum = (typeof SubPlanScalarFieldEnum)[keyof typeof SubPlanScalarFieldEnum]


  export const SubPlanFeatureScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    featureId: 'featureId',
    isIncluded: 'isIncluded',
    notes: 'notes',
    ord: 'ord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubPlanFeatureScalarFieldEnum = (typeof SubPlanFeatureScalarFieldEnum)[keyof typeof SubPlanFeatureScalarFieldEnum]


  export const SysUserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    emailVerifiedAt: 'emailVerifiedAt',
    password: 'password',
    status: 'status',
    personId: 'personId',
    rememberToken: 'rememberToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SysUserScalarFieldEnum = (typeof SysUserScalarFieldEnum)[keyof typeof SysUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const BaseCompetitionOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    description: 'description',
    status: 'status'
  };

  export type BaseCompetitionOrderByRelevanceFieldEnum = (typeof BaseCompetitionOrderByRelevanceFieldEnum)[keyof typeof BaseCompetitionOrderByRelevanceFieldEnum]


  export const BaseCountryOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    code: 'code',
    note: 'note'
  };

  export type BaseCountryOrderByRelevanceFieldEnum = (typeof BaseCountryOrderByRelevanceFieldEnum)[keyof typeof BaseCountryOrderByRelevanceFieldEnum]


  export const BaseFieldOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    note: 'note'
  };

  export type BaseFieldOrderByRelevanceFieldEnum = (typeof BaseFieldOrderByRelevanceFieldEnum)[keyof typeof BaseFieldOrderByRelevanceFieldEnum]


  export const BaseGroupLevelOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    skillLevel: 'skillLevel'
  };

  export type BaseGroupLevelOrderByRelevanceFieldEnum = (typeof BaseGroupLevelOrderByRelevanceFieldEnum)[keyof typeof BaseGroupLevelOrderByRelevanceFieldEnum]


  export const BaseSportOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    note: 'note'
  };

  export type BaseSportOrderByRelevanceFieldEnum = (typeof BaseSportOrderByRelevanceFieldEnum)[keyof typeof BaseSportOrderByRelevanceFieldEnum]


  export const GameEventOrderByRelevanceFieldEnum: {
    venue: 'venue',
    status: 'status'
  };

  export type GameEventOrderByRelevanceFieldEnum = (typeof GameEventOrderByRelevanceFieldEnum)[keyof typeof GameEventOrderByRelevanceFieldEnum]


  export const GameMatcheOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type GameMatcheOrderByRelevanceFieldEnum = (typeof GameMatcheOrderByRelevanceFieldEnum)[keyof typeof GameMatcheOrderByRelevanceFieldEnum]


  export const MatchEventOrderByRelevanceFieldEnum: {
    eventType: 'eventType',
    description: 'description',
    eventData: 'eventData',
    notes: 'notes'
  };

  export type MatchEventOrderByRelevanceFieldEnum = (typeof MatchEventOrderByRelevanceFieldEnum)[keyof typeof MatchEventOrderByRelevanceFieldEnum]


  export const MatchLineupOrderByRelevanceFieldEnum: {
    formation: 'formation',
    lineupData: 'lineupData',
    notes: 'notes'
  };

  export type MatchLineupOrderByRelevanceFieldEnum = (typeof MatchLineupOrderByRelevanceFieldEnum)[keyof typeof MatchLineupOrderByRelevanceFieldEnum]


  export const MatchMediaOrderByRelevanceFieldEnum: {
    mediaType: 'mediaType',
    fileName: 'fileName',
    filePath: 'filePath',
    mimeType: 'mimeType',
    description: 'description',
    category: 'category',
    notes: 'notes'
  };

  export type MatchMediaOrderByRelevanceFieldEnum = (typeof MatchMediaOrderByRelevanceFieldEnum)[keyof typeof MatchMediaOrderByRelevanceFieldEnum]


  export const MatchRosterOrderByRelevanceFieldEnum: {
    position: 'position',
    jerseyNumber: 'jerseyNumber',
    substitutionReason: 'substitutionReason',
    status: 'status',
    notes: 'notes'
  };

  export type MatchRosterOrderByRelevanceFieldEnum = (typeof MatchRosterOrderByRelevanceFieldEnum)[keyof typeof MatchRosterOrderByRelevanceFieldEnum]


  export const MatchStatisticOrderByRelevanceFieldEnum: {
    notes: 'notes'
  };

  export type MatchStatisticOrderByRelevanceFieldEnum = (typeof MatchStatisticOrderByRelevanceFieldEnum)[keyof typeof MatchStatisticOrderByRelevanceFieldEnum]


  export const MemberClubAdminOrderByRelevanceFieldEnum: {
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio'
  };

  export type MemberClubAdminOrderByRelevanceFieldEnum = (typeof MemberClubAdminOrderByRelevanceFieldEnum)[keyof typeof MemberClubAdminOrderByRelevanceFieldEnum]


  export const MemberCoacheOrderByRelevanceFieldEnum: {
    licenseNumber: 'licenseNumber',
    certification: 'certification',
    specialization: 'specialization',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio'
  };

  export type MemberCoacheOrderByRelevanceFieldEnum = (typeof MemberCoacheOrderByRelevanceFieldEnum)[keyof typeof MemberCoacheOrderByRelevanceFieldEnum]


  export const MemberParentOrderByRelevanceFieldEnum: {
    status: 'status',
    notes: 'notes'
  };

  export type MemberParentOrderByRelevanceFieldEnum = (typeof MemberParentOrderByRelevanceFieldEnum)[keyof typeof MemberParentOrderByRelevanceFieldEnum]


  export const MemberPersonOrderByRelevanceFieldEnum: {
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    gender: 'gender',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    photoPath: 'photoPath',
    status: 'status'
  };

  export type MemberPersonOrderByRelevanceFieldEnum = (typeof MemberPersonOrderByRelevanceFieldEnum)[keyof typeof MemberPersonOrderByRelevanceFieldEnum]


  export const MemberPlayerOrderByRelevanceFieldEnum: {
    preferredFoot: 'preferredFoot',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio'
  };

  export type MemberPlayerOrderByRelevanceFieldEnum = (typeof MemberPlayerOrderByRelevanceFieldEnum)[keyof typeof MemberPlayerOrderByRelevanceFieldEnum]


  export const MemberRefereeOrderByRelevanceFieldEnum: {
    licenseNumber: 'licenseNumber',
    licenseLevel: 'licenseLevel',
    certification: 'certification',
    refereeType: 'refereeType',
    specialization: 'specialization',
    languages: 'languages',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio'
  };

  export type MemberRefereeOrderByRelevanceFieldEnum = (typeof MemberRefereeOrderByRelevanceFieldEnum)[keyof typeof MemberRefereeOrderByRelevanceFieldEnum]


  export const MemberSponsorOrderByRelevanceFieldEnum: {
    companyName: 'companyName',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    website: 'website',
    sponsorLevel: 'sponsorLevel',
    benefits: 'benefits',
    logoPath: 'logoPath',
    status: 'status',
    notes: 'notes'
  };

  export type MemberSponsorOrderByRelevanceFieldEnum = (typeof MemberSponsorOrderByRelevanceFieldEnum)[keyof typeof MemberSponsorOrderByRelevanceFieldEnum]


  export const MemberTeamManagerOrderByRelevanceFieldEnum: {
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    bio: 'bio'
  };

  export type MemberTeamManagerOrderByRelevanceFieldEnum = (typeof MemberTeamManagerOrderByRelevanceFieldEnum)[keyof typeof MemberTeamManagerOrderByRelevanceFieldEnum]


  export const OrgClubOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    description: 'description',
    address: 'address',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    status: 'status'
  };

  export type OrgClubOrderByRelevanceFieldEnum = (typeof OrgClubOrderByRelevanceFieldEnum)[keyof typeof OrgClubOrderByRelevanceFieldEnum]


  export const OrgLeagueOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    description: 'description',
    season: 'season',
    subscribeEmail: 'subscribeEmail',
    rules: 'rules',
    status: 'status'
  };

  export type OrgLeagueOrderByRelevanceFieldEnum = (typeof OrgLeagueOrderByRelevanceFieldEnum)[keyof typeof OrgLeagueOrderByRelevanceFieldEnum]


  export const OrgTeamOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    note: 'note',
    ageGroup: 'ageGroup',
    skillLevel: 'skillLevel',
    color1: 'color1',
    color2: 'color2'
  };

  export type OrgTeamOrderByRelevanceFieldEnum = (typeof OrgTeamOrderByRelevanceFieldEnum)[keyof typeof OrgTeamOrderByRelevanceFieldEnum]


  export const PlanGameOrderByRelevanceFieldEnum: {
    gameName: 'gameName',
    uniform: 'uniform',
    status: 'status'
  };

  export type PlanGameOrderByRelevanceFieldEnum = (typeof PlanGameOrderByRelevanceFieldEnum)[keyof typeof PlanGameOrderByRelevanceFieldEnum]


  export const PlanMeetingOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content'
  };

  export type PlanMeetingOrderByRelevanceFieldEnum = (typeof PlanMeetingOrderByRelevanceFieldEnum)[keyof typeof PlanMeetingOrderByRelevanceFieldEnum]


  export const PlanTrainingOrderByRelevanceFieldEnum: {
    trainingContent: 'trainingContent',
    status: 'status'
  };

  export type PlanTrainingOrderByRelevanceFieldEnum = (typeof PlanTrainingOrderByRelevanceFieldEnum)[keyof typeof PlanTrainingOrderByRelevanceFieldEnum]


  export const RelClubClubAdminOrderByRelevanceFieldEnum: {
    status: 'status',
    role: 'role',
    notes: 'notes'
  };

  export type RelClubClubAdminOrderByRelevanceFieldEnum = (typeof RelClubClubAdminOrderByRelevanceFieldEnum)[keyof typeof RelClubClubAdminOrderByRelevanceFieldEnum]


  export const RelCompetitionGroupLevelOrderByRelevanceFieldEnum: {
    notes: 'notes'
  };

  export type RelCompetitionGroupLevelOrderByRelevanceFieldEnum = (typeof RelCompetitionGroupLevelOrderByRelevanceFieldEnum)[keyof typeof RelCompetitionGroupLevelOrderByRelevanceFieldEnum]


  export const RelFieldSportOrderByRelevanceFieldEnum: {
    notes: 'notes'
  };

  export type RelFieldSportOrderByRelevanceFieldEnum = (typeof RelFieldSportOrderByRelevanceFieldEnum)[keyof typeof RelFieldSportOrderByRelevanceFieldEnum]


  export const RelMatchRefereeOrderByRelevanceFieldEnum: {
    status: 'status',
    notes: 'notes'
  };

  export type RelMatchRefereeOrderByRelevanceFieldEnum = (typeof RelMatchRefereeOrderByRelevanceFieldEnum)[keyof typeof RelMatchRefereeOrderByRelevanceFieldEnum]


  export const RelPlayerParentOrderByRelevanceFieldEnum: {
    relationship: 'relationship',
    occupation: 'occupation',
    employer: 'employer',
    workPhone: 'workPhone',
    status: 'status',
    notes: 'notes'
  };

  export type RelPlayerParentOrderByRelevanceFieldEnum = (typeof RelPlayerParentOrderByRelevanceFieldEnum)[keyof typeof RelPlayerParentOrderByRelevanceFieldEnum]


  export const RelSponsorClubOrderByRelevanceFieldEnum: {
    status: 'status',
    benefits: 'benefits',
    notes: 'notes'
  };

  export type RelSponsorClubOrderByRelevanceFieldEnum = (typeof RelSponsorClubOrderByRelevanceFieldEnum)[keyof typeof RelSponsorClubOrderByRelevanceFieldEnum]


  export const RelSponsorLeagueOrderByRelevanceFieldEnum: {
    status: 'status',
    benefits: 'benefits',
    notes: 'notes'
  };

  export type RelSponsorLeagueOrderByRelevanceFieldEnum = (typeof RelSponsorLeagueOrderByRelevanceFieldEnum)[keyof typeof RelSponsorLeagueOrderByRelevanceFieldEnum]


  export const RelSponsorTeamOrderByRelevanceFieldEnum: {
    status: 'status',
    benefits: 'benefits',
    notes: 'notes'
  };

  export type RelSponsorTeamOrderByRelevanceFieldEnum = (typeof RelSponsorTeamOrderByRelevanceFieldEnum)[keyof typeof RelSponsorTeamOrderByRelevanceFieldEnum]


  export const RelTeamCoachOrderByRelevanceFieldEnum: {
    status: 'status',
    responsibilities: 'responsibilities',
    notes: 'notes'
  };

  export type RelTeamCoachOrderByRelevanceFieldEnum = (typeof RelTeamCoachOrderByRelevanceFieldEnum)[keyof typeof RelTeamCoachOrderByRelevanceFieldEnum]


  export const RelTeamPlayerOrderByRelevanceFieldEnum: {
    status: 'status',
    jerseyNumber: 'jerseyNumber',
    notes: 'notes'
  };

  export type RelTeamPlayerOrderByRelevanceFieldEnum = (typeof RelTeamPlayerOrderByRelevanceFieldEnum)[keyof typeof RelTeamPlayerOrderByRelevanceFieldEnum]


  export const RelTeamTeamManagerOrderByRelevanceFieldEnum: {
    status: 'status',
    managerTypeId: 'managerTypeId',
    responsibilities: 'responsibilities',
    notes: 'notes'
  };

  export type RelTeamTeamManagerOrderByRelevanceFieldEnum = (typeof RelTeamTeamManagerOrderByRelevanceFieldEnum)[keyof typeof RelTeamTeamManagerOrderByRelevanceFieldEnum]


  export const SportCoachTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    color: 'color',
    note: 'note'
  };

  export type SportCoachTypeOrderByRelevanceFieldEnum = (typeof SportCoachTypeOrderByRelevanceFieldEnum)[keyof typeof SportCoachTypeOrderByRelevanceFieldEnum]


  export const SportEventTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    code: 'code',
    note: 'note'
  };

  export type SportEventTypeOrderByRelevanceFieldEnum = (typeof SportEventTypeOrderByRelevanceFieldEnum)[keyof typeof SportEventTypeOrderByRelevanceFieldEnum]


  export const SportGamePeriodOrderByRelevanceFieldEnum: {
    name: 'name',
    note: 'note'
  };

  export type SportGamePeriodOrderByRelevanceFieldEnum = (typeof SportGamePeriodOrderByRelevanceFieldEnum)[keyof typeof SportGamePeriodOrderByRelevanceFieldEnum]


  export const SportManagerTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    color: 'color',
    note: 'note'
  };

  export type SportManagerTypeOrderByRelevanceFieldEnum = (typeof SportManagerTypeOrderByRelevanceFieldEnum)[keyof typeof SportManagerTypeOrderByRelevanceFieldEnum]


  export const SportPlayerPositionOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    note: 'note'
  };

  export type SportPlayerPositionOrderByRelevanceFieldEnum = (typeof SportPlayerPositionOrderByRelevanceFieldEnum)[keyof typeof SportPlayerPositionOrderByRelevanceFieldEnum]


  export const SportRefereeTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    abbr: 'abbr',
    color: 'color',
    note: 'note'
  };

  export type SportRefereeTypeOrderByRelevanceFieldEnum = (typeof SportRefereeTypeOrderByRelevanceFieldEnum)[keyof typeof SportRefereeTypeOrderByRelevanceFieldEnum]


  export const SubFeatureOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    category: 'category',
    icon: 'icon'
  };

  export type SubFeatureOrderByRelevanceFieldEnum = (typeof SubFeatureOrderByRelevanceFieldEnum)[keyof typeof SubFeatureOrderByRelevanceFieldEnum]


  export const SubForTeamOrderByRelevanceFieldEnum: {
    status: 'status',
    paymentMethod: 'paymentMethod',
    notes: 'notes'
  };

  export type SubForTeamOrderByRelevanceFieldEnum = (typeof SubForTeamOrderByRelevanceFieldEnum)[keyof typeof SubForTeamOrderByRelevanceFieldEnum]


  export const SubForUserOrderByRelevanceFieldEnum: {
    status: 'status',
    paymentMethod: 'paymentMethod',
    notes: 'notes'
  };

  export type SubForUserOrderByRelevanceFieldEnum = (typeof SubForUserOrderByRelevanceFieldEnum)[keyof typeof SubForUserOrderByRelevanceFieldEnum]


  export const SubPlanOrderByRelevanceFieldEnum: {
    name: 'name',
    planType: 'planType',
    description: 'description',
    features: 'features'
  };

  export type SubPlanOrderByRelevanceFieldEnum = (typeof SubPlanOrderByRelevanceFieldEnum)[keyof typeof SubPlanOrderByRelevanceFieldEnum]


  export const SubPlanFeatureOrderByRelevanceFieldEnum: {
    notes: 'notes'
  };

  export type SubPlanFeatureOrderByRelevanceFieldEnum = (typeof SubPlanFeatureOrderByRelevanceFieldEnum)[keyof typeof SubPlanFeatureOrderByRelevanceFieldEnum]


  export const SysUserOrderByRelevanceFieldEnum: {
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    status: 'status',
    rememberToken: 'rememberToken'
  };

  export type SysUserOrderByRelevanceFieldEnum = (typeof SysUserOrderByRelevanceFieldEnum)[keyof typeof SysUserOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BaseCompetitionWhereInput = {
    AND?: BaseCompetitionWhereInput | BaseCompetitionWhereInput[]
    OR?: BaseCompetitionWhereInput[]
    NOT?: BaseCompetitionWhereInput | BaseCompetitionWhereInput[]
    id?: DecimalFilter<"BaseCompetition"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"BaseCompetition"> | string
    abbr?: StringNullableFilter<"BaseCompetition"> | string | null
    sportId?: DecimalNullableFilter<"BaseCompetition"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"BaseCompetition"> | string | null
    status?: StringFilter<"BaseCompetition"> | string
    startDate?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
    ord?: IntNullableFilter<"BaseCompetition"> | number | null
    createdAt?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
  }

  export type BaseCompetitionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    sportId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: BaseCompetitionOrderByRelevanceInput
  }

  export type BaseCompetitionWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: BaseCompetitionWhereInput | BaseCompetitionWhereInput[]
    OR?: BaseCompetitionWhereInput[]
    NOT?: BaseCompetitionWhereInput | BaseCompetitionWhereInput[]
    name?: StringFilter<"BaseCompetition"> | string
    abbr?: StringNullableFilter<"BaseCompetition"> | string | null
    sportId?: DecimalNullableFilter<"BaseCompetition"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"BaseCompetition"> | string | null
    status?: StringFilter<"BaseCompetition"> | string
    startDate?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
    ord?: IntNullableFilter<"BaseCompetition"> | number | null
    createdAt?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BaseCompetition"> | Date | string | null
  }, "id">

  export type BaseCompetitionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    sportId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BaseCompetitionCountOrderByAggregateInput
    _avg?: BaseCompetitionAvgOrderByAggregateInput
    _max?: BaseCompetitionMaxOrderByAggregateInput
    _min?: BaseCompetitionMinOrderByAggregateInput
    _sum?: BaseCompetitionSumOrderByAggregateInput
  }

  export type BaseCompetitionScalarWhereWithAggregatesInput = {
    AND?: BaseCompetitionScalarWhereWithAggregatesInput | BaseCompetitionScalarWhereWithAggregatesInput[]
    OR?: BaseCompetitionScalarWhereWithAggregatesInput[]
    NOT?: BaseCompetitionScalarWhereWithAggregatesInput | BaseCompetitionScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"BaseCompetition"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"BaseCompetition"> | string
    abbr?: StringNullableWithAggregatesFilter<"BaseCompetition"> | string | null
    sportId?: DecimalNullableWithAggregatesFilter<"BaseCompetition"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"BaseCompetition"> | string | null
    status?: StringWithAggregatesFilter<"BaseCompetition"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"BaseCompetition"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"BaseCompetition"> | Date | string | null
    ord?: IntNullableWithAggregatesFilter<"BaseCompetition"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"BaseCompetition"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BaseCompetition"> | Date | string | null
  }

  export type BaseCountryWhereInput = {
    AND?: BaseCountryWhereInput | BaseCountryWhereInput[]
    OR?: BaseCountryWhereInput[]
    NOT?: BaseCountryWhereInput | BaseCountryWhereInput[]
    id?: IntFilter<"BaseCountry"> | number
    name?: StringFilter<"BaseCountry"> | string
    abbr?: StringNullableFilter<"BaseCountry"> | string | null
    code?: StringNullableFilter<"BaseCountry"> | string | null
    note?: StringNullableFilter<"BaseCountry"> | string | null
    isActive?: BoolFilter<"BaseCountry"> | boolean
    ord?: IntFilter<"BaseCountry"> | number
    createdAt?: DateTimeFilter<"BaseCountry"> | Date | string
    updatedAt?: DateTimeFilter<"BaseCountry"> | Date | string
  }

  export type BaseCountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BaseCountryOrderByRelevanceInput
  }

  export type BaseCountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BaseCountryWhereInput | BaseCountryWhereInput[]
    OR?: BaseCountryWhereInput[]
    NOT?: BaseCountryWhereInput | BaseCountryWhereInput[]
    abbr?: StringNullableFilter<"BaseCountry"> | string | null
    code?: StringNullableFilter<"BaseCountry"> | string | null
    note?: StringNullableFilter<"BaseCountry"> | string | null
    isActive?: BoolFilter<"BaseCountry"> | boolean
    ord?: IntFilter<"BaseCountry"> | number
    createdAt?: DateTimeFilter<"BaseCountry"> | Date | string
    updatedAt?: DateTimeFilter<"BaseCountry"> | Date | string
  }, "id" | "name">

  export type BaseCountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BaseCountryCountOrderByAggregateInput
    _avg?: BaseCountryAvgOrderByAggregateInput
    _max?: BaseCountryMaxOrderByAggregateInput
    _min?: BaseCountryMinOrderByAggregateInput
    _sum?: BaseCountrySumOrderByAggregateInput
  }

  export type BaseCountryScalarWhereWithAggregatesInput = {
    AND?: BaseCountryScalarWhereWithAggregatesInput | BaseCountryScalarWhereWithAggregatesInput[]
    OR?: BaseCountryScalarWhereWithAggregatesInput[]
    NOT?: BaseCountryScalarWhereWithAggregatesInput | BaseCountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BaseCountry"> | number
    name?: StringWithAggregatesFilter<"BaseCountry"> | string
    abbr?: StringNullableWithAggregatesFilter<"BaseCountry"> | string | null
    code?: StringNullableWithAggregatesFilter<"BaseCountry"> | string | null
    note?: StringNullableWithAggregatesFilter<"BaseCountry"> | string | null
    isActive?: BoolWithAggregatesFilter<"BaseCountry"> | boolean
    ord?: IntWithAggregatesFilter<"BaseCountry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BaseCountry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BaseCountry"> | Date | string
  }

  export type BaseFieldWhereInput = {
    AND?: BaseFieldWhereInput | BaseFieldWhereInput[]
    OR?: BaseFieldWhereInput[]
    NOT?: BaseFieldWhereInput | BaseFieldWhereInput[]
    id?: IntFilter<"BaseField"> | number
    name?: StringFilter<"BaseField"> | string
    abbr?: StringNullableFilter<"BaseField"> | string | null
    note?: StringNullableFilter<"BaseField"> | string | null
    isActive?: BoolFilter<"BaseField"> | boolean
    sportIds?: IntNullableListFilter<"BaseField">
    countryId?: IntNullableFilter<"BaseField"> | number | null
    ord?: IntFilter<"BaseField"> | number
    createdAt?: DateTimeFilter<"BaseField"> | Date | string
    updatedAt?: DateTimeFilter<"BaseField"> | Date | string
  }

  export type BaseFieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sportIds?: SortOrder
    countryId?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BaseFieldOrderByRelevanceInput
  }

  export type BaseFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BaseFieldWhereInput | BaseFieldWhereInput[]
    OR?: BaseFieldWhereInput[]
    NOT?: BaseFieldWhereInput | BaseFieldWhereInput[]
    abbr?: StringNullableFilter<"BaseField"> | string | null
    note?: StringNullableFilter<"BaseField"> | string | null
    isActive?: BoolFilter<"BaseField"> | boolean
    sportIds?: IntNullableListFilter<"BaseField">
    countryId?: IntNullableFilter<"BaseField"> | number | null
    ord?: IntFilter<"BaseField"> | number
    createdAt?: DateTimeFilter<"BaseField"> | Date | string
    updatedAt?: DateTimeFilter<"BaseField"> | Date | string
  }, "id" | "name">

  export type BaseFieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sportIds?: SortOrder
    countryId?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BaseFieldCountOrderByAggregateInput
    _avg?: BaseFieldAvgOrderByAggregateInput
    _max?: BaseFieldMaxOrderByAggregateInput
    _min?: BaseFieldMinOrderByAggregateInput
    _sum?: BaseFieldSumOrderByAggregateInput
  }

  export type BaseFieldScalarWhereWithAggregatesInput = {
    AND?: BaseFieldScalarWhereWithAggregatesInput | BaseFieldScalarWhereWithAggregatesInput[]
    OR?: BaseFieldScalarWhereWithAggregatesInput[]
    NOT?: BaseFieldScalarWhereWithAggregatesInput | BaseFieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BaseField"> | number
    name?: StringWithAggregatesFilter<"BaseField"> | string
    abbr?: StringNullableWithAggregatesFilter<"BaseField"> | string | null
    note?: StringNullableWithAggregatesFilter<"BaseField"> | string | null
    isActive?: BoolWithAggregatesFilter<"BaseField"> | boolean
    sportIds?: IntNullableListFilter<"BaseField">
    countryId?: IntNullableWithAggregatesFilter<"BaseField"> | number | null
    ord?: IntWithAggregatesFilter<"BaseField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BaseField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BaseField"> | Date | string
  }

  export type BaseGroupLevelWhereInput = {
    AND?: BaseGroupLevelWhereInput | BaseGroupLevelWhereInput[]
    OR?: BaseGroupLevelWhereInput[]
    NOT?: BaseGroupLevelWhereInput | BaseGroupLevelWhereInput[]
    id?: DecimalFilter<"BaseGroupLevel"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"BaseGroupLevel"> | string
    abbr?: StringNullableFilter<"BaseGroupLevel"> | string | null
    note?: StringNullableFilter<"BaseGroupLevel"> | string | null
    minAge?: IntNullableFilter<"BaseGroupLevel"> | number | null
    maxAge?: IntNullableFilter<"BaseGroupLevel"> | number | null
    skillLevel?: StringNullableFilter<"BaseGroupLevel"> | string | null
    ord?: IntNullableFilter<"BaseGroupLevel"> | number | null
    createdAt?: DateTimeNullableFilter<"BaseGroupLevel"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BaseGroupLevel"> | Date | string | null
  }

  export type BaseGroupLevelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    minAge?: SortOrderInput | SortOrder
    maxAge?: SortOrderInput | SortOrder
    skillLevel?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: BaseGroupLevelOrderByRelevanceInput
  }

  export type BaseGroupLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: BaseGroupLevelWhereInput | BaseGroupLevelWhereInput[]
    OR?: BaseGroupLevelWhereInput[]
    NOT?: BaseGroupLevelWhereInput | BaseGroupLevelWhereInput[]
    name?: StringFilter<"BaseGroupLevel"> | string
    abbr?: StringNullableFilter<"BaseGroupLevel"> | string | null
    note?: StringNullableFilter<"BaseGroupLevel"> | string | null
    minAge?: IntNullableFilter<"BaseGroupLevel"> | number | null
    maxAge?: IntNullableFilter<"BaseGroupLevel"> | number | null
    skillLevel?: StringNullableFilter<"BaseGroupLevel"> | string | null
    ord?: IntNullableFilter<"BaseGroupLevel"> | number | null
    createdAt?: DateTimeNullableFilter<"BaseGroupLevel"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"BaseGroupLevel"> | Date | string | null
  }, "id">

  export type BaseGroupLevelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    minAge?: SortOrderInput | SortOrder
    maxAge?: SortOrderInput | SortOrder
    skillLevel?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BaseGroupLevelCountOrderByAggregateInput
    _avg?: BaseGroupLevelAvgOrderByAggregateInput
    _max?: BaseGroupLevelMaxOrderByAggregateInput
    _min?: BaseGroupLevelMinOrderByAggregateInput
    _sum?: BaseGroupLevelSumOrderByAggregateInput
  }

  export type BaseGroupLevelScalarWhereWithAggregatesInput = {
    AND?: BaseGroupLevelScalarWhereWithAggregatesInput | BaseGroupLevelScalarWhereWithAggregatesInput[]
    OR?: BaseGroupLevelScalarWhereWithAggregatesInput[]
    NOT?: BaseGroupLevelScalarWhereWithAggregatesInput | BaseGroupLevelScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"BaseGroupLevel"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"BaseGroupLevel"> | string
    abbr?: StringNullableWithAggregatesFilter<"BaseGroupLevel"> | string | null
    note?: StringNullableWithAggregatesFilter<"BaseGroupLevel"> | string | null
    minAge?: IntNullableWithAggregatesFilter<"BaseGroupLevel"> | number | null
    maxAge?: IntNullableWithAggregatesFilter<"BaseGroupLevel"> | number | null
    skillLevel?: StringNullableWithAggregatesFilter<"BaseGroupLevel"> | string | null
    ord?: IntNullableWithAggregatesFilter<"BaseGroupLevel"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"BaseGroupLevel"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BaseGroupLevel"> | Date | string | null
  }

  export type BaseSportWhereInput = {
    AND?: BaseSportWhereInput | BaseSportWhereInput[]
    OR?: BaseSportWhereInput[]
    NOT?: BaseSportWhereInput | BaseSportWhereInput[]
    id?: IntFilter<"BaseSport"> | number
    name?: StringFilter<"BaseSport"> | string
    abbr?: StringNullableFilter<"BaseSport"> | string | null
    note?: StringNullableFilter<"BaseSport"> | string | null
    isActive?: BoolFilter<"BaseSport"> | boolean
    ord?: IntFilter<"BaseSport"> | number
    createdAt?: DateTimeFilter<"BaseSport"> | Date | string
    updatedAt?: DateTimeFilter<"BaseSport"> | Date | string
  }

  export type BaseSportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BaseSportOrderByRelevanceInput
  }

  export type BaseSportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BaseSportWhereInput | BaseSportWhereInput[]
    OR?: BaseSportWhereInput[]
    NOT?: BaseSportWhereInput | BaseSportWhereInput[]
    abbr?: StringNullableFilter<"BaseSport"> | string | null
    note?: StringNullableFilter<"BaseSport"> | string | null
    isActive?: BoolFilter<"BaseSport"> | boolean
    ord?: IntFilter<"BaseSport"> | number
    createdAt?: DateTimeFilter<"BaseSport"> | Date | string
    updatedAt?: DateTimeFilter<"BaseSport"> | Date | string
  }, "id" | "name">

  export type BaseSportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BaseSportCountOrderByAggregateInput
    _avg?: BaseSportAvgOrderByAggregateInput
    _max?: BaseSportMaxOrderByAggregateInput
    _min?: BaseSportMinOrderByAggregateInput
    _sum?: BaseSportSumOrderByAggregateInput
  }

  export type BaseSportScalarWhereWithAggregatesInput = {
    AND?: BaseSportScalarWhereWithAggregatesInput | BaseSportScalarWhereWithAggregatesInput[]
    OR?: BaseSportScalarWhereWithAggregatesInput[]
    NOT?: BaseSportScalarWhereWithAggregatesInput | BaseSportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BaseSport"> | number
    name?: StringWithAggregatesFilter<"BaseSport"> | string
    abbr?: StringNullableWithAggregatesFilter<"BaseSport"> | string | null
    note?: StringNullableWithAggregatesFilter<"BaseSport"> | string | null
    isActive?: BoolWithAggregatesFilter<"BaseSport"> | boolean
    ord?: IntWithAggregatesFilter<"BaseSport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BaseSport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BaseSport"> | Date | string
  }

  export type GameEventWhereInput = {
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    id?: DecimalFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalNullableFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeFilter<"GameEvent"> | Date | string
    venue?: StringNullableFilter<"GameEvent"> | string | null
    status?: StringFilter<"GameEvent"> | string
    createdAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
  }

  export type GameEventOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    venue?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: GameEventOrderByRelevanceInput
  }

  export type GameEventWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: GameEventWhereInput | GameEventWhereInput[]
    OR?: GameEventWhereInput[]
    NOT?: GameEventWhereInput | GameEventWhereInput[]
    sportId?: DecimalFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalNullableFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeFilter<"GameEvent"> | Date | string
    venue?: StringNullableFilter<"GameEvent"> | string | null
    status?: StringFilter<"GameEvent"> | string
    createdAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GameEvent"> | Date | string | null
  }, "id">

  export type GameEventOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrderInput | SortOrder
    eventDate?: SortOrder
    venue?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: GameEventCountOrderByAggregateInput
    _avg?: GameEventAvgOrderByAggregateInput
    _max?: GameEventMaxOrderByAggregateInput
    _min?: GameEventMinOrderByAggregateInput
    _sum?: GameEventSumOrderByAggregateInput
  }

  export type GameEventScalarWhereWithAggregatesInput = {
    AND?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    OR?: GameEventScalarWhereWithAggregatesInput[]
    NOT?: GameEventScalarWhereWithAggregatesInput | GameEventScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalWithAggregatesFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalNullableWithAggregatesFilter<"GameEvent"> | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeWithAggregatesFilter<"GameEvent"> | Date | string
    venue?: StringNullableWithAggregatesFilter<"GameEvent"> | string | null
    status?: StringWithAggregatesFilter<"GameEvent"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"GameEvent"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"GameEvent"> | Date | string | null
  }

  export type GameMatcheWhereInput = {
    AND?: GameMatcheWhereInput | GameMatcheWhereInput[]
    OR?: GameMatcheWhereInput[]
    NOT?: GameMatcheWhereInput | GameMatcheWhereInput[]
    id?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    eventId?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    homeTeamScore?: IntNullableFilter<"GameMatche"> | number | null
    awayTeamScore?: IntNullableFilter<"GameMatche"> | number | null
    status?: StringFilter<"GameMatche"> | string
    createdAt?: DateTimeNullableFilter<"GameMatche"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GameMatche"> | Date | string | null
  }

  export type GameMatcheOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrderInput | SortOrder
    awayTeamScore?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: GameMatcheOrderByRelevanceInput
  }

  export type GameMatcheWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: GameMatcheWhereInput | GameMatcheWhereInput[]
    OR?: GameMatcheWhereInput[]
    NOT?: GameMatcheWhereInput | GameMatcheWhereInput[]
    eventId?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    homeTeamScore?: IntNullableFilter<"GameMatche"> | number | null
    awayTeamScore?: IntNullableFilter<"GameMatche"> | number | null
    status?: StringFilter<"GameMatche"> | string
    createdAt?: DateTimeNullableFilter<"GameMatche"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GameMatche"> | Date | string | null
  }, "id">

  export type GameMatcheOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrderInput | SortOrder
    awayTeamScore?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: GameMatcheCountOrderByAggregateInput
    _avg?: GameMatcheAvgOrderByAggregateInput
    _max?: GameMatcheMaxOrderByAggregateInput
    _min?: GameMatcheMinOrderByAggregateInput
    _sum?: GameMatcheSumOrderByAggregateInput
  }

  export type GameMatcheScalarWhereWithAggregatesInput = {
    AND?: GameMatcheScalarWhereWithAggregatesInput | GameMatcheScalarWhereWithAggregatesInput[]
    OR?: GameMatcheScalarWhereWithAggregatesInput[]
    NOT?: GameMatcheScalarWhereWithAggregatesInput | GameMatcheScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    eventId?: DecimalWithAggregatesFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalWithAggregatesFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalWithAggregatesFilter<"GameMatche"> | Decimal | DecimalJsLike | number | string
    homeTeamScore?: IntNullableWithAggregatesFilter<"GameMatche"> | number | null
    awayTeamScore?: IntNullableWithAggregatesFilter<"GameMatche"> | number | null
    status?: StringWithAggregatesFilter<"GameMatche"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"GameMatche"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"GameMatche"> | Date | string | null
  }

  export type MatchEventWhereInput = {
    AND?: MatchEventWhereInput | MatchEventWhereInput[]
    OR?: MatchEventWhereInput[]
    NOT?: MatchEventWhereInput | MatchEventWhereInput[]
    id?: DecimalFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    teamId?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    eventType?: StringFilter<"MatchEvent"> | string
    minute?: IntFilter<"MatchEvent"> | number
    second?: IntFilter<"MatchEvent"> | number
    description?: StringNullableFilter<"MatchEvent"> | string | null
    eventData?: StringNullableFilter<"MatchEvent"> | string | null
    fieldX?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    fieldY?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntFilter<"MatchEvent"> | number
    createdBy?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MatchEvent"> | string | null
    ord?: IntFilter<"MatchEvent"> | number
    createdAt?: DateTimeNullableFilter<"MatchEvent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchEvent"> | Date | string | null
  }

  export type MatchEventOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    description?: SortOrderInput | SortOrder
    eventData?: SortOrderInput | SortOrder
    fieldX?: SortOrderInput | SortOrder
    fieldY?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MatchEventOrderByRelevanceInput
  }

  export type MatchEventWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MatchEventWhereInput | MatchEventWhereInput[]
    OR?: MatchEventWhereInput[]
    NOT?: MatchEventWhereInput | MatchEventWhereInput[]
    matchId?: DecimalFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    teamId?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    eventType?: StringFilter<"MatchEvent"> | string
    minute?: IntFilter<"MatchEvent"> | number
    second?: IntFilter<"MatchEvent"> | number
    description?: StringNullableFilter<"MatchEvent"> | string | null
    eventData?: StringNullableFilter<"MatchEvent"> | string | null
    fieldX?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    fieldY?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntFilter<"MatchEvent"> | number
    createdBy?: DecimalNullableFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MatchEvent"> | string | null
    ord?: IntFilter<"MatchEvent"> | number
    createdAt?: DateTimeNullableFilter<"MatchEvent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchEvent"> | Date | string | null
  }, "id">

  export type MatchEventOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    description?: SortOrderInput | SortOrder
    eventData?: SortOrderInput | SortOrder
    fieldX?: SortOrderInput | SortOrder
    fieldY?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MatchEventCountOrderByAggregateInput
    _avg?: MatchEventAvgOrderByAggregateInput
    _max?: MatchEventMaxOrderByAggregateInput
    _min?: MatchEventMinOrderByAggregateInput
    _sum?: MatchEventSumOrderByAggregateInput
  }

  export type MatchEventScalarWhereWithAggregatesInput = {
    AND?: MatchEventScalarWhereWithAggregatesInput | MatchEventScalarWhereWithAggregatesInput[]
    OR?: MatchEventScalarWhereWithAggregatesInput[]
    NOT?: MatchEventScalarWhereWithAggregatesInput | MatchEventScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalNullableWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    teamId?: DecimalNullableWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    eventType?: StringWithAggregatesFilter<"MatchEvent"> | string
    minute?: IntWithAggregatesFilter<"MatchEvent"> | number
    second?: IntWithAggregatesFilter<"MatchEvent"> | number
    description?: StringNullableWithAggregatesFilter<"MatchEvent"> | string | null
    eventData?: StringNullableWithAggregatesFilter<"MatchEvent"> | string | null
    fieldX?: DecimalNullableWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    fieldY?: DecimalNullableWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntWithAggregatesFilter<"MatchEvent"> | number
    createdBy?: DecimalNullableWithAggregatesFilter<"MatchEvent"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"MatchEvent"> | string | null
    ord?: IntWithAggregatesFilter<"MatchEvent"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MatchEvent"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MatchEvent"> | Date | string | null
  }

  export type MatchLineupWhereInput = {
    AND?: MatchLineupWhereInput | MatchLineupWhereInput[]
    OR?: MatchLineupWhereInput[]
    NOT?: MatchLineupWhereInput | MatchLineupWhereInput[]
    id?: DecimalFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    formation?: StringNullableFilter<"MatchLineup"> | string | null
    lineupData?: StringNullableFilter<"MatchLineup"> | string | null
    announcedAt?: DateTimeNullableFilter<"MatchLineup"> | Date | string | null
    isConfirmed?: IntFilter<"MatchLineup"> | number
    createdBy?: DecimalNullableFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MatchLineup"> | string | null
    ord?: IntFilter<"MatchLineup"> | number
    createdAt?: DateTimeNullableFilter<"MatchLineup"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchLineup"> | Date | string | null
  }

  export type MatchLineupOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    formation?: SortOrderInput | SortOrder
    lineupData?: SortOrderInput | SortOrder
    announcedAt?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MatchLineupOrderByRelevanceInput
  }

  export type MatchLineupWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    matchId_teamId?: MatchLineupMatchIdTeamIdCompoundUniqueInput
    AND?: MatchLineupWhereInput | MatchLineupWhereInput[]
    OR?: MatchLineupWhereInput[]
    NOT?: MatchLineupWhereInput | MatchLineupWhereInput[]
    matchId?: DecimalFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    formation?: StringNullableFilter<"MatchLineup"> | string | null
    lineupData?: StringNullableFilter<"MatchLineup"> | string | null
    announcedAt?: DateTimeNullableFilter<"MatchLineup"> | Date | string | null
    isConfirmed?: IntFilter<"MatchLineup"> | number
    createdBy?: DecimalNullableFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MatchLineup"> | string | null
    ord?: IntFilter<"MatchLineup"> | number
    createdAt?: DateTimeNullableFilter<"MatchLineup"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchLineup"> | Date | string | null
  }, "id" | "matchId_teamId">

  export type MatchLineupOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    formation?: SortOrderInput | SortOrder
    lineupData?: SortOrderInput | SortOrder
    announcedAt?: SortOrderInput | SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MatchLineupCountOrderByAggregateInput
    _avg?: MatchLineupAvgOrderByAggregateInput
    _max?: MatchLineupMaxOrderByAggregateInput
    _min?: MatchLineupMinOrderByAggregateInput
    _sum?: MatchLineupSumOrderByAggregateInput
  }

  export type MatchLineupScalarWhereWithAggregatesInput = {
    AND?: MatchLineupScalarWhereWithAggregatesInput | MatchLineupScalarWhereWithAggregatesInput[]
    OR?: MatchLineupScalarWhereWithAggregatesInput[]
    NOT?: MatchLineupScalarWhereWithAggregatesInput | MatchLineupScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalWithAggregatesFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string
    formation?: StringNullableWithAggregatesFilter<"MatchLineup"> | string | null
    lineupData?: StringNullableWithAggregatesFilter<"MatchLineup"> | string | null
    announcedAt?: DateTimeNullableWithAggregatesFilter<"MatchLineup"> | Date | string | null
    isConfirmed?: IntWithAggregatesFilter<"MatchLineup"> | number
    createdBy?: DecimalNullableWithAggregatesFilter<"MatchLineup"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"MatchLineup"> | string | null
    ord?: IntWithAggregatesFilter<"MatchLineup"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MatchLineup"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MatchLineup"> | Date | string | null
  }

  export type MatchMediaWhereInput = {
    AND?: MatchMediaWhereInput | MatchMediaWhereInput[]
    OR?: MatchMediaWhereInput[]
    NOT?: MatchMediaWhereInput | MatchMediaWhereInput[]
    id?: DecimalFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string
    mediaType?: StringFilter<"MatchMedia"> | string
    fileName?: StringFilter<"MatchMedia"> | string
    filePath?: StringFilter<"MatchMedia"> | string
    fileSize?: BigIntNullableFilter<"MatchMedia"> | bigint | number | null
    mimeType?: StringNullableFilter<"MatchMedia"> | string | null
    description?: StringNullableFilter<"MatchMedia"> | string | null
    category?: StringNullableFilter<"MatchMedia"> | string | null
    isPublic?: IntFilter<"MatchMedia"> | number
    uploadedBy?: DecimalNullableFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeFilter<"MatchMedia"> | Date | string
    notes?: StringNullableFilter<"MatchMedia"> | string | null
    ord?: IntFilter<"MatchMedia"> | number
    createdAt?: DateTimeNullableFilter<"MatchMedia"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchMedia"> | Date | string | null
  }

  export type MatchMediaOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MatchMediaOrderByRelevanceInput
  }

  export type MatchMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MatchMediaWhereInput | MatchMediaWhereInput[]
    OR?: MatchMediaWhereInput[]
    NOT?: MatchMediaWhereInput | MatchMediaWhereInput[]
    matchId?: DecimalFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string
    mediaType?: StringFilter<"MatchMedia"> | string
    fileName?: StringFilter<"MatchMedia"> | string
    filePath?: StringFilter<"MatchMedia"> | string
    fileSize?: BigIntNullableFilter<"MatchMedia"> | bigint | number | null
    mimeType?: StringNullableFilter<"MatchMedia"> | string | null
    description?: StringNullableFilter<"MatchMedia"> | string | null
    category?: StringNullableFilter<"MatchMedia"> | string | null
    isPublic?: IntFilter<"MatchMedia"> | number
    uploadedBy?: DecimalNullableFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeFilter<"MatchMedia"> | Date | string
    notes?: StringNullableFilter<"MatchMedia"> | string | null
    ord?: IntFilter<"MatchMedia"> | number
    createdAt?: DateTimeNullableFilter<"MatchMedia"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchMedia"> | Date | string | null
  }, "id">

  export type MatchMediaOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MatchMediaCountOrderByAggregateInput
    _avg?: MatchMediaAvgOrderByAggregateInput
    _max?: MatchMediaMaxOrderByAggregateInput
    _min?: MatchMediaMinOrderByAggregateInput
    _sum?: MatchMediaSumOrderByAggregateInput
  }

  export type MatchMediaScalarWhereWithAggregatesInput = {
    AND?: MatchMediaScalarWhereWithAggregatesInput | MatchMediaScalarWhereWithAggregatesInput[]
    OR?: MatchMediaScalarWhereWithAggregatesInput[]
    NOT?: MatchMediaScalarWhereWithAggregatesInput | MatchMediaScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalWithAggregatesFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string
    mediaType?: StringWithAggregatesFilter<"MatchMedia"> | string
    fileName?: StringWithAggregatesFilter<"MatchMedia"> | string
    filePath?: StringWithAggregatesFilter<"MatchMedia"> | string
    fileSize?: BigIntNullableWithAggregatesFilter<"MatchMedia"> | bigint | number | null
    mimeType?: StringNullableWithAggregatesFilter<"MatchMedia"> | string | null
    description?: StringNullableWithAggregatesFilter<"MatchMedia"> | string | null
    category?: StringNullableWithAggregatesFilter<"MatchMedia"> | string | null
    isPublic?: IntWithAggregatesFilter<"MatchMedia"> | number
    uploadedBy?: DecimalNullableWithAggregatesFilter<"MatchMedia"> | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"MatchMedia"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"MatchMedia"> | string | null
    ord?: IntWithAggregatesFilter<"MatchMedia"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MatchMedia"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MatchMedia"> | Date | string | null
  }

  export type MatchRosterWhereInput = {
    AND?: MatchRosterWhereInput | MatchRosterWhereInput[]
    OR?: MatchRosterWhereInput[]
    NOT?: MatchRosterWhereInput | MatchRosterWhereInput[]
    id?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    isStarting?: IntFilter<"MatchRoster"> | number
    isSubstitute?: IntFilter<"MatchRoster"> | number
    position?: StringNullableFilter<"MatchRoster"> | string | null
    jerseyNumber?: StringNullableFilter<"MatchRoster"> | string | null
    substitutionInMinute?: IntNullableFilter<"MatchRoster"> | number | null
    substitutionOutMinute?: IntNullableFilter<"MatchRoster"> | number | null
    substitutionReason?: StringNullableFilter<"MatchRoster"> | string | null
    minutesPlayed?: IntNullableFilter<"MatchRoster"> | number | null
    status?: StringFilter<"MatchRoster"> | string
    notes?: StringNullableFilter<"MatchRoster"> | string | null
    ord?: IntFilter<"MatchRoster"> | number
    createdAt?: DateTimeNullableFilter<"MatchRoster"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchRoster"> | Date | string | null
  }

  export type MatchRosterOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    position?: SortOrderInput | SortOrder
    jerseyNumber?: SortOrderInput | SortOrder
    substitutionInMinute?: SortOrderInput | SortOrder
    substitutionOutMinute?: SortOrderInput | SortOrder
    substitutionReason?: SortOrderInput | SortOrder
    minutesPlayed?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MatchRosterOrderByRelevanceInput
  }

  export type MatchRosterWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    matchId_playerId?: MatchRosterMatchIdPlayerIdCompoundUniqueInput
    AND?: MatchRosterWhereInput | MatchRosterWhereInput[]
    OR?: MatchRosterWhereInput[]
    NOT?: MatchRosterWhereInput | MatchRosterWhereInput[]
    matchId?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    isStarting?: IntFilter<"MatchRoster"> | number
    isSubstitute?: IntFilter<"MatchRoster"> | number
    position?: StringNullableFilter<"MatchRoster"> | string | null
    jerseyNumber?: StringNullableFilter<"MatchRoster"> | string | null
    substitutionInMinute?: IntNullableFilter<"MatchRoster"> | number | null
    substitutionOutMinute?: IntNullableFilter<"MatchRoster"> | number | null
    substitutionReason?: StringNullableFilter<"MatchRoster"> | string | null
    minutesPlayed?: IntNullableFilter<"MatchRoster"> | number | null
    status?: StringFilter<"MatchRoster"> | string
    notes?: StringNullableFilter<"MatchRoster"> | string | null
    ord?: IntFilter<"MatchRoster"> | number
    createdAt?: DateTimeNullableFilter<"MatchRoster"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchRoster"> | Date | string | null
  }, "id" | "matchId_playerId">

  export type MatchRosterOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    position?: SortOrderInput | SortOrder
    jerseyNumber?: SortOrderInput | SortOrder
    substitutionInMinute?: SortOrderInput | SortOrder
    substitutionOutMinute?: SortOrderInput | SortOrder
    substitutionReason?: SortOrderInput | SortOrder
    minutesPlayed?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MatchRosterCountOrderByAggregateInput
    _avg?: MatchRosterAvgOrderByAggregateInput
    _max?: MatchRosterMaxOrderByAggregateInput
    _min?: MatchRosterMinOrderByAggregateInput
    _sum?: MatchRosterSumOrderByAggregateInput
  }

  export type MatchRosterScalarWhereWithAggregatesInput = {
    AND?: MatchRosterScalarWhereWithAggregatesInput | MatchRosterScalarWhereWithAggregatesInput[]
    OR?: MatchRosterScalarWhereWithAggregatesInput[]
    NOT?: MatchRosterScalarWhereWithAggregatesInput | MatchRosterScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalWithAggregatesFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalWithAggregatesFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"MatchRoster"> | Decimal | DecimalJsLike | number | string
    isStarting?: IntWithAggregatesFilter<"MatchRoster"> | number
    isSubstitute?: IntWithAggregatesFilter<"MatchRoster"> | number
    position?: StringNullableWithAggregatesFilter<"MatchRoster"> | string | null
    jerseyNumber?: StringNullableWithAggregatesFilter<"MatchRoster"> | string | null
    substitutionInMinute?: IntNullableWithAggregatesFilter<"MatchRoster"> | number | null
    substitutionOutMinute?: IntNullableWithAggregatesFilter<"MatchRoster"> | number | null
    substitutionReason?: StringNullableWithAggregatesFilter<"MatchRoster"> | string | null
    minutesPlayed?: IntNullableWithAggregatesFilter<"MatchRoster"> | number | null
    status?: StringWithAggregatesFilter<"MatchRoster"> | string
    notes?: StringNullableWithAggregatesFilter<"MatchRoster"> | string | null
    ord?: IntWithAggregatesFilter<"MatchRoster"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MatchRoster"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MatchRoster"> | Date | string | null
  }

  export type MatchStatisticWhereInput = {
    AND?: MatchStatisticWhereInput | MatchStatisticWhereInput[]
    OR?: MatchStatisticWhereInput[]
    NOT?: MatchStatisticWhereInput | MatchStatisticWhereInput[]
    id?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntFilter<"MatchStatistic"> | number
    goals?: IntFilter<"MatchStatistic"> | number
    assists?: IntFilter<"MatchStatistic"> | number
    shots?: IntFilter<"MatchStatistic"> | number
    shots_on_target?: IntFilter<"MatchStatistic"> | number
    passes?: IntFilter<"MatchStatistic"> | number
    passesCompleted?: IntFilter<"MatchStatistic"> | number
    passAccuracy?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    tackles?: IntFilter<"MatchStatistic"> | number
    interceptions?: IntFilter<"MatchStatistic"> | number
    clearances?: IntFilter<"MatchStatistic"> | number
    blocks?: IntFilter<"MatchStatistic"> | number
    yellowCards?: IntFilter<"MatchStatistic"> | number
    redCards?: IntFilter<"MatchStatistic"> | number
    foulsCommitted?: IntFilter<"MatchStatistic"> | number
    foulsWon?: IntFilter<"MatchStatistic"> | number
    saves?: IntFilter<"MatchStatistic"> | number
    goalsConceded?: IntFilter<"MatchStatistic"> | number
    cleanSheets?: IntFilter<"MatchStatistic"> | number
    rating?: DecimalNullableFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MatchStatistic"> | string | null
    ord?: IntFilter<"MatchStatistic"> | number
    createdAt?: DateTimeNullableFilter<"MatchStatistic"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchStatistic"> | Date | string | null
  }

  export type MatchStatisticOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MatchStatisticOrderByRelevanceInput
  }

  export type MatchStatisticWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    matchId_playerId?: MatchStatisticMatchIdPlayerIdCompoundUniqueInput
    AND?: MatchStatisticWhereInput | MatchStatisticWhereInput[]
    OR?: MatchStatisticWhereInput[]
    NOT?: MatchStatisticWhereInput | MatchStatisticWhereInput[]
    matchId?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntFilter<"MatchStatistic"> | number
    goals?: IntFilter<"MatchStatistic"> | number
    assists?: IntFilter<"MatchStatistic"> | number
    shots?: IntFilter<"MatchStatistic"> | number
    shots_on_target?: IntFilter<"MatchStatistic"> | number
    passes?: IntFilter<"MatchStatistic"> | number
    passesCompleted?: IntFilter<"MatchStatistic"> | number
    passAccuracy?: DecimalFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    tackles?: IntFilter<"MatchStatistic"> | number
    interceptions?: IntFilter<"MatchStatistic"> | number
    clearances?: IntFilter<"MatchStatistic"> | number
    blocks?: IntFilter<"MatchStatistic"> | number
    yellowCards?: IntFilter<"MatchStatistic"> | number
    redCards?: IntFilter<"MatchStatistic"> | number
    foulsCommitted?: IntFilter<"MatchStatistic"> | number
    foulsWon?: IntFilter<"MatchStatistic"> | number
    saves?: IntFilter<"MatchStatistic"> | number
    goalsConceded?: IntFilter<"MatchStatistic"> | number
    cleanSheets?: IntFilter<"MatchStatistic"> | number
    rating?: DecimalNullableFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"MatchStatistic"> | string | null
    ord?: IntFilter<"MatchStatistic"> | number
    createdAt?: DateTimeNullableFilter<"MatchStatistic"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MatchStatistic"> | Date | string | null
  }, "id" | "matchId_playerId">

  export type MatchStatisticOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MatchStatisticCountOrderByAggregateInput
    _avg?: MatchStatisticAvgOrderByAggregateInput
    _max?: MatchStatisticMaxOrderByAggregateInput
    _min?: MatchStatisticMinOrderByAggregateInput
    _sum?: MatchStatisticSumOrderByAggregateInput
  }

  export type MatchStatisticScalarWhereWithAggregatesInput = {
    AND?: MatchStatisticScalarWhereWithAggregatesInput | MatchStatisticScalarWhereWithAggregatesInput[]
    OR?: MatchStatisticScalarWhereWithAggregatesInput[]
    NOT?: MatchStatisticScalarWhereWithAggregatesInput | MatchStatisticScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalWithAggregatesFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalWithAggregatesFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntWithAggregatesFilter<"MatchStatistic"> | number
    goals?: IntWithAggregatesFilter<"MatchStatistic"> | number
    assists?: IntWithAggregatesFilter<"MatchStatistic"> | number
    shots?: IntWithAggregatesFilter<"MatchStatistic"> | number
    shots_on_target?: IntWithAggregatesFilter<"MatchStatistic"> | number
    passes?: IntWithAggregatesFilter<"MatchStatistic"> | number
    passesCompleted?: IntWithAggregatesFilter<"MatchStatistic"> | number
    passAccuracy?: DecimalWithAggregatesFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string
    tackles?: IntWithAggregatesFilter<"MatchStatistic"> | number
    interceptions?: IntWithAggregatesFilter<"MatchStatistic"> | number
    clearances?: IntWithAggregatesFilter<"MatchStatistic"> | number
    blocks?: IntWithAggregatesFilter<"MatchStatistic"> | number
    yellowCards?: IntWithAggregatesFilter<"MatchStatistic"> | number
    redCards?: IntWithAggregatesFilter<"MatchStatistic"> | number
    foulsCommitted?: IntWithAggregatesFilter<"MatchStatistic"> | number
    foulsWon?: IntWithAggregatesFilter<"MatchStatistic"> | number
    saves?: IntWithAggregatesFilter<"MatchStatistic"> | number
    goalsConceded?: IntWithAggregatesFilter<"MatchStatistic"> | number
    cleanSheets?: IntWithAggregatesFilter<"MatchStatistic"> | number
    rating?: DecimalNullableWithAggregatesFilter<"MatchStatistic"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"MatchStatistic"> | string | null
    ord?: IntWithAggregatesFilter<"MatchStatistic"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MatchStatistic"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MatchStatistic"> | Date | string | null
  }

  export type MemberClubAdminWhereInput = {
    AND?: MemberClubAdminWhereInput | MemberClubAdminWhereInput[]
    OR?: MemberClubAdminWhereInput[]
    NOT?: MemberClubAdminWhereInput | MemberClubAdminWhereInput[]
    id?: DecimalFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    emergencyContactName?: StringNullableFilter<"MemberClubAdmin"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberClubAdmin"> | string | null
    status?: StringFilter<"MemberClubAdmin"> | string
    bio?: StringNullableFilter<"MemberClubAdmin"> | string | null
    ord?: IntFilter<"MemberClubAdmin"> | number
    createdAt?: DateTimeNullableFilter<"MemberClubAdmin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberClubAdmin"> | Date | string | null
  }

  export type MemberClubAdminOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberClubAdminOrderByRelevanceInput
  }

  export type MemberClubAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MemberClubAdminWhereInput | MemberClubAdminWhereInput[]
    OR?: MemberClubAdminWhereInput[]
    NOT?: MemberClubAdminWhereInput | MemberClubAdminWhereInput[]
    personId?: DecimalFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    emergencyContactName?: StringNullableFilter<"MemberClubAdmin"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberClubAdmin"> | string | null
    status?: StringFilter<"MemberClubAdmin"> | string
    bio?: StringNullableFilter<"MemberClubAdmin"> | string | null
    ord?: IntFilter<"MemberClubAdmin"> | number
    createdAt?: DateTimeNullableFilter<"MemberClubAdmin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberClubAdmin"> | Date | string | null
  }, "id">

  export type MemberClubAdminOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberClubAdminCountOrderByAggregateInput
    _avg?: MemberClubAdminAvgOrderByAggregateInput
    _max?: MemberClubAdminMaxOrderByAggregateInput
    _min?: MemberClubAdminMinOrderByAggregateInput
    _sum?: MemberClubAdminSumOrderByAggregateInput
  }

  export type MemberClubAdminScalarWhereWithAggregatesInput = {
    AND?: MemberClubAdminScalarWhereWithAggregatesInput | MemberClubAdminScalarWhereWithAggregatesInput[]
    OR?: MemberClubAdminScalarWhereWithAggregatesInput[]
    NOT?: MemberClubAdminScalarWhereWithAggregatesInput | MemberClubAdminScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalWithAggregatesFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalWithAggregatesFilter<"MemberClubAdmin"> | Decimal | DecimalJsLike | number | string
    emergencyContactName?: StringNullableWithAggregatesFilter<"MemberClubAdmin"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"MemberClubAdmin"> | string | null
    status?: StringWithAggregatesFilter<"MemberClubAdmin"> | string
    bio?: StringNullableWithAggregatesFilter<"MemberClubAdmin"> | string | null
    ord?: IntWithAggregatesFilter<"MemberClubAdmin"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberClubAdmin"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberClubAdmin"> | Date | string | null
  }

  export type MemberCoacheWhereInput = {
    AND?: MemberCoacheWhereInput | MemberCoacheWhereInput[]
    OR?: MemberCoacheWhereInput[]
    NOT?: MemberCoacheWhereInput | MemberCoacheWhereInput[]
    id?: DecimalFilter<"MemberCoache"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalFilter<"MemberCoache"> | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringNullableFilter<"MemberCoache"> | string | null
    certification?: StringNullableFilter<"MemberCoache"> | string | null
    specialization?: StringNullableFilter<"MemberCoache"> | string | null
    emergencyContactName?: StringNullableFilter<"MemberCoache"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberCoache"> | string | null
    status?: StringFilter<"MemberCoache"> | string
    bio?: StringNullableFilter<"MemberCoache"> | string | null
    ord?: IntNullableFilter<"MemberCoache"> | number | null
    createdAt?: DateTimeNullableFilter<"MemberCoache"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberCoache"> | Date | string | null
  }

  export type MemberCoacheOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    certification?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberCoacheOrderByRelevanceInput
  }

  export type MemberCoacheWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MemberCoacheWhereInput | MemberCoacheWhereInput[]
    OR?: MemberCoacheWhereInput[]
    NOT?: MemberCoacheWhereInput | MemberCoacheWhereInput[]
    personId?: DecimalFilter<"MemberCoache"> | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringNullableFilter<"MemberCoache"> | string | null
    certification?: StringNullableFilter<"MemberCoache"> | string | null
    specialization?: StringNullableFilter<"MemberCoache"> | string | null
    emergencyContactName?: StringNullableFilter<"MemberCoache"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberCoache"> | string | null
    status?: StringFilter<"MemberCoache"> | string
    bio?: StringNullableFilter<"MemberCoache"> | string | null
    ord?: IntNullableFilter<"MemberCoache"> | number | null
    createdAt?: DateTimeNullableFilter<"MemberCoache"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberCoache"> | Date | string | null
  }, "id">

  export type MemberCoacheOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    certification?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberCoacheCountOrderByAggregateInput
    _avg?: MemberCoacheAvgOrderByAggregateInput
    _max?: MemberCoacheMaxOrderByAggregateInput
    _min?: MemberCoacheMinOrderByAggregateInput
    _sum?: MemberCoacheSumOrderByAggregateInput
  }

  export type MemberCoacheScalarWhereWithAggregatesInput = {
    AND?: MemberCoacheScalarWhereWithAggregatesInput | MemberCoacheScalarWhereWithAggregatesInput[]
    OR?: MemberCoacheScalarWhereWithAggregatesInput[]
    NOT?: MemberCoacheScalarWhereWithAggregatesInput | MemberCoacheScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberCoache"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalWithAggregatesFilter<"MemberCoache"> | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringNullableWithAggregatesFilter<"MemberCoache"> | string | null
    certification?: StringNullableWithAggregatesFilter<"MemberCoache"> | string | null
    specialization?: StringNullableWithAggregatesFilter<"MemberCoache"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"MemberCoache"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"MemberCoache"> | string | null
    status?: StringWithAggregatesFilter<"MemberCoache"> | string
    bio?: StringNullableWithAggregatesFilter<"MemberCoache"> | string | null
    ord?: IntNullableWithAggregatesFilter<"MemberCoache"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberCoache"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberCoache"> | Date | string | null
  }

  export type MemberParentWhereInput = {
    AND?: MemberParentWhereInput | MemberParentWhereInput[]
    OR?: MemberParentWhereInput[]
    NOT?: MemberParentWhereInput | MemberParentWhereInput[]
    id?: DecimalFilter<"MemberParent"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalFilter<"MemberParent"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"MemberParent"> | string
    notes?: StringNullableFilter<"MemberParent"> | string | null
    ord?: IntFilter<"MemberParent"> | number
    createdAt?: DateTimeNullableFilter<"MemberParent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberParent"> | Date | string | null
  }

  export type MemberParentOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberParentOrderByRelevanceInput
  }

  export type MemberParentWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MemberParentWhereInput | MemberParentWhereInput[]
    OR?: MemberParentWhereInput[]
    NOT?: MemberParentWhereInput | MemberParentWhereInput[]
    personId?: DecimalFilter<"MemberParent"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"MemberParent"> | string
    notes?: StringNullableFilter<"MemberParent"> | string | null
    ord?: IntFilter<"MemberParent"> | number
    createdAt?: DateTimeNullableFilter<"MemberParent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberParent"> | Date | string | null
  }, "id">

  export type MemberParentOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberParentCountOrderByAggregateInput
    _avg?: MemberParentAvgOrderByAggregateInput
    _max?: MemberParentMaxOrderByAggregateInput
    _min?: MemberParentMinOrderByAggregateInput
    _sum?: MemberParentSumOrderByAggregateInput
  }

  export type MemberParentScalarWhereWithAggregatesInput = {
    AND?: MemberParentScalarWhereWithAggregatesInput | MemberParentScalarWhereWithAggregatesInput[]
    OR?: MemberParentScalarWhereWithAggregatesInput[]
    NOT?: MemberParentScalarWhereWithAggregatesInput | MemberParentScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberParent"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalWithAggregatesFilter<"MemberParent"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"MemberParent"> | string
    notes?: StringNullableWithAggregatesFilter<"MemberParent"> | string | null
    ord?: IntWithAggregatesFilter<"MemberParent"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberParent"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberParent"> | Date | string | null
  }

  export type MemberPersonWhereInput = {
    AND?: MemberPersonWhereInput | MemberPersonWhereInput[]
    OR?: MemberPersonWhereInput[]
    NOT?: MemberPersonWhereInput | MemberPersonWhereInput[]
    id?: DecimalFilter<"MemberPerson"> | Decimal | DecimalJsLike | number | string
    firstName?: StringFilter<"MemberPerson"> | string
    lastName?: StringFilter<"MemberPerson"> | string
    email?: StringNullableFilter<"MemberPerson"> | string | null
    phone?: StringNullableFilter<"MemberPerson"> | string | null
    dob?: DateTimeNullableFilter<"MemberPerson"> | Date | string | null
    gender?: StringNullableFilter<"MemberPerson"> | string | null
    address?: StringNullableFilter<"MemberPerson"> | string | null
    city?: StringNullableFilter<"MemberPerson"> | string | null
    state?: StringNullableFilter<"MemberPerson"> | string | null
    zipCode?: StringNullableFilter<"MemberPerson"> | string | null
    countryId?: DecimalNullableFilter<"MemberPerson"> | Decimal | DecimalJsLike | number | string | null
    photoPath?: StringNullableFilter<"MemberPerson"> | string | null
    status?: StringFilter<"MemberPerson"> | string
    createdAt?: DateTimeNullableFilter<"MemberPerson"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberPerson"> | Date | string | null
  }

  export type MemberPersonOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    countryId?: SortOrderInput | SortOrder
    photoPath?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberPersonOrderByRelevanceInput
  }

  export type MemberPersonWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    email?: string
    AND?: MemberPersonWhereInput | MemberPersonWhereInput[]
    OR?: MemberPersonWhereInput[]
    NOT?: MemberPersonWhereInput | MemberPersonWhereInput[]
    firstName?: StringFilter<"MemberPerson"> | string
    lastName?: StringFilter<"MemberPerson"> | string
    phone?: StringNullableFilter<"MemberPerson"> | string | null
    dob?: DateTimeNullableFilter<"MemberPerson"> | Date | string | null
    gender?: StringNullableFilter<"MemberPerson"> | string | null
    address?: StringNullableFilter<"MemberPerson"> | string | null
    city?: StringNullableFilter<"MemberPerson"> | string | null
    state?: StringNullableFilter<"MemberPerson"> | string | null
    zipCode?: StringNullableFilter<"MemberPerson"> | string | null
    countryId?: DecimalNullableFilter<"MemberPerson"> | Decimal | DecimalJsLike | number | string | null
    photoPath?: StringNullableFilter<"MemberPerson"> | string | null
    status?: StringFilter<"MemberPerson"> | string
    createdAt?: DateTimeNullableFilter<"MemberPerson"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberPerson"> | Date | string | null
  }, "id" | "email">

  export type MemberPersonOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    countryId?: SortOrderInput | SortOrder
    photoPath?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberPersonCountOrderByAggregateInput
    _avg?: MemberPersonAvgOrderByAggregateInput
    _max?: MemberPersonMaxOrderByAggregateInput
    _min?: MemberPersonMinOrderByAggregateInput
    _sum?: MemberPersonSumOrderByAggregateInput
  }

  export type MemberPersonScalarWhereWithAggregatesInput = {
    AND?: MemberPersonScalarWhereWithAggregatesInput | MemberPersonScalarWhereWithAggregatesInput[]
    OR?: MemberPersonScalarWhereWithAggregatesInput[]
    NOT?: MemberPersonScalarWhereWithAggregatesInput | MemberPersonScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberPerson"> | Decimal | DecimalJsLike | number | string
    firstName?: StringWithAggregatesFilter<"MemberPerson"> | string
    lastName?: StringWithAggregatesFilter<"MemberPerson"> | string
    email?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    phone?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"MemberPerson"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    address?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    city?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    state?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    countryId?: DecimalNullableWithAggregatesFilter<"MemberPerson"> | Decimal | DecimalJsLike | number | string | null
    photoPath?: StringNullableWithAggregatesFilter<"MemberPerson"> | string | null
    status?: StringWithAggregatesFilter<"MemberPerson"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberPerson"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberPerson"> | Date | string | null
  }

  export type MemberPlayerWhereInput = {
    AND?: MemberPlayerWhereInput | MemberPlayerWhereInput[]
    OR?: MemberPlayerWhereInput[]
    NOT?: MemberPlayerWhereInput | MemberPlayerWhereInput[]
    id?: DecimalFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string
    height?: DecimalNullableFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: StringNullableFilter<"MemberPlayer"> | string | null
    contractStart?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
    emergencyContactName?: StringNullableFilter<"MemberPlayer"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberPlayer"> | string | null
    status?: StringFilter<"MemberPlayer"> | string
    bio?: StringNullableFilter<"MemberPlayer"> | string | null
    ord?: IntFilter<"MemberPlayer"> | number
    createdAt?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
  }

  export type MemberPlayerOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    preferredFoot?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberPlayerOrderByRelevanceInput
  }

  export type MemberPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MemberPlayerWhereInput | MemberPlayerWhereInput[]
    OR?: MemberPlayerWhereInput[]
    NOT?: MemberPlayerWhereInput | MemberPlayerWhereInput[]
    personId?: DecimalFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string
    height?: DecimalNullableFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: StringNullableFilter<"MemberPlayer"> | string | null
    contractStart?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
    emergencyContactName?: StringNullableFilter<"MemberPlayer"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberPlayer"> | string | null
    status?: StringFilter<"MemberPlayer"> | string
    bio?: StringNullableFilter<"MemberPlayer"> | string | null
    ord?: IntFilter<"MemberPlayer"> | number
    createdAt?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberPlayer"> | Date | string | null
  }, "id">

  export type MemberPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    preferredFoot?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberPlayerCountOrderByAggregateInput
    _avg?: MemberPlayerAvgOrderByAggregateInput
    _max?: MemberPlayerMaxOrderByAggregateInput
    _min?: MemberPlayerMinOrderByAggregateInput
    _sum?: MemberPlayerSumOrderByAggregateInput
  }

  export type MemberPlayerScalarWhereWithAggregatesInput = {
    AND?: MemberPlayerScalarWhereWithAggregatesInput | MemberPlayerScalarWhereWithAggregatesInput[]
    OR?: MemberPlayerScalarWhereWithAggregatesInput[]
    NOT?: MemberPlayerScalarWhereWithAggregatesInput | MemberPlayerScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalWithAggregatesFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string
    height?: DecimalNullableWithAggregatesFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string | null
    weight?: DecimalNullableWithAggregatesFilter<"MemberPlayer"> | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: StringNullableWithAggregatesFilter<"MemberPlayer"> | string | null
    contractStart?: DateTimeNullableWithAggregatesFilter<"MemberPlayer"> | Date | string | null
    contractEnd?: DateTimeNullableWithAggregatesFilter<"MemberPlayer"> | Date | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"MemberPlayer"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"MemberPlayer"> | string | null
    status?: StringWithAggregatesFilter<"MemberPlayer"> | string
    bio?: StringNullableWithAggregatesFilter<"MemberPlayer"> | string | null
    ord?: IntWithAggregatesFilter<"MemberPlayer"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberPlayer"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberPlayer"> | Date | string | null
  }

  export type MemberRefereeWhereInput = {
    AND?: MemberRefereeWhereInput | MemberRefereeWhereInput[]
    OR?: MemberRefereeWhereInput[]
    NOT?: MemberRefereeWhereInput | MemberRefereeWhereInput[]
    id?: DecimalFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringFilter<"MemberReferee"> | string
    licenseLevel?: StringNullableFilter<"MemberReferee"> | string | null
    certification?: StringNullableFilter<"MemberReferee"> | string | null
    refereeType?: StringFilter<"MemberReferee"> | string
    specialization?: StringNullableFilter<"MemberReferee"> | string | null
    languages?: StringNullableFilter<"MemberReferee"> | string | null
    matchFee?: DecimalNullableFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableFilter<"MemberReferee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberReferee"> | string | null
    status?: StringFilter<"MemberReferee"> | string
    bio?: StringNullableFilter<"MemberReferee"> | string | null
    ord?: IntFilter<"MemberReferee"> | number
    createdAt?: DateTimeNullableFilter<"MemberReferee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberReferee"> | Date | string | null
  }

  export type MemberRefereeOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    licenseLevel?: SortOrderInput | SortOrder
    certification?: SortOrderInput | SortOrder
    refereeType?: SortOrder
    specialization?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    matchFee?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberRefereeOrderByRelevanceInput
  }

  export type MemberRefereeWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    licenseNumber?: string
    AND?: MemberRefereeWhereInput | MemberRefereeWhereInput[]
    OR?: MemberRefereeWhereInput[]
    NOT?: MemberRefereeWhereInput | MemberRefereeWhereInput[]
    personId?: DecimalFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string
    licenseLevel?: StringNullableFilter<"MemberReferee"> | string | null
    certification?: StringNullableFilter<"MemberReferee"> | string | null
    refereeType?: StringFilter<"MemberReferee"> | string
    specialization?: StringNullableFilter<"MemberReferee"> | string | null
    languages?: StringNullableFilter<"MemberReferee"> | string | null
    matchFee?: DecimalNullableFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableFilter<"MemberReferee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberReferee"> | string | null
    status?: StringFilter<"MemberReferee"> | string
    bio?: StringNullableFilter<"MemberReferee"> | string | null
    ord?: IntFilter<"MemberReferee"> | number
    createdAt?: DateTimeNullableFilter<"MemberReferee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberReferee"> | Date | string | null
  }, "id" | "licenseNumber">

  export type MemberRefereeOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    licenseLevel?: SortOrderInput | SortOrder
    certification?: SortOrderInput | SortOrder
    refereeType?: SortOrder
    specialization?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    matchFee?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberRefereeCountOrderByAggregateInput
    _avg?: MemberRefereeAvgOrderByAggregateInput
    _max?: MemberRefereeMaxOrderByAggregateInput
    _min?: MemberRefereeMinOrderByAggregateInput
    _sum?: MemberRefereeSumOrderByAggregateInput
  }

  export type MemberRefereeScalarWhereWithAggregatesInput = {
    AND?: MemberRefereeScalarWhereWithAggregatesInput | MemberRefereeScalarWhereWithAggregatesInput[]
    OR?: MemberRefereeScalarWhereWithAggregatesInput[]
    NOT?: MemberRefereeScalarWhereWithAggregatesInput | MemberRefereeScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalWithAggregatesFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringWithAggregatesFilter<"MemberReferee"> | string
    licenseLevel?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    certification?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    refereeType?: StringWithAggregatesFilter<"MemberReferee"> | string
    specialization?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    languages?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    matchFee?: DecimalNullableWithAggregatesFilter<"MemberReferee"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    status?: StringWithAggregatesFilter<"MemberReferee"> | string
    bio?: StringNullableWithAggregatesFilter<"MemberReferee"> | string | null
    ord?: IntWithAggregatesFilter<"MemberReferee"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberReferee"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberReferee"> | Date | string | null
  }

  export type MemberSponsorWhereInput = {
    AND?: MemberSponsorWhereInput | MemberSponsorWhereInput[]
    OR?: MemberSponsorWhereInput[]
    NOT?: MemberSponsorWhereInput | MemberSponsorWhereInput[]
    id?: DecimalFilter<"MemberSponsor"> | Decimal | DecimalJsLike | number | string
    companyName?: StringFilter<"MemberSponsor"> | string
    contactPerson?: StringNullableFilter<"MemberSponsor"> | string | null
    email?: StringNullableFilter<"MemberSponsor"> | string | null
    phone?: StringNullableFilter<"MemberSponsor"> | string | null
    website?: StringNullableFilter<"MemberSponsor"> | string | null
    sponsorLevel?: StringNullableFilter<"MemberSponsor"> | string | null
    sponsorshipAmount?: DecimalNullableFilter<"MemberSponsor"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
    benefits?: StringNullableFilter<"MemberSponsor"> | string | null
    logoPath?: StringNullableFilter<"MemberSponsor"> | string | null
    status?: StringFilter<"MemberSponsor"> | string
    notes?: StringNullableFilter<"MemberSponsor"> | string | null
    ord?: IntFilter<"MemberSponsor"> | number
    createdAt?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
  }

  export type MemberSponsorOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    sponsorLevel?: SortOrderInput | SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    logoPath?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberSponsorOrderByRelevanceInput
  }

  export type MemberSponsorWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MemberSponsorWhereInput | MemberSponsorWhereInput[]
    OR?: MemberSponsorWhereInput[]
    NOT?: MemberSponsorWhereInput | MemberSponsorWhereInput[]
    companyName?: StringFilter<"MemberSponsor"> | string
    contactPerson?: StringNullableFilter<"MemberSponsor"> | string | null
    email?: StringNullableFilter<"MemberSponsor"> | string | null
    phone?: StringNullableFilter<"MemberSponsor"> | string | null
    website?: StringNullableFilter<"MemberSponsor"> | string | null
    sponsorLevel?: StringNullableFilter<"MemberSponsor"> | string | null
    sponsorshipAmount?: DecimalNullableFilter<"MemberSponsor"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
    benefits?: StringNullableFilter<"MemberSponsor"> | string | null
    logoPath?: StringNullableFilter<"MemberSponsor"> | string | null
    status?: StringFilter<"MemberSponsor"> | string
    notes?: StringNullableFilter<"MemberSponsor"> | string | null
    ord?: IntFilter<"MemberSponsor"> | number
    createdAt?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberSponsor"> | Date | string | null
  }, "id">

  export type MemberSponsorOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    sponsorLevel?: SortOrderInput | SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    logoPath?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberSponsorCountOrderByAggregateInput
    _avg?: MemberSponsorAvgOrderByAggregateInput
    _max?: MemberSponsorMaxOrderByAggregateInput
    _min?: MemberSponsorMinOrderByAggregateInput
    _sum?: MemberSponsorSumOrderByAggregateInput
  }

  export type MemberSponsorScalarWhereWithAggregatesInput = {
    AND?: MemberSponsorScalarWhereWithAggregatesInput | MemberSponsorScalarWhereWithAggregatesInput[]
    OR?: MemberSponsorScalarWhereWithAggregatesInput[]
    NOT?: MemberSponsorScalarWhereWithAggregatesInput | MemberSponsorScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberSponsor"> | Decimal | DecimalJsLike | number | string
    companyName?: StringWithAggregatesFilter<"MemberSponsor"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    email?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    website?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    sponsorLevel?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    sponsorshipAmount?: DecimalNullableWithAggregatesFilter<"MemberSponsor"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableWithAggregatesFilter<"MemberSponsor"> | Date | string | null
    contractEnd?: DateTimeNullableWithAggregatesFilter<"MemberSponsor"> | Date | string | null
    benefits?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    logoPath?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    status?: StringWithAggregatesFilter<"MemberSponsor"> | string
    notes?: StringNullableWithAggregatesFilter<"MemberSponsor"> | string | null
    ord?: IntWithAggregatesFilter<"MemberSponsor"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberSponsor"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberSponsor"> | Date | string | null
  }

  export type MemberTeamManagerWhereInput = {
    AND?: MemberTeamManagerWhereInput | MemberTeamManagerWhereInput[]
    OR?: MemberTeamManagerWhereInput[]
    NOT?: MemberTeamManagerWhereInput | MemberTeamManagerWhereInput[]
    id?: DecimalFilter<"MemberTeamManager"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalFilter<"MemberTeamManager"> | Decimal | DecimalJsLike | number | string
    appointedDate?: DateTimeNullableFilter<"MemberTeamManager"> | Date | string | null
    emergencyContactName?: StringNullableFilter<"MemberTeamManager"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberTeamManager"> | string | null
    status?: StringFilter<"MemberTeamManager"> | string
    bio?: StringNullableFilter<"MemberTeamManager"> | string | null
    ord?: IntFilter<"MemberTeamManager"> | number
    createdAt?: DateTimeNullableFilter<"MemberTeamManager"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberTeamManager"> | Date | string | null
  }

  export type MemberTeamManagerOrderByWithRelationInput = {
    id?: SortOrder
    personId?: SortOrder
    appointedDate?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: MemberTeamManagerOrderByRelevanceInput
  }

  export type MemberTeamManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: MemberTeamManagerWhereInput | MemberTeamManagerWhereInput[]
    OR?: MemberTeamManagerWhereInput[]
    NOT?: MemberTeamManagerWhereInput | MemberTeamManagerWhereInput[]
    personId?: DecimalFilter<"MemberTeamManager"> | Decimal | DecimalJsLike | number | string
    appointedDate?: DateTimeNullableFilter<"MemberTeamManager"> | Date | string | null
    emergencyContactName?: StringNullableFilter<"MemberTeamManager"> | string | null
    emergencyContactPhone?: StringNullableFilter<"MemberTeamManager"> | string | null
    status?: StringFilter<"MemberTeamManager"> | string
    bio?: StringNullableFilter<"MemberTeamManager"> | string | null
    ord?: IntFilter<"MemberTeamManager"> | number
    createdAt?: DateTimeNullableFilter<"MemberTeamManager"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"MemberTeamManager"> | Date | string | null
  }, "id">

  export type MemberTeamManagerOrderByWithAggregationInput = {
    id?: SortOrder
    personId?: SortOrder
    appointedDate?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    bio?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberTeamManagerCountOrderByAggregateInput
    _avg?: MemberTeamManagerAvgOrderByAggregateInput
    _max?: MemberTeamManagerMaxOrderByAggregateInput
    _min?: MemberTeamManagerMinOrderByAggregateInput
    _sum?: MemberTeamManagerSumOrderByAggregateInput
  }

  export type MemberTeamManagerScalarWhereWithAggregatesInput = {
    AND?: MemberTeamManagerScalarWhereWithAggregatesInput | MemberTeamManagerScalarWhereWithAggregatesInput[]
    OR?: MemberTeamManagerScalarWhereWithAggregatesInput[]
    NOT?: MemberTeamManagerScalarWhereWithAggregatesInput | MemberTeamManagerScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"MemberTeamManager"> | Decimal | DecimalJsLike | number | string
    personId?: DecimalWithAggregatesFilter<"MemberTeamManager"> | Decimal | DecimalJsLike | number | string
    appointedDate?: DateTimeNullableWithAggregatesFilter<"MemberTeamManager"> | Date | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"MemberTeamManager"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"MemberTeamManager"> | string | null
    status?: StringWithAggregatesFilter<"MemberTeamManager"> | string
    bio?: StringNullableWithAggregatesFilter<"MemberTeamManager"> | string | null
    ord?: IntWithAggregatesFilter<"MemberTeamManager"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"MemberTeamManager"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberTeamManager"> | Date | string | null
  }

  export type OrgClubWhereInput = {
    AND?: OrgClubWhereInput | OrgClubWhereInput[]
    OR?: OrgClubWhereInput[]
    NOT?: OrgClubWhereInput | OrgClubWhereInput[]
    id?: DecimalFilter<"OrgClub"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"OrgClub"> | string
    abbr?: StringNullableFilter<"OrgClub"> | string | null
    description?: StringNullableFilter<"OrgClub"> | string | null
    foundedDate?: DateTimeNullableFilter<"OrgClub"> | Date | string | null
    address?: StringNullableFilter<"OrgClub"> | string | null
    contactEmail?: StringNullableFilter<"OrgClub"> | string | null
    contactPhone?: StringNullableFilter<"OrgClub"> | string | null
    website?: StringNullableFilter<"OrgClub"> | string | null
    status?: StringFilter<"OrgClub"> | string
    ord?: IntNullableFilter<"OrgClub"> | number | null
    createdAt?: DateTimeNullableFilter<"OrgClub"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrgClub"> | Date | string | null
  }

  export type OrgClubOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    foundedDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    status?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: OrgClubOrderByRelevanceInput
  }

  export type OrgClubWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: OrgClubWhereInput | OrgClubWhereInput[]
    OR?: OrgClubWhereInput[]
    NOT?: OrgClubWhereInput | OrgClubWhereInput[]
    name?: StringFilter<"OrgClub"> | string
    abbr?: StringNullableFilter<"OrgClub"> | string | null
    description?: StringNullableFilter<"OrgClub"> | string | null
    foundedDate?: DateTimeNullableFilter<"OrgClub"> | Date | string | null
    address?: StringNullableFilter<"OrgClub"> | string | null
    contactEmail?: StringNullableFilter<"OrgClub"> | string | null
    contactPhone?: StringNullableFilter<"OrgClub"> | string | null
    website?: StringNullableFilter<"OrgClub"> | string | null
    status?: StringFilter<"OrgClub"> | string
    ord?: IntNullableFilter<"OrgClub"> | number | null
    createdAt?: DateTimeNullableFilter<"OrgClub"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrgClub"> | Date | string | null
  }, "id">

  export type OrgClubOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    foundedDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    status?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OrgClubCountOrderByAggregateInput
    _avg?: OrgClubAvgOrderByAggregateInput
    _max?: OrgClubMaxOrderByAggregateInput
    _min?: OrgClubMinOrderByAggregateInput
    _sum?: OrgClubSumOrderByAggregateInput
  }

  export type OrgClubScalarWhereWithAggregatesInput = {
    AND?: OrgClubScalarWhereWithAggregatesInput | OrgClubScalarWhereWithAggregatesInput[]
    OR?: OrgClubScalarWhereWithAggregatesInput[]
    NOT?: OrgClubScalarWhereWithAggregatesInput | OrgClubScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"OrgClub"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"OrgClub"> | string
    abbr?: StringNullableWithAggregatesFilter<"OrgClub"> | string | null
    description?: StringNullableWithAggregatesFilter<"OrgClub"> | string | null
    foundedDate?: DateTimeNullableWithAggregatesFilter<"OrgClub"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"OrgClub"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"OrgClub"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"OrgClub"> | string | null
    website?: StringNullableWithAggregatesFilter<"OrgClub"> | string | null
    status?: StringWithAggregatesFilter<"OrgClub"> | string
    ord?: IntNullableWithAggregatesFilter<"OrgClub"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OrgClub"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrgClub"> | Date | string | null
  }

  export type OrgLeagueWhereInput = {
    AND?: OrgLeagueWhereInput | OrgLeagueWhereInput[]
    OR?: OrgLeagueWhereInput[]
    NOT?: OrgLeagueWhereInput | OrgLeagueWhereInput[]
    id?: DecimalFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"OrgLeague"> | string
    abbr?: StringNullableFilter<"OrgLeague"> | string | null
    description?: StringNullableFilter<"OrgLeague"> | string | null
    gameModeId?: DecimalNullableFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: DecimalNullableFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    season?: StringNullableFilter<"OrgLeague"> | string | null
    startDate?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    endDate?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    registrationDeadline?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    maxTeams?: IntNullableFilter<"OrgLeague"> | number | null
    entryFee?: DecimalNullableFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: StringNullableFilter<"OrgLeague"> | string | null
    rules?: StringNullableFilter<"OrgLeague"> | string | null
    status?: StringFilter<"OrgLeague"> | string
    ord?: IntNullableFilter<"OrgLeague"> | number | null
    createdAt?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
  }

  export type OrgLeagueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    gameModeId?: SortOrderInput | SortOrder
    groupLevelId?: SortOrderInput | SortOrder
    season?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    registrationDeadline?: SortOrderInput | SortOrder
    maxTeams?: SortOrderInput | SortOrder
    entryFee?: SortOrderInput | SortOrder
    subscribeEmail?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    status?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: OrgLeagueOrderByRelevanceInput
  }

  export type OrgLeagueWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: OrgLeagueWhereInput | OrgLeagueWhereInput[]
    OR?: OrgLeagueWhereInput[]
    NOT?: OrgLeagueWhereInput | OrgLeagueWhereInput[]
    name?: StringFilter<"OrgLeague"> | string
    abbr?: StringNullableFilter<"OrgLeague"> | string | null
    description?: StringNullableFilter<"OrgLeague"> | string | null
    gameModeId?: DecimalNullableFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: DecimalNullableFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    season?: StringNullableFilter<"OrgLeague"> | string | null
    startDate?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    endDate?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    registrationDeadline?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    maxTeams?: IntNullableFilter<"OrgLeague"> | number | null
    entryFee?: DecimalNullableFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: StringNullableFilter<"OrgLeague"> | string | null
    rules?: StringNullableFilter<"OrgLeague"> | string | null
    status?: StringFilter<"OrgLeague"> | string
    ord?: IntNullableFilter<"OrgLeague"> | number | null
    createdAt?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrgLeague"> | Date | string | null
  }, "id">

  export type OrgLeagueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    gameModeId?: SortOrderInput | SortOrder
    groupLevelId?: SortOrderInput | SortOrder
    season?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    registrationDeadline?: SortOrderInput | SortOrder
    maxTeams?: SortOrderInput | SortOrder
    entryFee?: SortOrderInput | SortOrder
    subscribeEmail?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    status?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OrgLeagueCountOrderByAggregateInput
    _avg?: OrgLeagueAvgOrderByAggregateInput
    _max?: OrgLeagueMaxOrderByAggregateInput
    _min?: OrgLeagueMinOrderByAggregateInput
    _sum?: OrgLeagueSumOrderByAggregateInput
  }

  export type OrgLeagueScalarWhereWithAggregatesInput = {
    AND?: OrgLeagueScalarWhereWithAggregatesInput | OrgLeagueScalarWhereWithAggregatesInput[]
    OR?: OrgLeagueScalarWhereWithAggregatesInput[]
    NOT?: OrgLeagueScalarWhereWithAggregatesInput | OrgLeagueScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"OrgLeague"> | string
    abbr?: StringNullableWithAggregatesFilter<"OrgLeague"> | string | null
    description?: StringNullableWithAggregatesFilter<"OrgLeague"> | string | null
    gameModeId?: DecimalNullableWithAggregatesFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: DecimalNullableWithAggregatesFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    season?: StringNullableWithAggregatesFilter<"OrgLeague"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"OrgLeague"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"OrgLeague"> | Date | string | null
    registrationDeadline?: DateTimeNullableWithAggregatesFilter<"OrgLeague"> | Date | string | null
    maxTeams?: IntNullableWithAggregatesFilter<"OrgLeague"> | number | null
    entryFee?: DecimalNullableWithAggregatesFilter<"OrgLeague"> | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: StringNullableWithAggregatesFilter<"OrgLeague"> | string | null
    rules?: StringNullableWithAggregatesFilter<"OrgLeague"> | string | null
    status?: StringWithAggregatesFilter<"OrgLeague"> | string
    ord?: IntNullableWithAggregatesFilter<"OrgLeague"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OrgLeague"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrgLeague"> | Date | string | null
  }

  export type OrgTeamWhereInput = {
    AND?: OrgTeamWhereInput | OrgTeamWhereInput[]
    OR?: OrgTeamWhereInput[]
    NOT?: OrgTeamWhereInput | OrgTeamWhereInput[]
    id?: DecimalFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"OrgTeam"> | string
    abbr?: StringNullableFilter<"OrgTeam"> | string | null
    note?: StringNullableFilter<"OrgTeam"> | string | null
    clubId?: DecimalNullableFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    sportId?: DecimalNullableFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    leagueId?: DecimalNullableFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    ageGroup?: StringNullableFilter<"OrgTeam"> | string | null
    gender?: IntNullableFilter<"OrgTeam"> | number | null
    skillLevel?: StringNullableFilter<"OrgTeam"> | string | null
    color1?: StringNullableFilter<"OrgTeam"> | string | null
    color2?: StringNullableFilter<"OrgTeam"> | string | null
    maxPlayers?: IntNullableFilter<"OrgTeam"> | number | null
    status?: IntFilter<"OrgTeam"> | number
    ord?: IntNullableFilter<"OrgTeam"> | number | null
    createdAt?: DateTimeNullableFilter<"OrgTeam"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrgTeam"> | Date | string | null
  }

  export type OrgTeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    clubId?: SortOrderInput | SortOrder
    sportId?: SortOrderInput | SortOrder
    leagueId?: SortOrderInput | SortOrder
    ageGroup?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    skillLevel?: SortOrderInput | SortOrder
    color1?: SortOrderInput | SortOrder
    color2?: SortOrderInput | SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    status?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: OrgTeamOrderByRelevanceInput
  }

  export type OrgTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: OrgTeamWhereInput | OrgTeamWhereInput[]
    OR?: OrgTeamWhereInput[]
    NOT?: OrgTeamWhereInput | OrgTeamWhereInput[]
    name?: StringFilter<"OrgTeam"> | string
    abbr?: StringNullableFilter<"OrgTeam"> | string | null
    note?: StringNullableFilter<"OrgTeam"> | string | null
    clubId?: DecimalNullableFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    sportId?: DecimalNullableFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    leagueId?: DecimalNullableFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    ageGroup?: StringNullableFilter<"OrgTeam"> | string | null
    gender?: IntNullableFilter<"OrgTeam"> | number | null
    skillLevel?: StringNullableFilter<"OrgTeam"> | string | null
    color1?: StringNullableFilter<"OrgTeam"> | string | null
    color2?: StringNullableFilter<"OrgTeam"> | string | null
    maxPlayers?: IntNullableFilter<"OrgTeam"> | number | null
    status?: IntFilter<"OrgTeam"> | number
    ord?: IntNullableFilter<"OrgTeam"> | number | null
    createdAt?: DateTimeNullableFilter<"OrgTeam"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrgTeam"> | Date | string | null
  }, "id">

  export type OrgTeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    clubId?: SortOrderInput | SortOrder
    sportId?: SortOrderInput | SortOrder
    leagueId?: SortOrderInput | SortOrder
    ageGroup?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    skillLevel?: SortOrderInput | SortOrder
    color1?: SortOrderInput | SortOrder
    color2?: SortOrderInput | SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    status?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OrgTeamCountOrderByAggregateInput
    _avg?: OrgTeamAvgOrderByAggregateInput
    _max?: OrgTeamMaxOrderByAggregateInput
    _min?: OrgTeamMinOrderByAggregateInput
    _sum?: OrgTeamSumOrderByAggregateInput
  }

  export type OrgTeamScalarWhereWithAggregatesInput = {
    AND?: OrgTeamScalarWhereWithAggregatesInput | OrgTeamScalarWhereWithAggregatesInput[]
    OR?: OrgTeamScalarWhereWithAggregatesInput[]
    NOT?: OrgTeamScalarWhereWithAggregatesInput | OrgTeamScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"OrgTeam"> | string
    abbr?: StringNullableWithAggregatesFilter<"OrgTeam"> | string | null
    note?: StringNullableWithAggregatesFilter<"OrgTeam"> | string | null
    clubId?: DecimalNullableWithAggregatesFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    sportId?: DecimalNullableWithAggregatesFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    leagueId?: DecimalNullableWithAggregatesFilter<"OrgTeam"> | Decimal | DecimalJsLike | number | string | null
    ageGroup?: StringNullableWithAggregatesFilter<"OrgTeam"> | string | null
    gender?: IntNullableWithAggregatesFilter<"OrgTeam"> | number | null
    skillLevel?: StringNullableWithAggregatesFilter<"OrgTeam"> | string | null
    color1?: StringNullableWithAggregatesFilter<"OrgTeam"> | string | null
    color2?: StringNullableWithAggregatesFilter<"OrgTeam"> | string | null
    maxPlayers?: IntNullableWithAggregatesFilter<"OrgTeam"> | number | null
    status?: IntWithAggregatesFilter<"OrgTeam"> | number
    ord?: IntNullableWithAggregatesFilter<"OrgTeam"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OrgTeam"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrgTeam"> | Date | string | null
  }

  export type PlanGameWhereInput = {
    AND?: PlanGameWhereInput | PlanGameWhereInput[]
    OR?: PlanGameWhereInput[]
    NOT?: PlanGameWhereInput | PlanGameWhereInput[]
    id?: DecimalFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    gameName?: StringNullableFilter<"PlanGame"> | string | null
    homeTeamId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFilter<"PlanGame"> | Date | string
    endDatetime?: DateTimeFilter<"PlanGame"> | Date | string
    duration?: IntNullableFilter<"PlanGame"> | number | null
    uniform?: StringNullableFilter<"PlanGame"> | string | null
    locationId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntFilter<"PlanGame"> | number
    status?: StringFilter<"PlanGame"> | string
    createdBy?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"PlanGame"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PlanGame"> | Date | string | null
  }

  export type PlanGameOrderByWithRelationInput = {
    id?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    gameName?: SortOrderInput | SortOrder
    homeTeamId?: SortOrderInput | SortOrder
    awayTeamId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    duration?: SortOrderInput | SortOrder
    uniform?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    isScrimmage?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: PlanGameOrderByRelevanceInput
  }

  export type PlanGameWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: PlanGameWhereInput | PlanGameWhereInput[]
    OR?: PlanGameWhereInput[]
    NOT?: PlanGameWhereInput | PlanGameWhereInput[]
    leagueId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    gameName?: StringNullableFilter<"PlanGame"> | string | null
    homeTeamId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFilter<"PlanGame"> | Date | string
    endDatetime?: DateTimeFilter<"PlanGame"> | Date | string
    duration?: IntNullableFilter<"PlanGame"> | number | null
    uniform?: StringNullableFilter<"PlanGame"> | string | null
    locationId?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntFilter<"PlanGame"> | number
    status?: StringFilter<"PlanGame"> | string
    createdBy?: DecimalNullableFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"PlanGame"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PlanGame"> | Date | string | null
  }, "id">

  export type PlanGameOrderByWithAggregationInput = {
    id?: SortOrder
    leagueId?: SortOrderInput | SortOrder
    gameName?: SortOrderInput | SortOrder
    homeTeamId?: SortOrderInput | SortOrder
    awayTeamId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    duration?: SortOrderInput | SortOrder
    uniform?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    isScrimmage?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlanGameCountOrderByAggregateInput
    _avg?: PlanGameAvgOrderByAggregateInput
    _max?: PlanGameMaxOrderByAggregateInput
    _min?: PlanGameMinOrderByAggregateInput
    _sum?: PlanGameSumOrderByAggregateInput
  }

  export type PlanGameScalarWhereWithAggregatesInput = {
    AND?: PlanGameScalarWhereWithAggregatesInput | PlanGameScalarWhereWithAggregatesInput[]
    OR?: PlanGameScalarWhereWithAggregatesInput[]
    NOT?: PlanGameScalarWhereWithAggregatesInput | PlanGameScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalNullableWithAggregatesFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    gameName?: StringNullableWithAggregatesFilter<"PlanGame"> | string | null
    homeTeamId?: DecimalNullableWithAggregatesFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: DecimalNullableWithAggregatesFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeWithAggregatesFilter<"PlanGame"> | Date | string
    endDatetime?: DateTimeWithAggregatesFilter<"PlanGame"> | Date | string
    duration?: IntNullableWithAggregatesFilter<"PlanGame"> | number | null
    uniform?: StringNullableWithAggregatesFilter<"PlanGame"> | string | null
    locationId?: DecimalNullableWithAggregatesFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntWithAggregatesFilter<"PlanGame"> | number
    status?: StringWithAggregatesFilter<"PlanGame"> | string
    createdBy?: DecimalNullableWithAggregatesFilter<"PlanGame"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"PlanGame"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PlanGame"> | Date | string | null
  }

  export type PlanMeetingWhereInput = {
    AND?: PlanMeetingWhereInput | PlanMeetingWhereInput[]
    OR?: PlanMeetingWhereInput[]
    NOT?: PlanMeetingWhereInput | PlanMeetingWhereInput[]
    id?: DecimalFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string
    meetingCategory?: IntNullableFilter<"PlanMeeting"> | number | null
    teamId?: DecimalNullableFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFilter<"PlanMeeting"> | Date | string
    endDatetime?: DateTimeFilter<"PlanMeeting"> | Date | string
    title?: StringNullableFilter<"PlanMeeting"> | string | null
    content?: StringNullableFilter<"PlanMeeting"> | string | null
    locationId?: DecimalNullableFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    status?: IntNullableFilter<"PlanMeeting"> | number | null
    createdBy?: DecimalNullableFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"PlanMeeting"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PlanMeeting"> | Date | string | null
  }

  export type PlanMeetingOrderByWithRelationInput = {
    id?: SortOrder
    meetingCategory?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: PlanMeetingOrderByRelevanceInput
  }

  export type PlanMeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: PlanMeetingWhereInput | PlanMeetingWhereInput[]
    OR?: PlanMeetingWhereInput[]
    NOT?: PlanMeetingWhereInput | PlanMeetingWhereInput[]
    meetingCategory?: IntNullableFilter<"PlanMeeting"> | number | null
    teamId?: DecimalNullableFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFilter<"PlanMeeting"> | Date | string
    endDatetime?: DateTimeFilter<"PlanMeeting"> | Date | string
    title?: StringNullableFilter<"PlanMeeting"> | string | null
    content?: StringNullableFilter<"PlanMeeting"> | string | null
    locationId?: DecimalNullableFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    status?: IntNullableFilter<"PlanMeeting"> | number | null
    createdBy?: DecimalNullableFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"PlanMeeting"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PlanMeeting"> | Date | string | null
  }, "id">

  export type PlanMeetingOrderByWithAggregationInput = {
    id?: SortOrder
    meetingCategory?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlanMeetingCountOrderByAggregateInput
    _avg?: PlanMeetingAvgOrderByAggregateInput
    _max?: PlanMeetingMaxOrderByAggregateInput
    _min?: PlanMeetingMinOrderByAggregateInput
    _sum?: PlanMeetingSumOrderByAggregateInput
  }

  export type PlanMeetingScalarWhereWithAggregatesInput = {
    AND?: PlanMeetingScalarWhereWithAggregatesInput | PlanMeetingScalarWhereWithAggregatesInput[]
    OR?: PlanMeetingScalarWhereWithAggregatesInput[]
    NOT?: PlanMeetingScalarWhereWithAggregatesInput | PlanMeetingScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string
    meetingCategory?: IntNullableWithAggregatesFilter<"PlanMeeting"> | number | null
    teamId?: DecimalNullableWithAggregatesFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeWithAggregatesFilter<"PlanMeeting"> | Date | string
    endDatetime?: DateTimeWithAggregatesFilter<"PlanMeeting"> | Date | string
    title?: StringNullableWithAggregatesFilter<"PlanMeeting"> | string | null
    content?: StringNullableWithAggregatesFilter<"PlanMeeting"> | string | null
    locationId?: DecimalNullableWithAggregatesFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    status?: IntNullableWithAggregatesFilter<"PlanMeeting"> | number | null
    createdBy?: DecimalNullableWithAggregatesFilter<"PlanMeeting"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"PlanMeeting"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PlanMeeting"> | Date | string | null
  }

  export type PlanTrainingWhereInput = {
    AND?: PlanTrainingWhereInput | PlanTrainingWhereInput[]
    OR?: PlanTrainingWhereInput[]
    NOT?: PlanTrainingWhereInput | PlanTrainingWhereInput[]
    id?: DecimalFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalNullableFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFilter<"PlanTraining"> | Date | string
    endDatetime?: DateTimeFilter<"PlanTraining"> | Date | string
    trainingContent?: StringNullableFilter<"PlanTraining"> | string | null
    isAllMembers?: IntFilter<"PlanTraining"> | number
    locationId?: DecimalNullableFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntFilter<"PlanTraining"> | number
    status?: StringFilter<"PlanTraining"> | string
    createdBy?: DecimalNullableFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"PlanTraining"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PlanTraining"> | Date | string | null
  }

  export type PlanTrainingOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    trainingContent?: SortOrderInput | SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrderInput | SortOrder
    recurringType?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: PlanTrainingOrderByRelevanceInput
  }

  export type PlanTrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: PlanTrainingWhereInput | PlanTrainingWhereInput[]
    OR?: PlanTrainingWhereInput[]
    NOT?: PlanTrainingWhereInput | PlanTrainingWhereInput[]
    teamId?: DecimalNullableFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFilter<"PlanTraining"> | Date | string
    endDatetime?: DateTimeFilter<"PlanTraining"> | Date | string
    trainingContent?: StringNullableFilter<"PlanTraining"> | string | null
    isAllMembers?: IntFilter<"PlanTraining"> | number
    locationId?: DecimalNullableFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntFilter<"PlanTraining"> | number
    status?: StringFilter<"PlanTraining"> | string
    createdBy?: DecimalNullableFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"PlanTraining"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"PlanTraining"> | Date | string | null
  }, "id">

  export type PlanTrainingOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    trainingContent?: SortOrderInput | SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrderInput | SortOrder
    recurringType?: SortOrder
    status?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: PlanTrainingCountOrderByAggregateInput
    _avg?: PlanTrainingAvgOrderByAggregateInput
    _max?: PlanTrainingMaxOrderByAggregateInput
    _min?: PlanTrainingMinOrderByAggregateInput
    _sum?: PlanTrainingSumOrderByAggregateInput
  }

  export type PlanTrainingScalarWhereWithAggregatesInput = {
    AND?: PlanTrainingScalarWhereWithAggregatesInput | PlanTrainingScalarWhereWithAggregatesInput[]
    OR?: PlanTrainingScalarWhereWithAggregatesInput[]
    NOT?: PlanTrainingScalarWhereWithAggregatesInput | PlanTrainingScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalNullableWithAggregatesFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeWithAggregatesFilter<"PlanTraining"> | Date | string
    endDatetime?: DateTimeWithAggregatesFilter<"PlanTraining"> | Date | string
    trainingContent?: StringNullableWithAggregatesFilter<"PlanTraining"> | string | null
    isAllMembers?: IntWithAggregatesFilter<"PlanTraining"> | number
    locationId?: DecimalNullableWithAggregatesFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntWithAggregatesFilter<"PlanTraining"> | number
    status?: StringWithAggregatesFilter<"PlanTraining"> | string
    createdBy?: DecimalNullableWithAggregatesFilter<"PlanTraining"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"PlanTraining"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PlanTraining"> | Date | string | null
  }

  export type RelClubClubAdminWhereInput = {
    AND?: RelClubClubAdminWhereInput | RelClubClubAdminWhereInput[]
    OR?: RelClubClubAdminWhereInput[]
    NOT?: RelClubClubAdminWhereInput | RelClubClubAdminWhereInput[]
    id?: DecimalFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    adminId?: DecimalFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    status?: StringFilter<"RelClubClubAdmin"> | string
    role?: StringFilter<"RelClubClubAdmin"> | string
    salary?: DecimalNullableFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    notes?: StringNullableFilter<"RelClubClubAdmin"> | string | null
    ord?: IntFilter<"RelClubClubAdmin"> | number
    createdAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
  }

  export type RelClubClubAdminOrderByWithRelationInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    salary?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelClubClubAdminOrderByRelevanceInput
  }

  export type RelClubClubAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    clubId_adminId?: RelClubClubAdminClubIdAdminIdCompoundUniqueInput
    AND?: RelClubClubAdminWhereInput | RelClubClubAdminWhereInput[]
    OR?: RelClubClubAdminWhereInput[]
    NOT?: RelClubClubAdminWhereInput | RelClubClubAdminWhereInput[]
    clubId?: DecimalFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    adminId?: DecimalFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    status?: StringFilter<"RelClubClubAdmin"> | string
    role?: StringFilter<"RelClubClubAdmin"> | string
    salary?: DecimalNullableFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    notes?: StringNullableFilter<"RelClubClubAdmin"> | string | null
    ord?: IntFilter<"RelClubClubAdmin"> | number
    createdAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelClubClubAdmin"> | Date | string | null
  }, "id" | "clubId_adminId">

  export type RelClubClubAdminOrderByWithAggregationInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    salary?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelClubClubAdminCountOrderByAggregateInput
    _avg?: RelClubClubAdminAvgOrderByAggregateInput
    _max?: RelClubClubAdminMaxOrderByAggregateInput
    _min?: RelClubClubAdminMinOrderByAggregateInput
    _sum?: RelClubClubAdminSumOrderByAggregateInput
  }

  export type RelClubClubAdminScalarWhereWithAggregatesInput = {
    AND?: RelClubClubAdminScalarWhereWithAggregatesInput | RelClubClubAdminScalarWhereWithAggregatesInput[]
    OR?: RelClubClubAdminScalarWhereWithAggregatesInput[]
    NOT?: RelClubClubAdminScalarWhereWithAggregatesInput | RelClubClubAdminScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalWithAggregatesFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    adminId?: DecimalWithAggregatesFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"RelClubClubAdmin"> | Date | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"RelClubClubAdmin"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelClubClubAdmin"> | string
    role?: StringWithAggregatesFilter<"RelClubClubAdmin"> | string
    salary?: DecimalNullableWithAggregatesFilter<"RelClubClubAdmin"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableWithAggregatesFilter<"RelClubClubAdmin"> | Date | string | null
    contractEnd?: DateTimeNullableWithAggregatesFilter<"RelClubClubAdmin"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"RelClubClubAdmin"> | string | null
    ord?: IntWithAggregatesFilter<"RelClubClubAdmin"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelClubClubAdmin"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelClubClubAdmin"> | Date | string | null
  }

  export type RelCompetitionGroupLevelWhereInput = {
    AND?: RelCompetitionGroupLevelWhereInput | RelCompetitionGroupLevelWhereInput[]
    OR?: RelCompetitionGroupLevelWhereInput[]
    NOT?: RelCompetitionGroupLevelWhereInput | RelCompetitionGroupLevelWhereInput[]
    id?: DecimalFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFilter<"RelCompetitionGroupLevel"> | number
    notes?: StringNullableFilter<"RelCompetitionGroupLevel"> | string | null
    ord?: IntFilter<"RelCompetitionGroupLevel"> | number
    createdAt?: DateTimeNullableFilter<"RelCompetitionGroupLevel"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelCompetitionGroupLevel"> | Date | string | null
  }

  export type RelCompetitionGroupLevelOrderByWithRelationInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelCompetitionGroupLevelOrderByRelevanceInput
  }

  export type RelCompetitionGroupLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    competitionId_groupLevelId?: RelCompetitionGroupLevelCompetitionIdGroupLevelIdCompoundUniqueInput
    AND?: RelCompetitionGroupLevelWhereInput | RelCompetitionGroupLevelWhereInput[]
    OR?: RelCompetitionGroupLevelWhereInput[]
    NOT?: RelCompetitionGroupLevelWhereInput | RelCompetitionGroupLevelWhereInput[]
    competitionId?: DecimalFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFilter<"RelCompetitionGroupLevel"> | number
    notes?: StringNullableFilter<"RelCompetitionGroupLevel"> | string | null
    ord?: IntFilter<"RelCompetitionGroupLevel"> | number
    createdAt?: DateTimeNullableFilter<"RelCompetitionGroupLevel"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelCompetitionGroupLevel"> | Date | string | null
  }, "id" | "competitionId_groupLevelId">

  export type RelCompetitionGroupLevelOrderByWithAggregationInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelCompetitionGroupLevelCountOrderByAggregateInput
    _avg?: RelCompetitionGroupLevelAvgOrderByAggregateInput
    _max?: RelCompetitionGroupLevelMaxOrderByAggregateInput
    _min?: RelCompetitionGroupLevelMinOrderByAggregateInput
    _sum?: RelCompetitionGroupLevelSumOrderByAggregateInput
  }

  export type RelCompetitionGroupLevelScalarWhereWithAggregatesInput = {
    AND?: RelCompetitionGroupLevelScalarWhereWithAggregatesInput | RelCompetitionGroupLevelScalarWhereWithAggregatesInput[]
    OR?: RelCompetitionGroupLevelScalarWhereWithAggregatesInput[]
    NOT?: RelCompetitionGroupLevelScalarWhereWithAggregatesInput | RelCompetitionGroupLevelScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalWithAggregatesFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalWithAggregatesFilter<"RelCompetitionGroupLevel"> | Decimal | DecimalJsLike | number | string
    isPrimary?: IntWithAggregatesFilter<"RelCompetitionGroupLevel"> | number
    notes?: StringNullableWithAggregatesFilter<"RelCompetitionGroupLevel"> | string | null
    ord?: IntWithAggregatesFilter<"RelCompetitionGroupLevel"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelCompetitionGroupLevel"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelCompetitionGroupLevel"> | Date | string | null
  }

  export type RelFieldSportWhereInput = {
    AND?: RelFieldSportWhereInput | RelFieldSportWhereInput[]
    OR?: RelFieldSportWhereInput[]
    NOT?: RelFieldSportWhereInput | RelFieldSportWhereInput[]
    id?: DecimalFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    fieldId?: DecimalFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFilter<"RelFieldSport"> | number
    notes?: StringNullableFilter<"RelFieldSport"> | string | null
    ord?: IntFilter<"RelFieldSport"> | number
    createdAt?: DateTimeNullableFilter<"RelFieldSport"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelFieldSport"> | Date | string | null
  }

  export type RelFieldSportOrderByWithRelationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelFieldSportOrderByRelevanceInput
  }

  export type RelFieldSportWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    fieldId_sportId?: RelFieldSportFieldIdSportIdCompoundUniqueInput
    AND?: RelFieldSportWhereInput | RelFieldSportWhereInput[]
    OR?: RelFieldSportWhereInput[]
    NOT?: RelFieldSportWhereInput | RelFieldSportWhereInput[]
    fieldId?: DecimalFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFilter<"RelFieldSport"> | number
    notes?: StringNullableFilter<"RelFieldSport"> | string | null
    ord?: IntFilter<"RelFieldSport"> | number
    createdAt?: DateTimeNullableFilter<"RelFieldSport"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelFieldSport"> | Date | string | null
  }, "id" | "fieldId_sportId">

  export type RelFieldSportOrderByWithAggregationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelFieldSportCountOrderByAggregateInput
    _avg?: RelFieldSportAvgOrderByAggregateInput
    _max?: RelFieldSportMaxOrderByAggregateInput
    _min?: RelFieldSportMinOrderByAggregateInput
    _sum?: RelFieldSportSumOrderByAggregateInput
  }

  export type RelFieldSportScalarWhereWithAggregatesInput = {
    AND?: RelFieldSportScalarWhereWithAggregatesInput | RelFieldSportScalarWhereWithAggregatesInput[]
    OR?: RelFieldSportScalarWhereWithAggregatesInput[]
    NOT?: RelFieldSportScalarWhereWithAggregatesInput | RelFieldSportScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    fieldId?: DecimalWithAggregatesFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalWithAggregatesFilter<"RelFieldSport"> | Decimal | DecimalJsLike | number | string
    isPrimary?: IntWithAggregatesFilter<"RelFieldSport"> | number
    notes?: StringNullableWithAggregatesFilter<"RelFieldSport"> | string | null
    ord?: IntWithAggregatesFilter<"RelFieldSport"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelFieldSport"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelFieldSport"> | Date | string | null
  }

  export type RelMatchRefereeWhereInput = {
    AND?: RelMatchRefereeWhereInput | RelMatchRefereeWhereInput[]
    OR?: RelMatchRefereeWhereInput[]
    NOT?: RelMatchRefereeWhereInput | RelMatchRefereeWhereInput[]
    id?: DecimalFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    assignedAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    status?: StringFilter<"RelMatchReferee"> | string
    matchFee?: DecimalNullableFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"RelMatchReferee"> | string | null
    ord?: IntFilter<"RelMatchReferee"> | number
    createdAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
  }

  export type RelMatchRefereeOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    matchFee?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelMatchRefereeOrderByRelevanceInput
  }

  export type RelMatchRefereeWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    matchId_refereeId?: RelMatchRefereeMatchIdRefereeIdCompoundUniqueInput
    AND?: RelMatchRefereeWhereInput | RelMatchRefereeWhereInput[]
    OR?: RelMatchRefereeWhereInput[]
    NOT?: RelMatchRefereeWhereInput | RelMatchRefereeWhereInput[]
    matchId?: DecimalFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    assignedAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    status?: StringFilter<"RelMatchReferee"> | string
    matchFee?: DecimalNullableFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"RelMatchReferee"> | string | null
    ord?: IntFilter<"RelMatchReferee"> | number
    createdAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelMatchReferee"> | Date | string | null
  }, "id" | "matchId_refereeId">

  export type RelMatchRefereeOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    matchFee?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelMatchRefereeCountOrderByAggregateInput
    _avg?: RelMatchRefereeAvgOrderByAggregateInput
    _max?: RelMatchRefereeMaxOrderByAggregateInput
    _min?: RelMatchRefereeMinOrderByAggregateInput
    _sum?: RelMatchRefereeSumOrderByAggregateInput
  }

  export type RelMatchRefereeScalarWhereWithAggregatesInput = {
    AND?: RelMatchRefereeScalarWhereWithAggregatesInput | RelMatchRefereeScalarWhereWithAggregatesInput[]
    OR?: RelMatchRefereeScalarWhereWithAggregatesInput[]
    NOT?: RelMatchRefereeScalarWhereWithAggregatesInput | RelMatchRefereeScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    matchId?: DecimalWithAggregatesFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalWithAggregatesFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string
    assignedAt?: DateTimeNullableWithAggregatesFilter<"RelMatchReferee"> | Date | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"RelMatchReferee"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"RelMatchReferee"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelMatchReferee"> | string
    matchFee?: DecimalNullableWithAggregatesFilter<"RelMatchReferee"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"RelMatchReferee"> | string | null
    ord?: IntWithAggregatesFilter<"RelMatchReferee"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelMatchReferee"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelMatchReferee"> | Date | string | null
  }

  export type RelPlayerParentWhereInput = {
    AND?: RelPlayerParentWhereInput | RelPlayerParentWhereInput[]
    OR?: RelPlayerParentWhereInput[]
    NOT?: RelPlayerParentWhereInput | RelPlayerParentWhereInput[]
    id?: DecimalFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    parentId?: DecimalFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    assignedAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
    relationship?: StringNullableFilter<"RelPlayerParent"> | string | null
    isPrimaryContact?: IntFilter<"RelPlayerParent"> | number
    canPickup?: IntFilter<"RelPlayerParent"> | number
    receivesNotifications?: IntFilter<"RelPlayerParent"> | number
    occupation?: StringNullableFilter<"RelPlayerParent"> | string | null
    employer?: StringNullableFilter<"RelPlayerParent"> | string | null
    workPhone?: StringNullableFilter<"RelPlayerParent"> | string | null
    status?: StringFilter<"RelPlayerParent"> | string
    notes?: StringNullableFilter<"RelPlayerParent"> | string | null
    ord?: IntFilter<"RelPlayerParent"> | number
    createdAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
  }

  export type RelPlayerParentOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    occupation?: SortOrderInput | SortOrder
    employer?: SortOrderInput | SortOrder
    workPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelPlayerParentOrderByRelevanceInput
  }

  export type RelPlayerParentWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    playerId_parentId?: RelPlayerParentPlayerIdParentIdCompoundUniqueInput
    AND?: RelPlayerParentWhereInput | RelPlayerParentWhereInput[]
    OR?: RelPlayerParentWhereInput[]
    NOT?: RelPlayerParentWhereInput | RelPlayerParentWhereInput[]
    playerId?: DecimalFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    parentId?: DecimalFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    assignedAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
    removedAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
    relationship?: StringNullableFilter<"RelPlayerParent"> | string | null
    isPrimaryContact?: IntFilter<"RelPlayerParent"> | number
    canPickup?: IntFilter<"RelPlayerParent"> | number
    receivesNotifications?: IntFilter<"RelPlayerParent"> | number
    occupation?: StringNullableFilter<"RelPlayerParent"> | string | null
    employer?: StringNullableFilter<"RelPlayerParent"> | string | null
    workPhone?: StringNullableFilter<"RelPlayerParent"> | string | null
    status?: StringFilter<"RelPlayerParent"> | string
    notes?: StringNullableFilter<"RelPlayerParent"> | string | null
    ord?: IntFilter<"RelPlayerParent"> | number
    createdAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelPlayerParent"> | Date | string | null
  }, "id" | "playerId_parentId">

  export type RelPlayerParentOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    removedAt?: SortOrderInput | SortOrder
    relationship?: SortOrderInput | SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    occupation?: SortOrderInput | SortOrder
    employer?: SortOrderInput | SortOrder
    workPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelPlayerParentCountOrderByAggregateInput
    _avg?: RelPlayerParentAvgOrderByAggregateInput
    _max?: RelPlayerParentMaxOrderByAggregateInput
    _min?: RelPlayerParentMinOrderByAggregateInput
    _sum?: RelPlayerParentSumOrderByAggregateInput
  }

  export type RelPlayerParentScalarWhereWithAggregatesInput = {
    AND?: RelPlayerParentScalarWhereWithAggregatesInput | RelPlayerParentScalarWhereWithAggregatesInput[]
    OR?: RelPlayerParentScalarWhereWithAggregatesInput[]
    NOT?: RelPlayerParentScalarWhereWithAggregatesInput | RelPlayerParentScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalWithAggregatesFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    parentId?: DecimalWithAggregatesFilter<"RelPlayerParent"> | Decimal | DecimalJsLike | number | string
    assignedAt?: DateTimeNullableWithAggregatesFilter<"RelPlayerParent"> | Date | string | null
    removedAt?: DateTimeNullableWithAggregatesFilter<"RelPlayerParent"> | Date | string | null
    relationship?: StringNullableWithAggregatesFilter<"RelPlayerParent"> | string | null
    isPrimaryContact?: IntWithAggregatesFilter<"RelPlayerParent"> | number
    canPickup?: IntWithAggregatesFilter<"RelPlayerParent"> | number
    receivesNotifications?: IntWithAggregatesFilter<"RelPlayerParent"> | number
    occupation?: StringNullableWithAggregatesFilter<"RelPlayerParent"> | string | null
    employer?: StringNullableWithAggregatesFilter<"RelPlayerParent"> | string | null
    workPhone?: StringNullableWithAggregatesFilter<"RelPlayerParent"> | string | null
    status?: StringWithAggregatesFilter<"RelPlayerParent"> | string
    notes?: StringNullableWithAggregatesFilter<"RelPlayerParent"> | string | null
    ord?: IntWithAggregatesFilter<"RelPlayerParent"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelPlayerParent"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelPlayerParent"> | Date | string | null
  }

  export type RelSponsorClubWhereInput = {
    AND?: RelSponsorClubWhereInput | RelSponsorClubWhereInput[]
    OR?: RelSponsorClubWhereInput[]
    NOT?: RelSponsorClubWhereInput | RelSponsorClubWhereInput[]
    id?: DecimalFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
    status?: StringFilter<"RelSponsorClub"> | string
    sponsorshipAmount?: DecimalNullableFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableFilter<"RelSponsorClub"> | string | null
    notes?: StringNullableFilter<"RelSponsorClub"> | string | null
    ord?: IntFilter<"RelSponsorClub"> | number
    createdAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
  }

  export type RelSponsorClubOrderByWithRelationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelSponsorClubOrderByRelevanceInput
  }

  export type RelSponsorClubWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    sponsorId_clubId?: RelSponsorClubSponsorIdClubIdCompoundUniqueInput
    AND?: RelSponsorClubWhereInput | RelSponsorClubWhereInput[]
    OR?: RelSponsorClubWhereInput[]
    NOT?: RelSponsorClubWhereInput | RelSponsorClubWhereInput[]
    sponsorId?: DecimalFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
    status?: StringFilter<"RelSponsorClub"> | string
    sponsorshipAmount?: DecimalNullableFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableFilter<"RelSponsorClub"> | string | null
    notes?: StringNullableFilter<"RelSponsorClub"> | string | null
    ord?: IntFilter<"RelSponsorClub"> | number
    createdAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelSponsorClub"> | Date | string | null
  }, "id" | "sponsorId_clubId">

  export type RelSponsorClubOrderByWithAggregationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelSponsorClubCountOrderByAggregateInput
    _avg?: RelSponsorClubAvgOrderByAggregateInput
    _max?: RelSponsorClubMaxOrderByAggregateInput
    _min?: RelSponsorClubMinOrderByAggregateInput
    _sum?: RelSponsorClubSumOrderByAggregateInput
  }

  export type RelSponsorClubScalarWhereWithAggregatesInput = {
    AND?: RelSponsorClubScalarWhereWithAggregatesInput | RelSponsorClubScalarWhereWithAggregatesInput[]
    OR?: RelSponsorClubScalarWhereWithAggregatesInput[]
    NOT?: RelSponsorClubScalarWhereWithAggregatesInput | RelSponsorClubScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalWithAggregatesFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    clubId?: DecimalWithAggregatesFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorClub"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorClub"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelSponsorClub"> | string
    sponsorshipAmount?: DecimalNullableWithAggregatesFilter<"RelSponsorClub"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableWithAggregatesFilter<"RelSponsorClub"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RelSponsorClub"> | string | null
    ord?: IntWithAggregatesFilter<"RelSponsorClub"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorClub"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorClub"> | Date | string | null
  }

  export type RelSponsorLeagueWhereInput = {
    AND?: RelSponsorLeagueWhereInput | RelSponsorLeagueWhereInput[]
    OR?: RelSponsorLeagueWhereInput[]
    NOT?: RelSponsorLeagueWhereInput | RelSponsorLeagueWhereInput[]
    id?: DecimalFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
    status?: StringFilter<"RelSponsorLeague"> | string
    sponsorshipAmount?: DecimalNullableFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableFilter<"RelSponsorLeague"> | string | null
    notes?: StringNullableFilter<"RelSponsorLeague"> | string | null
    ord?: IntFilter<"RelSponsorLeague"> | number
    createdAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
  }

  export type RelSponsorLeagueOrderByWithRelationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelSponsorLeagueOrderByRelevanceInput
  }

  export type RelSponsorLeagueWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    sponsorId_leagueId?: RelSponsorLeagueSponsorIdLeagueIdCompoundUniqueInput
    AND?: RelSponsorLeagueWhereInput | RelSponsorLeagueWhereInput[]
    OR?: RelSponsorLeagueWhereInput[]
    NOT?: RelSponsorLeagueWhereInput | RelSponsorLeagueWhereInput[]
    sponsorId?: DecimalFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
    status?: StringFilter<"RelSponsorLeague"> | string
    sponsorshipAmount?: DecimalNullableFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableFilter<"RelSponsorLeague"> | string | null
    notes?: StringNullableFilter<"RelSponsorLeague"> | string | null
    ord?: IntFilter<"RelSponsorLeague"> | number
    createdAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelSponsorLeague"> | Date | string | null
  }, "id" | "sponsorId_leagueId">

  export type RelSponsorLeagueOrderByWithAggregationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelSponsorLeagueCountOrderByAggregateInput
    _avg?: RelSponsorLeagueAvgOrderByAggregateInput
    _max?: RelSponsorLeagueMaxOrderByAggregateInput
    _min?: RelSponsorLeagueMinOrderByAggregateInput
    _sum?: RelSponsorLeagueSumOrderByAggregateInput
  }

  export type RelSponsorLeagueScalarWhereWithAggregatesInput = {
    AND?: RelSponsorLeagueScalarWhereWithAggregatesInput | RelSponsorLeagueScalarWhereWithAggregatesInput[]
    OR?: RelSponsorLeagueScalarWhereWithAggregatesInput[]
    NOT?: RelSponsorLeagueScalarWhereWithAggregatesInput | RelSponsorLeagueScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalWithAggregatesFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalWithAggregatesFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorLeague"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorLeague"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelSponsorLeague"> | string
    sponsorshipAmount?: DecimalNullableWithAggregatesFilter<"RelSponsorLeague"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableWithAggregatesFilter<"RelSponsorLeague"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RelSponsorLeague"> | string | null
    ord?: IntWithAggregatesFilter<"RelSponsorLeague"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorLeague"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorLeague"> | Date | string | null
  }

  export type RelSponsorTeamWhereInput = {
    AND?: RelSponsorTeamWhereInput | RelSponsorTeamWhereInput[]
    OR?: RelSponsorTeamWhereInput[]
    NOT?: RelSponsorTeamWhereInput | RelSponsorTeamWhereInput[]
    id?: DecimalFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
    status?: StringFilter<"RelSponsorTeam"> | string
    sponsorshipAmount?: DecimalNullableFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableFilter<"RelSponsorTeam"> | string | null
    notes?: StringNullableFilter<"RelSponsorTeam"> | string | null
    ord?: IntFilter<"RelSponsorTeam"> | number
    createdAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
  }

  export type RelSponsorTeamOrderByWithRelationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelSponsorTeamOrderByRelevanceInput
  }

  export type RelSponsorTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    sponsorId_teamId?: RelSponsorTeamSponsorIdTeamIdCompoundUniqueInput
    AND?: RelSponsorTeamWhereInput | RelSponsorTeamWhereInput[]
    OR?: RelSponsorTeamWhereInput[]
    NOT?: RelSponsorTeamWhereInput | RelSponsorTeamWhereInput[]
    sponsorId?: DecimalFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
    status?: StringFilter<"RelSponsorTeam"> | string
    sponsorshipAmount?: DecimalNullableFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableFilter<"RelSponsorTeam"> | string | null
    notes?: StringNullableFilter<"RelSponsorTeam"> | string | null
    ord?: IntFilter<"RelSponsorTeam"> | number
    createdAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelSponsorTeam"> | Date | string | null
  }, "id" | "sponsorId_teamId">

  export type RelSponsorTeamOrderByWithAggregationInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelSponsorTeamCountOrderByAggregateInput
    _avg?: RelSponsorTeamAvgOrderByAggregateInput
    _max?: RelSponsorTeamMaxOrderByAggregateInput
    _min?: RelSponsorTeamMinOrderByAggregateInput
    _sum?: RelSponsorTeamSumOrderByAggregateInput
  }

  export type RelSponsorTeamScalarWhereWithAggregatesInput = {
    AND?: RelSponsorTeamScalarWhereWithAggregatesInput | RelSponsorTeamScalarWhereWithAggregatesInput[]
    OR?: RelSponsorTeamScalarWhereWithAggregatesInput[]
    NOT?: RelSponsorTeamScalarWhereWithAggregatesInput | RelSponsorTeamScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalWithAggregatesFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorTeam"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorTeam"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelSponsorTeam"> | string
    sponsorshipAmount?: DecimalNullableWithAggregatesFilter<"RelSponsorTeam"> | Decimal | DecimalJsLike | number | string | null
    benefits?: StringNullableWithAggregatesFilter<"RelSponsorTeam"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RelSponsorTeam"> | string | null
    ord?: IntWithAggregatesFilter<"RelSponsorTeam"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorTeam"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelSponsorTeam"> | Date | string | null
  }

  export type RelTeamCoachWhereInput = {
    AND?: RelTeamCoachWhereInput | RelTeamCoachWhereInput[]
    OR?: RelTeamCoachWhereInput[]
    NOT?: RelTeamCoachWhereInput | RelTeamCoachWhereInput[]
    id?: DecimalFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    coachId?: DecimalFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    status?: StringFilter<"RelTeamCoach"> | string
    coachTypeId?: BigIntNullableFilter<"RelTeamCoach"> | bigint | number | null
    salary?: DecimalNullableFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    responsibilities?: StringNullableFilter<"RelTeamCoach"> | string | null
    notes?: StringNullableFilter<"RelTeamCoach"> | string | null
    ord?: IntFilter<"RelTeamCoach"> | number
    createdAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
  }

  export type RelTeamCoachOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    coachTypeId?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    responsibilities?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelTeamCoachOrderByRelevanceInput
  }

  export type RelTeamCoachWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    teamId_coachId?: RelTeamCoachTeamIdCoachIdCompoundUniqueInput
    AND?: RelTeamCoachWhereInput | RelTeamCoachWhereInput[]
    OR?: RelTeamCoachWhereInput[]
    NOT?: RelTeamCoachWhereInput | RelTeamCoachWhereInput[]
    teamId?: DecimalFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    coachId?: DecimalFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    status?: StringFilter<"RelTeamCoach"> | string
    coachTypeId?: BigIntNullableFilter<"RelTeamCoach"> | bigint | number | null
    salary?: DecimalNullableFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    responsibilities?: StringNullableFilter<"RelTeamCoach"> | string | null
    notes?: StringNullableFilter<"RelTeamCoach"> | string | null
    ord?: IntFilter<"RelTeamCoach"> | number
    createdAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelTeamCoach"> | Date | string | null
  }, "id" | "teamId_coachId">

  export type RelTeamCoachOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    coachTypeId?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    responsibilities?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelTeamCoachCountOrderByAggregateInput
    _avg?: RelTeamCoachAvgOrderByAggregateInput
    _max?: RelTeamCoachMaxOrderByAggregateInput
    _min?: RelTeamCoachMinOrderByAggregateInput
    _sum?: RelTeamCoachSumOrderByAggregateInput
  }

  export type RelTeamCoachScalarWhereWithAggregatesInput = {
    AND?: RelTeamCoachScalarWhereWithAggregatesInput | RelTeamCoachScalarWhereWithAggregatesInput[]
    OR?: RelTeamCoachScalarWhereWithAggregatesInput[]
    NOT?: RelTeamCoachScalarWhereWithAggregatesInput | RelTeamCoachScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    coachId?: DecimalWithAggregatesFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"RelTeamCoach"> | Date | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"RelTeamCoach"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelTeamCoach"> | string
    coachTypeId?: BigIntNullableWithAggregatesFilter<"RelTeamCoach"> | bigint | number | null
    salary?: DecimalNullableWithAggregatesFilter<"RelTeamCoach"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableWithAggregatesFilter<"RelTeamCoach"> | Date | string | null
    contractEnd?: DateTimeNullableWithAggregatesFilter<"RelTeamCoach"> | Date | string | null
    responsibilities?: StringNullableWithAggregatesFilter<"RelTeamCoach"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RelTeamCoach"> | string | null
    ord?: IntWithAggregatesFilter<"RelTeamCoach"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelTeamCoach"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelTeamCoach"> | Date | string | null
  }

  export type RelTeamPlayerWhereInput = {
    AND?: RelTeamPlayerWhereInput | RelTeamPlayerWhereInput[]
    OR?: RelTeamPlayerWhereInput[]
    NOT?: RelTeamPlayerWhereInput | RelTeamPlayerWhereInput[]
    id?: DecimalFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
    status?: StringFilter<"RelTeamPlayer"> | string
    jerseyNumber?: StringNullableFilter<"RelTeamPlayer"> | string | null
    positionId?: BigIntNullableFilter<"RelTeamPlayer"> | bigint | number | null
    notes?: StringNullableFilter<"RelTeamPlayer"> | string | null
    ord?: IntFilter<"RelTeamPlayer"> | number
    createdAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
  }

  export type RelTeamPlayerOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    jerseyNumber?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelTeamPlayerOrderByRelevanceInput
  }

  export type RelTeamPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    teamId_playerId?: RelTeamPlayerTeamIdPlayerIdCompoundUniqueInput
    AND?: RelTeamPlayerWhereInput | RelTeamPlayerWhereInput[]
    OR?: RelTeamPlayerWhereInput[]
    NOT?: RelTeamPlayerWhereInput | RelTeamPlayerWhereInput[]
    teamId?: DecimalFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
    status?: StringFilter<"RelTeamPlayer"> | string
    jerseyNumber?: StringNullableFilter<"RelTeamPlayer"> | string | null
    positionId?: BigIntNullableFilter<"RelTeamPlayer"> | bigint | number | null
    notes?: StringNullableFilter<"RelTeamPlayer"> | string | null
    ord?: IntFilter<"RelTeamPlayer"> | number
    createdAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelTeamPlayer"> | Date | string | null
  }, "id" | "teamId_playerId">

  export type RelTeamPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    jerseyNumber?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelTeamPlayerCountOrderByAggregateInput
    _avg?: RelTeamPlayerAvgOrderByAggregateInput
    _max?: RelTeamPlayerMaxOrderByAggregateInput
    _min?: RelTeamPlayerMinOrderByAggregateInput
    _sum?: RelTeamPlayerSumOrderByAggregateInput
  }

  export type RelTeamPlayerScalarWhereWithAggregatesInput = {
    AND?: RelTeamPlayerScalarWhereWithAggregatesInput | RelTeamPlayerScalarWhereWithAggregatesInput[]
    OR?: RelTeamPlayerScalarWhereWithAggregatesInput[]
    NOT?: RelTeamPlayerScalarWhereWithAggregatesInput | RelTeamPlayerScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    playerId?: DecimalWithAggregatesFilter<"RelTeamPlayer"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"RelTeamPlayer"> | Date | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"RelTeamPlayer"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelTeamPlayer"> | string
    jerseyNumber?: StringNullableWithAggregatesFilter<"RelTeamPlayer"> | string | null
    positionId?: BigIntNullableWithAggregatesFilter<"RelTeamPlayer"> | bigint | number | null
    notes?: StringNullableWithAggregatesFilter<"RelTeamPlayer"> | string | null
    ord?: IntWithAggregatesFilter<"RelTeamPlayer"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelTeamPlayer"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelTeamPlayer"> | Date | string | null
  }

  export type RelTeamTeamManagerWhereInput = {
    AND?: RelTeamTeamManagerWhereInput | RelTeamTeamManagerWhereInput[]
    OR?: RelTeamTeamManagerWhereInput[]
    NOT?: RelTeamTeamManagerWhereInput | RelTeamTeamManagerWhereInput[]
    id?: DecimalFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    managerId?: DecimalFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    status?: StringFilter<"RelTeamTeamManager"> | string
    managerTypeId?: StringNullableFilter<"RelTeamTeamManager"> | string | null
    salary?: DecimalNullableFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    responsibilities?: StringNullableFilter<"RelTeamTeamManager"> | string | null
    notes?: StringNullableFilter<"RelTeamTeamManager"> | string | null
    ord?: IntFilter<"RelTeamTeamManager"> | number
    createdAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
  }

  export type RelTeamTeamManagerOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    managerTypeId?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    responsibilities?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: RelTeamTeamManagerOrderByRelevanceInput
  }

  export type RelTeamTeamManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    teamId_managerId?: RelTeamTeamManagerTeamIdManagerIdCompoundUniqueInput
    AND?: RelTeamTeamManagerWhereInput | RelTeamTeamManagerWhereInput[]
    OR?: RelTeamTeamManagerWhereInput[]
    NOT?: RelTeamTeamManagerWhereInput | RelTeamTeamManagerWhereInput[]
    teamId?: DecimalFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    managerId?: DecimalFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    status?: StringFilter<"RelTeamTeamManager"> | string
    managerTypeId?: StringNullableFilter<"RelTeamTeamManager"> | string | null
    salary?: DecimalNullableFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    contractEnd?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    responsibilities?: StringNullableFilter<"RelTeamTeamManager"> | string | null
    notes?: StringNullableFilter<"RelTeamTeamManager"> | string | null
    ord?: IntFilter<"RelTeamTeamManager"> | number
    createdAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelTeamTeamManager"> | Date | string | null
  }, "id" | "teamId_managerId">

  export type RelTeamTeamManagerOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    status?: SortOrder
    managerTypeId?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    contractStart?: SortOrderInput | SortOrder
    contractEnd?: SortOrderInput | SortOrder
    responsibilities?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RelTeamTeamManagerCountOrderByAggregateInput
    _avg?: RelTeamTeamManagerAvgOrderByAggregateInput
    _max?: RelTeamTeamManagerMaxOrderByAggregateInput
    _min?: RelTeamTeamManagerMinOrderByAggregateInput
    _sum?: RelTeamTeamManagerSumOrderByAggregateInput
  }

  export type RelTeamTeamManagerScalarWhereWithAggregatesInput = {
    AND?: RelTeamTeamManagerScalarWhereWithAggregatesInput | RelTeamTeamManagerScalarWhereWithAggregatesInput[]
    OR?: RelTeamTeamManagerScalarWhereWithAggregatesInput[]
    NOT?: RelTeamTeamManagerScalarWhereWithAggregatesInput | RelTeamTeamManagerScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    managerId?: DecimalWithAggregatesFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"RelTeamTeamManager"> | Date | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"RelTeamTeamManager"> | Date | string | null
    status?: StringWithAggregatesFilter<"RelTeamTeamManager"> | string
    managerTypeId?: StringNullableWithAggregatesFilter<"RelTeamTeamManager"> | string | null
    salary?: DecimalNullableWithAggregatesFilter<"RelTeamTeamManager"> | Decimal | DecimalJsLike | number | string | null
    contractStart?: DateTimeNullableWithAggregatesFilter<"RelTeamTeamManager"> | Date | string | null
    contractEnd?: DateTimeNullableWithAggregatesFilter<"RelTeamTeamManager"> | Date | string | null
    responsibilities?: StringNullableWithAggregatesFilter<"RelTeamTeamManager"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RelTeamTeamManager"> | string | null
    ord?: IntWithAggregatesFilter<"RelTeamTeamManager"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelTeamTeamManager"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelTeamTeamManager"> | Date | string | null
  }

  export type SportCoachTypeWhereInput = {
    AND?: SportCoachTypeWhereInput | SportCoachTypeWhereInput[]
    OR?: SportCoachTypeWhereInput[]
    NOT?: SportCoachTypeWhereInput | SportCoachTypeWhereInput[]
    id?: DecimalFilter<"SportCoachType"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFilter<"SportCoachType"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportCoachType"> | string
    abbr?: StringFilter<"SportCoachType"> | string
    color?: StringFilter<"SportCoachType"> | string
    note?: StringNullableFilter<"SportCoachType"> | string | null
    isActive?: IntFilter<"SportCoachType"> | number
    ord?: IntFilter<"SportCoachType"> | number
    createdAt?: DateTimeNullableFilter<"SportCoachType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportCoachType"> | Date | string | null
  }

  export type SportCoachTypeOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SportCoachTypeOrderByRelevanceInput
  }

  export type SportCoachTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    sportId_name?: SportCoachTypeSportIdNameCompoundUniqueInput
    AND?: SportCoachTypeWhereInput | SportCoachTypeWhereInput[]
    OR?: SportCoachTypeWhereInput[]
    NOT?: SportCoachTypeWhereInput | SportCoachTypeWhereInput[]
    sportId?: DecimalFilter<"SportCoachType"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportCoachType"> | string
    abbr?: StringFilter<"SportCoachType"> | string
    color?: StringFilter<"SportCoachType"> | string
    note?: StringNullableFilter<"SportCoachType"> | string | null
    isActive?: IntFilter<"SportCoachType"> | number
    ord?: IntFilter<"SportCoachType"> | number
    createdAt?: DateTimeNullableFilter<"SportCoachType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportCoachType"> | Date | string | null
  }, "id" | "sportId_name">

  export type SportCoachTypeOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SportCoachTypeCountOrderByAggregateInput
    _avg?: SportCoachTypeAvgOrderByAggregateInput
    _max?: SportCoachTypeMaxOrderByAggregateInput
    _min?: SportCoachTypeMinOrderByAggregateInput
    _sum?: SportCoachTypeSumOrderByAggregateInput
  }

  export type SportCoachTypeScalarWhereWithAggregatesInput = {
    AND?: SportCoachTypeScalarWhereWithAggregatesInput | SportCoachTypeScalarWhereWithAggregatesInput[]
    OR?: SportCoachTypeScalarWhereWithAggregatesInput[]
    NOT?: SportCoachTypeScalarWhereWithAggregatesInput | SportCoachTypeScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SportCoachType"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalWithAggregatesFilter<"SportCoachType"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SportCoachType"> | string
    abbr?: StringWithAggregatesFilter<"SportCoachType"> | string
    color?: StringWithAggregatesFilter<"SportCoachType"> | string
    note?: StringNullableWithAggregatesFilter<"SportCoachType"> | string | null
    isActive?: IntWithAggregatesFilter<"SportCoachType"> | number
    ord?: IntWithAggregatesFilter<"SportCoachType"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SportCoachType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SportCoachType"> | Date | string | null
  }

  export type SportEventTypeWhereInput = {
    AND?: SportEventTypeWhereInput | SportEventTypeWhereInput[]
    OR?: SportEventTypeWhereInput[]
    NOT?: SportEventTypeWhereInput | SportEventTypeWhereInput[]
    id?: DecimalFilter<"SportEventType"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportEventType"> | string
    abbr?: StringNullableFilter<"SportEventType"> | string | null
    category?: IntNullableFilter<"SportEventType"> | number | null
    evaluationMetric?: IntNullableFilter<"SportEventType"> | number | null
    code?: StringNullableFilter<"SportEventType"> | string | null
    sportId?: DecimalNullableFilter<"SportEventType"> | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntFilter<"SportEventType"> | number
    note?: StringNullableFilter<"SportEventType"> | string | null
    ord?: IntNullableFilter<"SportEventType"> | number | null
    score?: IntFilter<"SportEventType"> | number
    slot?: IntFilter<"SportEventType"> | number
    createdAt?: DateTimeNullableFilter<"SportEventType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportEventType"> | Date | string | null
  }

  export type SportEventTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    evaluationMetric?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    sportId?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    note?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    score?: SortOrder
    slot?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SportEventTypeOrderByRelevanceInput
  }

  export type SportEventTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SportEventTypeWhereInput | SportEventTypeWhereInput[]
    OR?: SportEventTypeWhereInput[]
    NOT?: SportEventTypeWhereInput | SportEventTypeWhereInput[]
    name?: StringFilter<"SportEventType"> | string
    abbr?: StringNullableFilter<"SportEventType"> | string | null
    category?: IntNullableFilter<"SportEventType"> | number | null
    evaluationMetric?: IntNullableFilter<"SportEventType"> | number | null
    code?: StringNullableFilter<"SportEventType"> | string | null
    sportId?: DecimalNullableFilter<"SportEventType"> | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntFilter<"SportEventType"> | number
    note?: StringNullableFilter<"SportEventType"> | string | null
    ord?: IntNullableFilter<"SportEventType"> | number | null
    score?: IntFilter<"SportEventType"> | number
    slot?: IntFilter<"SportEventType"> | number
    createdAt?: DateTimeNullableFilter<"SportEventType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportEventType"> | Date | string | null
  }, "id">

  export type SportEventTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    evaluationMetric?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    sportId?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    note?: SortOrderInput | SortOrder
    ord?: SortOrderInput | SortOrder
    score?: SortOrder
    slot?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SportEventTypeCountOrderByAggregateInput
    _avg?: SportEventTypeAvgOrderByAggregateInput
    _max?: SportEventTypeMaxOrderByAggregateInput
    _min?: SportEventTypeMinOrderByAggregateInput
    _sum?: SportEventTypeSumOrderByAggregateInput
  }

  export type SportEventTypeScalarWhereWithAggregatesInput = {
    AND?: SportEventTypeScalarWhereWithAggregatesInput | SportEventTypeScalarWhereWithAggregatesInput[]
    OR?: SportEventTypeScalarWhereWithAggregatesInput[]
    NOT?: SportEventTypeScalarWhereWithAggregatesInput | SportEventTypeScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SportEventType"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SportEventType"> | string
    abbr?: StringNullableWithAggregatesFilter<"SportEventType"> | string | null
    category?: IntNullableWithAggregatesFilter<"SportEventType"> | number | null
    evaluationMetric?: IntNullableWithAggregatesFilter<"SportEventType"> | number | null
    code?: StringNullableWithAggregatesFilter<"SportEventType"> | string | null
    sportId?: DecimalNullableWithAggregatesFilter<"SportEventType"> | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntWithAggregatesFilter<"SportEventType"> | number
    note?: StringNullableWithAggregatesFilter<"SportEventType"> | string | null
    ord?: IntNullableWithAggregatesFilter<"SportEventType"> | number | null
    score?: IntWithAggregatesFilter<"SportEventType"> | number
    slot?: IntWithAggregatesFilter<"SportEventType"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SportEventType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SportEventType"> | Date | string | null
  }

  export type SportGamePeriodWhereInput = {
    AND?: SportGamePeriodWhereInput | SportGamePeriodWhereInput[]
    OR?: SportGamePeriodWhereInput[]
    NOT?: SportGamePeriodWhereInput | SportGamePeriodWhereInput[]
    id?: DecimalFilter<"SportGamePeriod"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFilter<"SportGamePeriod"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportGamePeriod"> | string
    ord?: IntFilter<"SportGamePeriod"> | number
    duration?: IntNullableFilter<"SportGamePeriod"> | number | null
    note?: StringNullableFilter<"SportGamePeriod"> | string | null
    createdAt?: DateTimeNullableFilter<"SportGamePeriod"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportGamePeriod"> | Date | string | null
  }

  export type SportGamePeriodOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    ord?: SortOrder
    duration?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SportGamePeriodOrderByRelevanceInput
  }

  export type SportGamePeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SportGamePeriodWhereInput | SportGamePeriodWhereInput[]
    OR?: SportGamePeriodWhereInput[]
    NOT?: SportGamePeriodWhereInput | SportGamePeriodWhereInput[]
    sportId?: DecimalFilter<"SportGamePeriod"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportGamePeriod"> | string
    ord?: IntFilter<"SportGamePeriod"> | number
    duration?: IntNullableFilter<"SportGamePeriod"> | number | null
    note?: StringNullableFilter<"SportGamePeriod"> | string | null
    createdAt?: DateTimeNullableFilter<"SportGamePeriod"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportGamePeriod"> | Date | string | null
  }, "id">

  export type SportGamePeriodOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    ord?: SortOrder
    duration?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SportGamePeriodCountOrderByAggregateInput
    _avg?: SportGamePeriodAvgOrderByAggregateInput
    _max?: SportGamePeriodMaxOrderByAggregateInput
    _min?: SportGamePeriodMinOrderByAggregateInput
    _sum?: SportGamePeriodSumOrderByAggregateInput
  }

  export type SportGamePeriodScalarWhereWithAggregatesInput = {
    AND?: SportGamePeriodScalarWhereWithAggregatesInput | SportGamePeriodScalarWhereWithAggregatesInput[]
    OR?: SportGamePeriodScalarWhereWithAggregatesInput[]
    NOT?: SportGamePeriodScalarWhereWithAggregatesInput | SportGamePeriodScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SportGamePeriod"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalWithAggregatesFilter<"SportGamePeriod"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SportGamePeriod"> | string
    ord?: IntWithAggregatesFilter<"SportGamePeriod"> | number
    duration?: IntNullableWithAggregatesFilter<"SportGamePeriod"> | number | null
    note?: StringNullableWithAggregatesFilter<"SportGamePeriod"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"SportGamePeriod"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SportGamePeriod"> | Date | string | null
  }

  export type SportManagerTypeWhereInput = {
    AND?: SportManagerTypeWhereInput | SportManagerTypeWhereInput[]
    OR?: SportManagerTypeWhereInput[]
    NOT?: SportManagerTypeWhereInput | SportManagerTypeWhereInput[]
    id?: DecimalFilter<"SportManagerType"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalNullableFilter<"SportManagerType"> | Decimal | DecimalJsLike | number | string | null
    name?: StringFilter<"SportManagerType"> | string
    abbr?: StringFilter<"SportManagerType"> | string
    color?: StringFilter<"SportManagerType"> | string
    note?: StringNullableFilter<"SportManagerType"> | string | null
    isActive?: IntFilter<"SportManagerType"> | number
    ord?: IntFilter<"SportManagerType"> | number
    createdAt?: DateTimeNullableFilter<"SportManagerType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportManagerType"> | Date | string | null
  }

  export type SportManagerTypeOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrderInput | SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SportManagerTypeOrderByRelevanceInput
  }

  export type SportManagerTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    sportId_name?: SportManagerTypeSportIdNameCompoundUniqueInput
    AND?: SportManagerTypeWhereInput | SportManagerTypeWhereInput[]
    OR?: SportManagerTypeWhereInput[]
    NOT?: SportManagerTypeWhereInput | SportManagerTypeWhereInput[]
    sportId?: DecimalNullableFilter<"SportManagerType"> | Decimal | DecimalJsLike | number | string | null
    name?: StringFilter<"SportManagerType"> | string
    abbr?: StringFilter<"SportManagerType"> | string
    color?: StringFilter<"SportManagerType"> | string
    note?: StringNullableFilter<"SportManagerType"> | string | null
    isActive?: IntFilter<"SportManagerType"> | number
    ord?: IntFilter<"SportManagerType"> | number
    createdAt?: DateTimeNullableFilter<"SportManagerType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportManagerType"> | Date | string | null
  }, "id" | "sportId_name">

  export type SportManagerTypeOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrderInput | SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SportManagerTypeCountOrderByAggregateInput
    _avg?: SportManagerTypeAvgOrderByAggregateInput
    _max?: SportManagerTypeMaxOrderByAggregateInput
    _min?: SportManagerTypeMinOrderByAggregateInput
    _sum?: SportManagerTypeSumOrderByAggregateInput
  }

  export type SportManagerTypeScalarWhereWithAggregatesInput = {
    AND?: SportManagerTypeScalarWhereWithAggregatesInput | SportManagerTypeScalarWhereWithAggregatesInput[]
    OR?: SportManagerTypeScalarWhereWithAggregatesInput[]
    NOT?: SportManagerTypeScalarWhereWithAggregatesInput | SportManagerTypeScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SportManagerType"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalNullableWithAggregatesFilter<"SportManagerType"> | Decimal | DecimalJsLike | number | string | null
    name?: StringWithAggregatesFilter<"SportManagerType"> | string
    abbr?: StringWithAggregatesFilter<"SportManagerType"> | string
    color?: StringWithAggregatesFilter<"SportManagerType"> | string
    note?: StringNullableWithAggregatesFilter<"SportManagerType"> | string | null
    isActive?: IntWithAggregatesFilter<"SportManagerType"> | number
    ord?: IntWithAggregatesFilter<"SportManagerType"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SportManagerType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SportManagerType"> | Date | string | null
  }

  export type SportPlayerPositionWhereInput = {
    AND?: SportPlayerPositionWhereInput | SportPlayerPositionWhereInput[]
    OR?: SportPlayerPositionWhereInput[]
    NOT?: SportPlayerPositionWhereInput | SportPlayerPositionWhereInput[]
    id?: DecimalFilter<"SportPlayerPosition"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportPlayerPosition"> | string
    abbr?: StringFilter<"SportPlayerPosition"> | string
    note?: StringNullableFilter<"SportPlayerPosition"> | string | null
    sportId?: DecimalFilter<"SportPlayerPosition"> | Decimal | DecimalJsLike | number | string
    ord?: IntNullableFilter<"SportPlayerPosition"> | number | null
    createdAt?: DateTimeNullableFilter<"SportPlayerPosition"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportPlayerPosition"> | Date | string | null
  }

  export type SportPlayerPositionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrderInput | SortOrder
    sportId?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SportPlayerPositionOrderByRelevanceInput
  }

  export type SportPlayerPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SportPlayerPositionWhereInput | SportPlayerPositionWhereInput[]
    OR?: SportPlayerPositionWhereInput[]
    NOT?: SportPlayerPositionWhereInput | SportPlayerPositionWhereInput[]
    name?: StringFilter<"SportPlayerPosition"> | string
    abbr?: StringFilter<"SportPlayerPosition"> | string
    note?: StringNullableFilter<"SportPlayerPosition"> | string | null
    sportId?: DecimalFilter<"SportPlayerPosition"> | Decimal | DecimalJsLike | number | string
    ord?: IntNullableFilter<"SportPlayerPosition"> | number | null
    createdAt?: DateTimeNullableFilter<"SportPlayerPosition"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportPlayerPosition"> | Date | string | null
  }, "id">

  export type SportPlayerPositionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrderInput | SortOrder
    sportId?: SortOrder
    ord?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SportPlayerPositionCountOrderByAggregateInput
    _avg?: SportPlayerPositionAvgOrderByAggregateInput
    _max?: SportPlayerPositionMaxOrderByAggregateInput
    _min?: SportPlayerPositionMinOrderByAggregateInput
    _sum?: SportPlayerPositionSumOrderByAggregateInput
  }

  export type SportPlayerPositionScalarWhereWithAggregatesInput = {
    AND?: SportPlayerPositionScalarWhereWithAggregatesInput | SportPlayerPositionScalarWhereWithAggregatesInput[]
    OR?: SportPlayerPositionScalarWhereWithAggregatesInput[]
    NOT?: SportPlayerPositionScalarWhereWithAggregatesInput | SportPlayerPositionScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SportPlayerPosition"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SportPlayerPosition"> | string
    abbr?: StringWithAggregatesFilter<"SportPlayerPosition"> | string
    note?: StringNullableWithAggregatesFilter<"SportPlayerPosition"> | string | null
    sportId?: DecimalWithAggregatesFilter<"SportPlayerPosition"> | Decimal | DecimalJsLike | number | string
    ord?: IntNullableWithAggregatesFilter<"SportPlayerPosition"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"SportPlayerPosition"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SportPlayerPosition"> | Date | string | null
  }

  export type SportRefereeTypeWhereInput = {
    AND?: SportRefereeTypeWhereInput | SportRefereeTypeWhereInput[]
    OR?: SportRefereeTypeWhereInput[]
    NOT?: SportRefereeTypeWhereInput | SportRefereeTypeWhereInput[]
    id?: DecimalFilter<"SportRefereeType"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFilter<"SportRefereeType"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportRefereeType"> | string
    abbr?: StringFilter<"SportRefereeType"> | string
    color?: StringFilter<"SportRefereeType"> | string
    note?: StringNullableFilter<"SportRefereeType"> | string | null
    isActive?: IntFilter<"SportRefereeType"> | number
    ord?: IntFilter<"SportRefereeType"> | number
    createdAt?: DateTimeNullableFilter<"SportRefereeType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportRefereeType"> | Date | string | null
  }

  export type SportRefereeTypeOrderByWithRelationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SportRefereeTypeOrderByRelevanceInput
  }

  export type SportRefereeTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    sportId_name?: SportRefereeTypeSportIdNameCompoundUniqueInput
    AND?: SportRefereeTypeWhereInput | SportRefereeTypeWhereInput[]
    OR?: SportRefereeTypeWhereInput[]
    NOT?: SportRefereeTypeWhereInput | SportRefereeTypeWhereInput[]
    sportId?: DecimalFilter<"SportRefereeType"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SportRefereeType"> | string
    abbr?: StringFilter<"SportRefereeType"> | string
    color?: StringFilter<"SportRefereeType"> | string
    note?: StringNullableFilter<"SportRefereeType"> | string | null
    isActive?: IntFilter<"SportRefereeType"> | number
    ord?: IntFilter<"SportRefereeType"> | number
    createdAt?: DateTimeNullableFilter<"SportRefereeType"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SportRefereeType"> | Date | string | null
  }, "id" | "sportId_name">

  export type SportRefereeTypeOrderByWithAggregationInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SportRefereeTypeCountOrderByAggregateInput
    _avg?: SportRefereeTypeAvgOrderByAggregateInput
    _max?: SportRefereeTypeMaxOrderByAggregateInput
    _min?: SportRefereeTypeMinOrderByAggregateInput
    _sum?: SportRefereeTypeSumOrderByAggregateInput
  }

  export type SportRefereeTypeScalarWhereWithAggregatesInput = {
    AND?: SportRefereeTypeScalarWhereWithAggregatesInput | SportRefereeTypeScalarWhereWithAggregatesInput[]
    OR?: SportRefereeTypeScalarWhereWithAggregatesInput[]
    NOT?: SportRefereeTypeScalarWhereWithAggregatesInput | SportRefereeTypeScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SportRefereeType"> | Decimal | DecimalJsLike | number | string
    sportId?: DecimalWithAggregatesFilter<"SportRefereeType"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SportRefereeType"> | string
    abbr?: StringWithAggregatesFilter<"SportRefereeType"> | string
    color?: StringWithAggregatesFilter<"SportRefereeType"> | string
    note?: StringNullableWithAggregatesFilter<"SportRefereeType"> | string | null
    isActive?: IntWithAggregatesFilter<"SportRefereeType"> | number
    ord?: IntWithAggregatesFilter<"SportRefereeType"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SportRefereeType"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SportRefereeType"> | Date | string | null
  }

  export type SubFeatureWhereInput = {
    AND?: SubFeatureWhereInput | SubFeatureWhereInput[]
    OR?: SubFeatureWhereInput[]
    NOT?: SubFeatureWhereInput | SubFeatureWhereInput[]
    id?: DecimalFilter<"SubFeature"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SubFeature"> | string
    description?: StringNullableFilter<"SubFeature"> | string | null
    category?: StringNullableFilter<"SubFeature"> | string | null
    icon?: StringNullableFilter<"SubFeature"> | string | null
    isActive?: IntFilter<"SubFeature"> | number
    ord?: IntFilter<"SubFeature"> | number
    createdAt?: DateTimeNullableFilter<"SubFeature"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubFeature"> | Date | string | null
  }

  export type SubFeatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SubFeatureOrderByRelevanceInput
  }

  export type SubFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SubFeatureWhereInput | SubFeatureWhereInput[]
    OR?: SubFeatureWhereInput[]
    NOT?: SubFeatureWhereInput | SubFeatureWhereInput[]
    name?: StringFilter<"SubFeature"> | string
    description?: StringNullableFilter<"SubFeature"> | string | null
    category?: StringNullableFilter<"SubFeature"> | string | null
    icon?: StringNullableFilter<"SubFeature"> | string | null
    isActive?: IntFilter<"SubFeature"> | number
    ord?: IntFilter<"SubFeature"> | number
    createdAt?: DateTimeNullableFilter<"SubFeature"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubFeature"> | Date | string | null
  }, "id">

  export type SubFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SubFeatureCountOrderByAggregateInput
    _avg?: SubFeatureAvgOrderByAggregateInput
    _max?: SubFeatureMaxOrderByAggregateInput
    _min?: SubFeatureMinOrderByAggregateInput
    _sum?: SubFeatureSumOrderByAggregateInput
  }

  export type SubFeatureScalarWhereWithAggregatesInput = {
    AND?: SubFeatureScalarWhereWithAggregatesInput | SubFeatureScalarWhereWithAggregatesInput[]
    OR?: SubFeatureScalarWhereWithAggregatesInput[]
    NOT?: SubFeatureScalarWhereWithAggregatesInput | SubFeatureScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SubFeature"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SubFeature"> | string
    description?: StringNullableWithAggregatesFilter<"SubFeature"> | string | null
    category?: StringNullableWithAggregatesFilter<"SubFeature"> | string | null
    icon?: StringNullableWithAggregatesFilter<"SubFeature"> | string | null
    isActive?: IntWithAggregatesFilter<"SubFeature"> | number
    ord?: IntWithAggregatesFilter<"SubFeature"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SubFeature"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SubFeature"> | Date | string | null
  }

  export type SubForTeamWhereInput = {
    AND?: SubForTeamWhereInput | SubForTeamWhereInput[]
    OR?: SubForTeamWhereInput[]
    NOT?: SubForTeamWhereInput | SubForTeamWhereInput[]
    id?: DecimalFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubForTeam"> | string
    startedAt?: DateTimeFilter<"SubForTeam"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    autoRenew?: IntFilter<"SubForTeam"> | number
    paymentMethod?: StringNullableFilter<"SubForTeam"> | string | null
    lastPaymentAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    nextPaymentAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    notes?: StringNullableFilter<"SubForTeam"> | string | null
    ord?: IntFilter<"SubForTeam"> | number
    createdAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
  }

  export type SubForTeamOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    lastPaymentAt?: SortOrderInput | SortOrder
    nextPaymentAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SubForTeamOrderByRelevanceInput
  }

  export type SubForTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SubForTeamWhereInput | SubForTeamWhereInput[]
    OR?: SubForTeamWhereInput[]
    NOT?: SubForTeamWhereInput | SubForTeamWhereInput[]
    teamId?: DecimalFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubForTeam"> | string
    startedAt?: DateTimeFilter<"SubForTeam"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    autoRenew?: IntFilter<"SubForTeam"> | number
    paymentMethod?: StringNullableFilter<"SubForTeam"> | string | null
    lastPaymentAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    nextPaymentAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    notes?: StringNullableFilter<"SubForTeam"> | string | null
    ord?: IntFilter<"SubForTeam"> | number
    createdAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubForTeam"> | Date | string | null
  }, "id">

  export type SubForTeamOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    lastPaymentAt?: SortOrderInput | SortOrder
    nextPaymentAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SubForTeamCountOrderByAggregateInput
    _avg?: SubForTeamAvgOrderByAggregateInput
    _max?: SubForTeamMaxOrderByAggregateInput
    _min?: SubForTeamMinOrderByAggregateInput
    _sum?: SubForTeamSumOrderByAggregateInput
  }

  export type SubForTeamScalarWhereWithAggregatesInput = {
    AND?: SubForTeamScalarWhereWithAggregatesInput | SubForTeamScalarWhereWithAggregatesInput[]
    OR?: SubForTeamScalarWhereWithAggregatesInput[]
    NOT?: SubForTeamScalarWhereWithAggregatesInput | SubForTeamScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    teamId?: DecimalWithAggregatesFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalWithAggregatesFilter<"SubForTeam"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"SubForTeam"> | string
    startedAt?: DateTimeWithAggregatesFilter<"SubForTeam"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SubForTeam"> | Date | string | null
    autoRenew?: IntWithAggregatesFilter<"SubForTeam"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"SubForTeam"> | string | null
    lastPaymentAt?: DateTimeNullableWithAggregatesFilter<"SubForTeam"> | Date | string | null
    nextPaymentAt?: DateTimeNullableWithAggregatesFilter<"SubForTeam"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"SubForTeam"> | string | null
    ord?: IntWithAggregatesFilter<"SubForTeam"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SubForTeam"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SubForTeam"> | Date | string | null
  }

  export type SubForUserWhereInput = {
    AND?: SubForUserWhereInput | SubForUserWhereInput[]
    OR?: SubForUserWhereInput[]
    NOT?: SubForUserWhereInput | SubForUserWhereInput[]
    id?: DecimalFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    userId?: DecimalFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubForUser"> | string
    startedAt?: DateTimeFilter<"SubForUser"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    autoRenew?: IntFilter<"SubForUser"> | number
    paymentMethod?: StringNullableFilter<"SubForUser"> | string | null
    lastPaymentAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    nextPaymentAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    notes?: StringNullableFilter<"SubForUser"> | string | null
    ord?: IntFilter<"SubForUser"> | number
    createdAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
  }

  export type SubForUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    lastPaymentAt?: SortOrderInput | SortOrder
    nextPaymentAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SubForUserOrderByRelevanceInput
  }

  export type SubForUserWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SubForUserWhereInput | SubForUserWhereInput[]
    OR?: SubForUserWhereInput[]
    NOT?: SubForUserWhereInput | SubForUserWhereInput[]
    userId?: DecimalFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"SubForUser"> | string
    startedAt?: DateTimeFilter<"SubForUser"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    autoRenew?: IntFilter<"SubForUser"> | number
    paymentMethod?: StringNullableFilter<"SubForUser"> | string | null
    lastPaymentAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    nextPaymentAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    notes?: StringNullableFilter<"SubForUser"> | string | null
    ord?: IntFilter<"SubForUser"> | number
    createdAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubForUser"> | Date | string | null
  }, "id">

  export type SubForUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    lastPaymentAt?: SortOrderInput | SortOrder
    nextPaymentAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SubForUserCountOrderByAggregateInput
    _avg?: SubForUserAvgOrderByAggregateInput
    _max?: SubForUserMaxOrderByAggregateInput
    _min?: SubForUserMinOrderByAggregateInput
    _sum?: SubForUserSumOrderByAggregateInput
  }

  export type SubForUserScalarWhereWithAggregatesInput = {
    AND?: SubForUserScalarWhereWithAggregatesInput | SubForUserScalarWhereWithAggregatesInput[]
    OR?: SubForUserScalarWhereWithAggregatesInput[]
    NOT?: SubForUserScalarWhereWithAggregatesInput | SubForUserScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    userId?: DecimalWithAggregatesFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalWithAggregatesFilter<"SubForUser"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"SubForUser"> | string
    startedAt?: DateTimeWithAggregatesFilter<"SubForUser"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SubForUser"> | Date | string | null
    autoRenew?: IntWithAggregatesFilter<"SubForUser"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"SubForUser"> | string | null
    lastPaymentAt?: DateTimeNullableWithAggregatesFilter<"SubForUser"> | Date | string | null
    nextPaymentAt?: DateTimeNullableWithAggregatesFilter<"SubForUser"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"SubForUser"> | string | null
    ord?: IntWithAggregatesFilter<"SubForUser"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SubForUser"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SubForUser"> | Date | string | null
  }

  export type SubPlanWhereInput = {
    AND?: SubPlanWhereInput | SubPlanWhereInput[]
    OR?: SubPlanWhereInput[]
    NOT?: SubPlanWhereInput | SubPlanWhereInput[]
    id?: DecimalFilter<"SubPlan"> | Decimal | DecimalJsLike | number | string
    name?: StringFilter<"SubPlan"> | string
    planType?: StringFilter<"SubPlan"> | string
    price?: DecimalFilter<"SubPlan"> | Decimal | DecimalJsLike | number | string
    isPopular?: IntFilter<"SubPlan"> | number
    description?: StringNullableFilter<"SubPlan"> | string | null
    features?: StringNullableFilter<"SubPlan"> | string | null
    maxTeams?: IntNullableFilter<"SubPlan"> | number | null
    maxPlayers?: IntNullableFilter<"SubPlan"> | number | null
    maxCoaches?: IntNullableFilter<"SubPlan"> | number | null
    maxReferees?: IntNullableFilter<"SubPlan"> | number | null
    storageLimitGb?: IntNullableFilter<"SubPlan"> | number | null
    isActive?: IntFilter<"SubPlan"> | number
    ord?: IntFilter<"SubPlan"> | number
    createdAt?: DateTimeNullableFilter<"SubPlan"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubPlan"> | Date | string | null
  }

  export type SubPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    planType?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    description?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    maxTeams?: SortOrderInput | SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    maxCoaches?: SortOrderInput | SortOrder
    maxReferees?: SortOrderInput | SortOrder
    storageLimitGb?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SubPlanOrderByRelevanceInput
  }

  export type SubPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    AND?: SubPlanWhereInput | SubPlanWhereInput[]
    OR?: SubPlanWhereInput[]
    NOT?: SubPlanWhereInput | SubPlanWhereInput[]
    name?: StringFilter<"SubPlan"> | string
    planType?: StringFilter<"SubPlan"> | string
    price?: DecimalFilter<"SubPlan"> | Decimal | DecimalJsLike | number | string
    isPopular?: IntFilter<"SubPlan"> | number
    description?: StringNullableFilter<"SubPlan"> | string | null
    features?: StringNullableFilter<"SubPlan"> | string | null
    maxTeams?: IntNullableFilter<"SubPlan"> | number | null
    maxPlayers?: IntNullableFilter<"SubPlan"> | number | null
    maxCoaches?: IntNullableFilter<"SubPlan"> | number | null
    maxReferees?: IntNullableFilter<"SubPlan"> | number | null
    storageLimitGb?: IntNullableFilter<"SubPlan"> | number | null
    isActive?: IntFilter<"SubPlan"> | number
    ord?: IntFilter<"SubPlan"> | number
    createdAt?: DateTimeNullableFilter<"SubPlan"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubPlan"> | Date | string | null
  }, "id">

  export type SubPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    planType?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    description?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    maxTeams?: SortOrderInput | SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    maxCoaches?: SortOrderInput | SortOrder
    maxReferees?: SortOrderInput | SortOrder
    storageLimitGb?: SortOrderInput | SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SubPlanCountOrderByAggregateInput
    _avg?: SubPlanAvgOrderByAggregateInput
    _max?: SubPlanMaxOrderByAggregateInput
    _min?: SubPlanMinOrderByAggregateInput
    _sum?: SubPlanSumOrderByAggregateInput
  }

  export type SubPlanScalarWhereWithAggregatesInput = {
    AND?: SubPlanScalarWhereWithAggregatesInput | SubPlanScalarWhereWithAggregatesInput[]
    OR?: SubPlanScalarWhereWithAggregatesInput[]
    NOT?: SubPlanScalarWhereWithAggregatesInput | SubPlanScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SubPlan"> | Decimal | DecimalJsLike | number | string
    name?: StringWithAggregatesFilter<"SubPlan"> | string
    planType?: StringWithAggregatesFilter<"SubPlan"> | string
    price?: DecimalWithAggregatesFilter<"SubPlan"> | Decimal | DecimalJsLike | number | string
    isPopular?: IntWithAggregatesFilter<"SubPlan"> | number
    description?: StringNullableWithAggregatesFilter<"SubPlan"> | string | null
    features?: StringNullableWithAggregatesFilter<"SubPlan"> | string | null
    maxTeams?: IntNullableWithAggregatesFilter<"SubPlan"> | number | null
    maxPlayers?: IntNullableWithAggregatesFilter<"SubPlan"> | number | null
    maxCoaches?: IntNullableWithAggregatesFilter<"SubPlan"> | number | null
    maxReferees?: IntNullableWithAggregatesFilter<"SubPlan"> | number | null
    storageLimitGb?: IntNullableWithAggregatesFilter<"SubPlan"> | number | null
    isActive?: IntWithAggregatesFilter<"SubPlan"> | number
    ord?: IntWithAggregatesFilter<"SubPlan"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SubPlan"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SubPlan"> | Date | string | null
  }

  export type SubPlanFeatureWhereInput = {
    AND?: SubPlanFeatureWhereInput | SubPlanFeatureWhereInput[]
    OR?: SubPlanFeatureWhereInput[]
    NOT?: SubPlanFeatureWhereInput | SubPlanFeatureWhereInput[]
    id?: DecimalFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    featureId?: DecimalFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    isIncluded?: IntFilter<"SubPlanFeature"> | number
    notes?: StringNullableFilter<"SubPlanFeature"> | string | null
    ord?: IntFilter<"SubPlanFeature"> | number
    createdAt?: DateTimeNullableFilter<"SubPlanFeature"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubPlanFeature"> | Date | string | null
  }

  export type SubPlanFeatureOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SubPlanFeatureOrderByRelevanceInput
  }

  export type SubPlanFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    planId_featureId?: SubPlanFeaturePlanIdFeatureIdCompoundUniqueInput
    AND?: SubPlanFeatureWhereInput | SubPlanFeatureWhereInput[]
    OR?: SubPlanFeatureWhereInput[]
    NOT?: SubPlanFeatureWhereInput | SubPlanFeatureWhereInput[]
    planId?: DecimalFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    featureId?: DecimalFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    isIncluded?: IntFilter<"SubPlanFeature"> | number
    notes?: StringNullableFilter<"SubPlanFeature"> | string | null
    ord?: IntFilter<"SubPlanFeature"> | number
    createdAt?: DateTimeNullableFilter<"SubPlanFeature"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SubPlanFeature"> | Date | string | null
  }, "id" | "planId_featureId">

  export type SubPlanFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    notes?: SortOrderInput | SortOrder
    ord?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SubPlanFeatureCountOrderByAggregateInput
    _avg?: SubPlanFeatureAvgOrderByAggregateInput
    _max?: SubPlanFeatureMaxOrderByAggregateInput
    _min?: SubPlanFeatureMinOrderByAggregateInput
    _sum?: SubPlanFeatureSumOrderByAggregateInput
  }

  export type SubPlanFeatureScalarWhereWithAggregatesInput = {
    AND?: SubPlanFeatureScalarWhereWithAggregatesInput | SubPlanFeatureScalarWhereWithAggregatesInput[]
    OR?: SubPlanFeatureScalarWhereWithAggregatesInput[]
    NOT?: SubPlanFeatureScalarWhereWithAggregatesInput | SubPlanFeatureScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    planId?: DecimalWithAggregatesFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    featureId?: DecimalWithAggregatesFilter<"SubPlanFeature"> | Decimal | DecimalJsLike | number | string
    isIncluded?: IntWithAggregatesFilter<"SubPlanFeature"> | number
    notes?: StringNullableWithAggregatesFilter<"SubPlanFeature"> | string | null
    ord?: IntWithAggregatesFilter<"SubPlanFeature"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"SubPlanFeature"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SubPlanFeature"> | Date | string | null
  }

  export type SysUserWhereInput = {
    AND?: SysUserWhereInput | SysUserWhereInput[]
    OR?: SysUserWhereInput[]
    NOT?: SysUserWhereInput | SysUserWhereInput[]
    id?: DecimalFilter<"SysUser"> | Decimal | DecimalJsLike | number | string
    firstName?: StringFilter<"SysUser"> | string
    lastName?: StringFilter<"SysUser"> | string
    email?: StringFilter<"SysUser"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"SysUser"> | Date | string | null
    password?: StringFilter<"SysUser"> | string
    status?: StringFilter<"SysUser"> | string
    personId?: DecimalNullableFilter<"SysUser"> | Decimal | DecimalJsLike | number | string | null
    rememberToken?: StringNullableFilter<"SysUser"> | string | null
    createdAt?: DateTimeNullableFilter<"SysUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SysUser"> | Date | string | null
  }

  export type SysUserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    personId?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: SysUserOrderByRelevanceInput
  }

  export type SysUserWhereUniqueInput = Prisma.AtLeast<{
    id?: Decimal | DecimalJsLike | number | string
    email?: string
    AND?: SysUserWhereInput | SysUserWhereInput[]
    OR?: SysUserWhereInput[]
    NOT?: SysUserWhereInput | SysUserWhereInput[]
    firstName?: StringFilter<"SysUser"> | string
    lastName?: StringFilter<"SysUser"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"SysUser"> | Date | string | null
    password?: StringFilter<"SysUser"> | string
    status?: StringFilter<"SysUser"> | string
    personId?: DecimalNullableFilter<"SysUser"> | Decimal | DecimalJsLike | number | string | null
    rememberToken?: StringNullableFilter<"SysUser"> | string | null
    createdAt?: DateTimeNullableFilter<"SysUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"SysUser"> | Date | string | null
  }, "id" | "email">

  export type SysUserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    personId?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SysUserCountOrderByAggregateInput
    _avg?: SysUserAvgOrderByAggregateInput
    _max?: SysUserMaxOrderByAggregateInput
    _min?: SysUserMinOrderByAggregateInput
    _sum?: SysUserSumOrderByAggregateInput
  }

  export type SysUserScalarWhereWithAggregatesInput = {
    AND?: SysUserScalarWhereWithAggregatesInput | SysUserScalarWhereWithAggregatesInput[]
    OR?: SysUserScalarWhereWithAggregatesInput[]
    NOT?: SysUserScalarWhereWithAggregatesInput | SysUserScalarWhereWithAggregatesInput[]
    id?: DecimalWithAggregatesFilter<"SysUser"> | Decimal | DecimalJsLike | number | string
    firstName?: StringWithAggregatesFilter<"SysUser"> | string
    lastName?: StringWithAggregatesFilter<"SysUser"> | string
    email?: StringWithAggregatesFilter<"SysUser"> | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"SysUser"> | Date | string | null
    password?: StringWithAggregatesFilter<"SysUser"> | string
    status?: StringWithAggregatesFilter<"SysUser"> | string
    personId?: DecimalNullableWithAggregatesFilter<"SysUser"> | Decimal | DecimalJsLike | number | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"SysUser"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"SysUser"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"SysUser"> | Date | string | null
  }

  export type BaseCompetitionCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BaseCompetitionUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BaseCompetitionUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseCompetitionUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseCompetitionCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BaseCompetitionUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseCompetitionUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseCountryCreateInput = {
    name: string
    abbr?: string | null
    code?: string | null
    note?: string | null
    isActive?: boolean
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseCountryUncheckedCreateInput = {
    id?: number
    name: string
    abbr?: string | null
    code?: string | null
    note?: string | null
    isActive?: boolean
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseCountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseCountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseCountryCreateManyInput = {
    id?: number
    name: string
    abbr?: string | null
    code?: string | null
    note?: string | null
    isActive?: boolean
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseCountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseCountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseFieldCreateInput = {
    name: string
    abbr?: string | null
    note?: string | null
    isActive?: boolean
    sportIds?: BaseFieldCreatesportIdsInput | number[]
    countryId?: number | null
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseFieldUncheckedCreateInput = {
    id?: number
    name: string
    abbr?: string | null
    note?: string | null
    isActive?: boolean
    sportIds?: BaseFieldCreatesportIdsInput | number[]
    countryId?: number | null
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseFieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sportIds?: BaseFieldUpdatesportIdsInput | number[]
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sportIds?: BaseFieldUpdatesportIdsInput | number[]
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseFieldCreateManyInput = {
    id?: number
    name: string
    abbr?: string | null
    note?: string | null
    isActive?: boolean
    sportIds?: BaseFieldCreatesportIdsInput | number[]
    countryId?: number | null
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseFieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sportIds?: BaseFieldUpdatesportIdsInput | number[]
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sportIds?: BaseFieldUpdatesportIdsInput | number[]
    countryId?: NullableIntFieldUpdateOperationsInput | number | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseGroupLevelCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    note?: string | null
    minAge?: number | null
    maxAge?: number | null
    skillLevel?: string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BaseGroupLevelUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    note?: string | null
    minAge?: number | null
    maxAge?: number | null
    skillLevel?: string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BaseGroupLevelUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseGroupLevelUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseGroupLevelCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    note?: string | null
    minAge?: number | null
    maxAge?: number | null
    skillLevel?: string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BaseGroupLevelUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseGroupLevelUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BaseSportCreateInput = {
    name: string
    abbr?: string | null
    note?: string | null
    isActive?: boolean
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseSportUncheckedCreateInput = {
    id?: number
    name: string
    abbr?: string | null
    note?: string | null
    isActive?: boolean
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseSportUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseSportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseSportCreateManyInput = {
    id?: number
    name: string
    abbr?: string | null
    note?: string | null
    isActive?: boolean
    ord?: number
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BaseSportUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaseSportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameEventCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    competitionId?: Decimal | DecimalJsLike | number | string | null
    eventDate: Date | string
    venue?: string | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameEventUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    competitionId?: Decimal | DecimalJsLike | number | string | null
    eventDate: Date | string
    venue?: string | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameEventUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    competitionId?: Decimal | DecimalJsLike | number | string | null
    eventDate: Date | string
    venue?: string | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameEventUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameEventUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameMatcheCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    eventId: Decimal | DecimalJsLike | number | string
    homeTeamId: Decimal | DecimalJsLike | number | string
    awayTeamId: Decimal | DecimalJsLike | number | string
    homeTeamScore?: number | null
    awayTeamScore?: number | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameMatcheUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    eventId: Decimal | DecimalJsLike | number | string
    homeTeamId: Decimal | DecimalJsLike | number | string
    awayTeamId: Decimal | DecimalJsLike | number | string
    homeTeamScore?: number | null
    awayTeamScore?: number | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameMatcheUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eventId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameMatcheUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eventId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameMatcheCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    eventId: Decimal | DecimalJsLike | number | string
    homeTeamId: Decimal | DecimalJsLike | number | string
    awayTeamId: Decimal | DecimalJsLike | number | string
    homeTeamScore?: number | null
    awayTeamScore?: number | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameMatcheUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eventId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameMatcheUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    eventId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    awayTeamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    homeTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    awayTeamScore?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchEventCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId?: Decimal | DecimalJsLike | number | string | null
    teamId?: Decimal | DecimalJsLike | number | string | null
    eventType: string
    minute: number
    second: number
    description?: string | null
    eventData?: string | null
    fieldX?: Decimal | DecimalJsLike | number | string | null
    fieldY?: Decimal | DecimalJsLike | number | string | null
    isConfirmed: number
    createdBy?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchEventUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId?: Decimal | DecimalJsLike | number | string | null
    teamId?: Decimal | DecimalJsLike | number | string | null
    eventType: string
    minute: number
    second: number
    description?: string | null
    eventData?: string | null
    fieldX?: Decimal | DecimalJsLike | number | string | null
    fieldY?: Decimal | DecimalJsLike | number | string | null
    isConfirmed: number
    createdBy?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchEventUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    minute?: IntFieldUpdateOperationsInput | number
    second?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    fieldX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fieldY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchEventUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    minute?: IntFieldUpdateOperationsInput | number
    second?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    fieldX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fieldY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchEventCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId?: Decimal | DecimalJsLike | number | string | null
    teamId?: Decimal | DecimalJsLike | number | string | null
    eventType: string
    minute: number
    second: number
    description?: string | null
    eventData?: string | null
    fieldX?: Decimal | DecimalJsLike | number | string | null
    fieldY?: Decimal | DecimalJsLike | number | string | null
    isConfirmed: number
    createdBy?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchEventUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    minute?: IntFieldUpdateOperationsInput | number
    second?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    fieldX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fieldY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchEventUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    minute?: IntFieldUpdateOperationsInput | number
    second?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    fieldX?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fieldY?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchLineupCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    formation?: string | null
    lineupData?: string | null
    announcedAt?: Date | string | null
    isConfirmed: number
    createdBy?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchLineupUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    formation?: string | null
    lineupData?: string | null
    announcedAt?: Date | string | null
    isConfirmed: number
    createdBy?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchLineupUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    lineupData?: NullableStringFieldUpdateOperationsInput | string | null
    announcedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchLineupUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    lineupData?: NullableStringFieldUpdateOperationsInput | string | null
    announcedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchLineupCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    formation?: string | null
    lineupData?: string | null
    announcedAt?: Date | string | null
    isConfirmed: number
    createdBy?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchLineupUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    lineupData?: NullableStringFieldUpdateOperationsInput | string | null
    announcedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchLineupUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    formation?: NullableStringFieldUpdateOperationsInput | string | null
    lineupData?: NullableStringFieldUpdateOperationsInput | string | null
    announcedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchMediaCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    mediaType: string
    fileName: string
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    description?: string | null
    category?: string | null
    isPublic: number
    uploadedBy?: Decimal | DecimalJsLike | number | string | null
    uploadedAt: Date | string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchMediaUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    mediaType: string
    fileName: string
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    description?: string | null
    category?: string | null
    isPublic: number
    uploadedBy?: Decimal | DecimalJsLike | number | string | null
    uploadedAt: Date | string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchMediaUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mediaType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchMediaUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mediaType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchMediaCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    mediaType: string
    fileName: string
    filePath: string
    fileSize?: bigint | number | null
    mimeType?: string | null
    description?: string | null
    category?: string | null
    isPublic: number
    uploadedBy?: Decimal | DecimalJsLike | number | string | null
    uploadedAt: Date | string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchMediaUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mediaType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchMediaUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    mediaType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchRosterCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    isStarting: number
    isSubstitute: number
    position?: string | null
    jerseyNumber?: string | null
    substitutionInMinute?: number | null
    substitutionOutMinute?: number | null
    substitutionReason?: string | null
    minutesPlayed?: number | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchRosterUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    isStarting: number
    isSubstitute: number
    position?: string | null
    jerseyNumber?: string | null
    substitutionInMinute?: number | null
    substitutionOutMinute?: number | null
    substitutionReason?: string | null
    minutesPlayed?: number | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchRosterUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isStarting?: IntFieldUpdateOperationsInput | number
    isSubstitute?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    substitutionInMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionOutMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionReason?: NullableStringFieldUpdateOperationsInput | string | null
    minutesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchRosterUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isStarting?: IntFieldUpdateOperationsInput | number
    isSubstitute?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    substitutionInMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionOutMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionReason?: NullableStringFieldUpdateOperationsInput | string | null
    minutesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchRosterCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    isStarting: number
    isSubstitute: number
    position?: string | null
    jerseyNumber?: string | null
    substitutionInMinute?: number | null
    substitutionOutMinute?: number | null
    substitutionReason?: string | null
    minutesPlayed?: number | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchRosterUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isStarting?: IntFieldUpdateOperationsInput | number
    isSubstitute?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    substitutionInMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionOutMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionReason?: NullableStringFieldUpdateOperationsInput | string | null
    minutesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchRosterUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isStarting?: IntFieldUpdateOperationsInput | number
    isSubstitute?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    substitutionInMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionOutMinute?: NullableIntFieldUpdateOperationsInput | number | null
    substitutionReason?: NullableStringFieldUpdateOperationsInput | string | null
    minutesPlayed?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchStatisticCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    minutesPlayed: number
    goals: number
    assists: number
    shots: number
    shots_on_target: number
    passes: number
    passesCompleted: number
    passAccuracy: Decimal | DecimalJsLike | number | string
    tackles: number
    interceptions: number
    clearances: number
    blocks: number
    yellowCards: number
    redCards: number
    foulsCommitted: number
    foulsWon: number
    saves: number
    goalsConceded: number
    cleanSheets: number
    rating?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchStatisticUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    minutesPlayed: number
    goals: number
    assists: number
    shots: number
    shots_on_target: number
    passes: number
    passesCompleted: number
    passAccuracy: Decimal | DecimalJsLike | number | string
    tackles: number
    interceptions: number
    clearances: number
    blocks: number
    yellowCards: number
    redCards: number
    foulsCommitted: number
    foulsWon: number
    saves: number
    goalsConceded: number
    cleanSheets: number
    rating?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchStatisticUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntFieldUpdateOperationsInput | number
    goals?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    shots?: IntFieldUpdateOperationsInput | number
    shots_on_target?: IntFieldUpdateOperationsInput | number
    passes?: IntFieldUpdateOperationsInput | number
    passesCompleted?: IntFieldUpdateOperationsInput | number
    passAccuracy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tackles?: IntFieldUpdateOperationsInput | number
    interceptions?: IntFieldUpdateOperationsInput | number
    clearances?: IntFieldUpdateOperationsInput | number
    blocks?: IntFieldUpdateOperationsInput | number
    yellowCards?: IntFieldUpdateOperationsInput | number
    redCards?: IntFieldUpdateOperationsInput | number
    foulsCommitted?: IntFieldUpdateOperationsInput | number
    foulsWon?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    goalsConceded?: IntFieldUpdateOperationsInput | number
    cleanSheets?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchStatisticUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntFieldUpdateOperationsInput | number
    goals?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    shots?: IntFieldUpdateOperationsInput | number
    shots_on_target?: IntFieldUpdateOperationsInput | number
    passes?: IntFieldUpdateOperationsInput | number
    passesCompleted?: IntFieldUpdateOperationsInput | number
    passAccuracy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tackles?: IntFieldUpdateOperationsInput | number
    interceptions?: IntFieldUpdateOperationsInput | number
    clearances?: IntFieldUpdateOperationsInput | number
    blocks?: IntFieldUpdateOperationsInput | number
    yellowCards?: IntFieldUpdateOperationsInput | number
    redCards?: IntFieldUpdateOperationsInput | number
    foulsCommitted?: IntFieldUpdateOperationsInput | number
    foulsWon?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    goalsConceded?: IntFieldUpdateOperationsInput | number
    cleanSheets?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchStatisticCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    minutesPlayed: number
    goals: number
    assists: number
    shots: number
    shots_on_target: number
    passes: number
    passesCompleted: number
    passAccuracy: Decimal | DecimalJsLike | number | string
    tackles: number
    interceptions: number
    clearances: number
    blocks: number
    yellowCards: number
    redCards: number
    foulsCommitted: number
    foulsWon: number
    saves: number
    goalsConceded: number
    cleanSheets: number
    rating?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MatchStatisticUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntFieldUpdateOperationsInput | number
    goals?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    shots?: IntFieldUpdateOperationsInput | number
    shots_on_target?: IntFieldUpdateOperationsInput | number
    passes?: IntFieldUpdateOperationsInput | number
    passesCompleted?: IntFieldUpdateOperationsInput | number
    passAccuracy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tackles?: IntFieldUpdateOperationsInput | number
    interceptions?: IntFieldUpdateOperationsInput | number
    clearances?: IntFieldUpdateOperationsInput | number
    blocks?: IntFieldUpdateOperationsInput | number
    yellowCards?: IntFieldUpdateOperationsInput | number
    redCards?: IntFieldUpdateOperationsInput | number
    foulsCommitted?: IntFieldUpdateOperationsInput | number
    foulsWon?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    goalsConceded?: IntFieldUpdateOperationsInput | number
    cleanSheets?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MatchStatisticUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minutesPlayed?: IntFieldUpdateOperationsInput | number
    goals?: IntFieldUpdateOperationsInput | number
    assists?: IntFieldUpdateOperationsInput | number
    shots?: IntFieldUpdateOperationsInput | number
    shots_on_target?: IntFieldUpdateOperationsInput | number
    passes?: IntFieldUpdateOperationsInput | number
    passesCompleted?: IntFieldUpdateOperationsInput | number
    passAccuracy?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tackles?: IntFieldUpdateOperationsInput | number
    interceptions?: IntFieldUpdateOperationsInput | number
    clearances?: IntFieldUpdateOperationsInput | number
    blocks?: IntFieldUpdateOperationsInput | number
    yellowCards?: IntFieldUpdateOperationsInput | number
    redCards?: IntFieldUpdateOperationsInput | number
    foulsCommitted?: IntFieldUpdateOperationsInput | number
    foulsWon?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    goalsConceded?: IntFieldUpdateOperationsInput | number
    cleanSheets?: IntFieldUpdateOperationsInput | number
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberClubAdminCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberClubAdminUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberClubAdminUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberClubAdminUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberClubAdminCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberClubAdminUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberClubAdminUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCoacheCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    licenseNumber?: string | null
    certification?: string | null
    specialization?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberCoacheUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    licenseNumber?: string | null
    certification?: string | null
    specialization?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberCoacheUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCoacheUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCoacheCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    licenseNumber?: string | null
    certification?: string | null
    specialization?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberCoacheUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCoacheUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberParentCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberParentUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberParentUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberParentUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberParentCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberParentUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberParentUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPersonCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dob?: Date | string | null
    gender?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    countryId?: Decimal | DecimalJsLike | number | string | null
    photoPath?: string | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberPersonUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dob?: Date | string | null
    gender?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    countryId?: Decimal | DecimalJsLike | number | string | null
    photoPath?: string | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberPersonUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPersonUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPersonCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dob?: Date | string | null
    gender?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    countryId?: Decimal | DecimalJsLike | number | string | null
    photoPath?: string | null
    status: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberPersonUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPersonUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    countryId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    photoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPlayerCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    height?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    preferredFoot?: string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberPlayerUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    height?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    preferredFoot?: string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberPlayerUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: NullableStringFieldUpdateOperationsInput | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPlayerUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: NullableStringFieldUpdateOperationsInput | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPlayerCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    height?: Decimal | DecimalJsLike | number | string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    preferredFoot?: string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberPlayerUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: NullableStringFieldUpdateOperationsInput | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberPlayerUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    preferredFoot?: NullableStringFieldUpdateOperationsInput | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRefereeCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    licenseNumber: string
    licenseLevel?: string | null
    certification?: string | null
    refereeType: string
    specialization?: string | null
    languages?: string | null
    matchFee?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberRefereeUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    licenseNumber: string
    licenseLevel?: string | null
    certification?: string | null
    refereeType: string
    specialization?: string | null
    languages?: string | null
    matchFee?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberRefereeUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseLevel?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    refereeType?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRefereeUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseLevel?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    refereeType?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRefereeCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    licenseNumber: string
    licenseLevel?: string | null
    certification?: string | null
    refereeType: string
    specialization?: string | null
    languages?: string | null
    matchFee?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberRefereeUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseLevel?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    refereeType?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRefereeUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseLevel?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: NullableStringFieldUpdateOperationsInput | string | null
    refereeType?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableStringFieldUpdateOperationsInput | string | null
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberSponsorCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    companyName: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    sponsorLevel?: string | null
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    benefits?: string | null
    logoPath?: string | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberSponsorUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    companyName: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    sponsorLevel?: string | null
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    benefits?: string | null
    logoPath?: string | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberSponsorUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberSponsorUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberSponsorCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    companyName: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    website?: string | null
    sponsorLevel?: string | null
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    benefits?: string | null
    logoPath?: string | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberSponsorUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberSponsorUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorLevel?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTeamManagerCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    appointedDate?: Date | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTeamManagerUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    appointedDate?: Date | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTeamManagerUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appointedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTeamManagerUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appointedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTeamManagerCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    personId: Decimal | DecimalJsLike | number | string
    appointedDate?: Date | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status: string
    bio?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MemberTeamManagerUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appointedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberTeamManagerUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    personId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appointedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgClubCreateInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    description?: string | null
    foundedDate?: Date | string | null
    address?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    status: string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgClubUncheckedCreateInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    description?: string | null
    foundedDate?: Date | string | null
    address?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    status: string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgClubUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    foundedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgClubUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    foundedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgClubCreateManyInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    description?: string | null
    foundedDate?: Date | string | null
    address?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    status: string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgClubUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    foundedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgClubUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    foundedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgLeagueCreateInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    description?: string | null
    gameModeId?: Decimal | DecimalJsLike | number | string | null
    groupLevelId?: Decimal | DecimalJsLike | number | string | null
    season?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    registrationDeadline?: Date | string | null
    maxTeams?: number | null
    entryFee?: Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: string | null
    rules?: string | null
    status: string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgLeagueUncheckedCreateInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    description?: string | null
    gameModeId?: Decimal | DecimalJsLike | number | string | null
    groupLevelId?: Decimal | DecimalJsLike | number | string | null
    season?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    registrationDeadline?: Date | string | null
    maxTeams?: number | null
    entryFee?: Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: string | null
    rules?: string | null
    status: string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgLeagueUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameModeId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgLeagueUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameModeId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgLeagueCreateManyInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    description?: string | null
    gameModeId?: Decimal | DecimalJsLike | number | string | null
    groupLevelId?: Decimal | DecimalJsLike | number | string | null
    season?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    registrationDeadline?: Date | string | null
    maxTeams?: number | null
    entryFee?: Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: string | null
    rules?: string | null
    status: string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgLeagueUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameModeId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgLeagueUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gameModeId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    groupLevelId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    season?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    registrationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subscribeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgTeamCreateInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    note?: string | null
    clubId?: Decimal | DecimalJsLike | number | string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    leagueId?: Decimal | DecimalJsLike | number | string | null
    ageGroup?: string | null
    gender?: number | null
    skillLevel?: string | null
    color1?: string | null
    color2?: string | null
    maxPlayers?: number | null
    status: number
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgTeamUncheckedCreateInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    note?: string | null
    clubId?: Decimal | DecimalJsLike | number | string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    leagueId?: Decimal | DecimalJsLike | number | string | null
    ageGroup?: string | null
    gender?: number | null
    skillLevel?: string | null
    color1?: string | null
    color2?: string | null
    maxPlayers?: number | null
    status: number
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgTeamUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgTeamUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgTeamCreateManyInput = {
    id?: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    note?: string | null
    clubId?: Decimal | DecimalJsLike | number | string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    leagueId?: Decimal | DecimalJsLike | number | string | null
    ageGroup?: string | null
    gender?: number | null
    skillLevel?: string | null
    color1?: string | null
    color2?: string | null
    maxPlayers?: number | null
    status: number
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrgTeamUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrgTeamUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    color1?: NullableStringFieldUpdateOperationsInput | string | null
    color2?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanGameCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    leagueId?: Decimal | DecimalJsLike | number | string | null
    gameName?: string | null
    homeTeamId?: Decimal | DecimalJsLike | number | string | null
    awayTeamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    duration?: number | null
    uniform?: string | null
    locationId?: Decimal | DecimalJsLike | number | string | null
    isScrimmage: number
    status: string
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanGameUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    leagueId?: Decimal | DecimalJsLike | number | string | null
    gameName?: string | null
    homeTeamId?: Decimal | DecimalJsLike | number | string | null
    awayTeamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    duration?: number | null
    uniform?: string | null
    locationId?: Decimal | DecimalJsLike | number | string | null
    isScrimmage: number
    status: string
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanGameUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gameName?: NullableStringFieldUpdateOperationsInput | string | null
    homeTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uniform?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanGameUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gameName?: NullableStringFieldUpdateOperationsInput | string | null
    homeTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uniform?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanGameCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    leagueId?: Decimal | DecimalJsLike | number | string | null
    gameName?: string | null
    homeTeamId?: Decimal | DecimalJsLike | number | string | null
    awayTeamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    duration?: number | null
    uniform?: string | null
    locationId?: Decimal | DecimalJsLike | number | string | null
    isScrimmage: number
    status: string
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanGameUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gameName?: NullableStringFieldUpdateOperationsInput | string | null
    homeTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uniform?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanGameUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gameName?: NullableStringFieldUpdateOperationsInput | string | null
    homeTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    awayTeamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    uniform?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isScrimmage?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanMeetingCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    meetingCategory?: number | null
    teamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    title?: string | null
    content?: string | null
    locationId?: Decimal | DecimalJsLike | number | string | null
    status?: number | null
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanMeetingUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    meetingCategory?: number | null
    teamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    title?: string | null
    content?: string | null
    locationId?: Decimal | DecimalJsLike | number | string | null
    status?: number | null
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanMeetingUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingCategory?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanMeetingUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingCategory?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanMeetingCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    meetingCategory?: number | null
    teamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    title?: string | null
    content?: string | null
    locationId?: Decimal | DecimalJsLike | number | string | null
    status?: number | null
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanMeetingUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingCategory?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanMeetingUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    meetingCategory?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanTrainingCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    trainingContent?: string | null
    isAllMembers: number
    locationId?: Decimal | DecimalJsLike | number | string | null
    recurringType: number
    status: string
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanTrainingUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    trainingContent?: string | null
    isAllMembers: number
    locationId?: Decimal | DecimalJsLike | number | string | null
    recurringType: number
    status: string
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanTrainingUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingContent?: NullableStringFieldUpdateOperationsInput | string | null
    isAllMembers?: IntFieldUpdateOperationsInput | number
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanTrainingUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingContent?: NullableStringFieldUpdateOperationsInput | string | null
    isAllMembers?: IntFieldUpdateOperationsInput | number
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanTrainingCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId?: Decimal | DecimalJsLike | number | string | null
    startDatetime: Date | string
    endDatetime: Date | string
    trainingContent?: string | null
    isAllMembers: number
    locationId?: Decimal | DecimalJsLike | number | string | null
    recurringType: number
    status: string
    createdBy?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PlanTrainingUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingContent?: NullableStringFieldUpdateOperationsInput | string | null
    isAllMembers?: IntFieldUpdateOperationsInput | number
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanTrainingUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    endDatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingContent?: NullableStringFieldUpdateOperationsInput | string | null
    isAllMembers?: IntFieldUpdateOperationsInput | number
    locationId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recurringType?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelClubClubAdminCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    adminId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    role: string
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelClubClubAdminUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    adminId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    role: string
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelClubClubAdminUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adminId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelClubClubAdminUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adminId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelClubClubAdminCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    adminId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    role: string
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelClubClubAdminUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adminId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelClubClubAdminUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adminId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelCompetitionGroupLevelCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    competitionId: Decimal | DecimalJsLike | number | string
    groupLevelId: Decimal | DecimalJsLike | number | string
    isPrimary: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelCompetitionGroupLevelUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    competitionId: Decimal | DecimalJsLike | number | string
    groupLevelId: Decimal | DecimalJsLike | number | string
    isPrimary: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelCompetitionGroupLevelUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelCompetitionGroupLevelUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelCompetitionGroupLevelCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    competitionId: Decimal | DecimalJsLike | number | string
    groupLevelId: Decimal | DecimalJsLike | number | string
    isPrimary: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelCompetitionGroupLevelUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelCompetitionGroupLevelUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    competitionId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    groupLevelId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelFieldSportCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    fieldId: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    isPrimary: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelFieldSportUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    fieldId: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    isPrimary: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelFieldSportUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelFieldSportUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelFieldSportCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    fieldId: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    isPrimary: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelFieldSportUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelFieldSportUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fieldId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPrimary?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelMatchRefereeCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    refereeId: Decimal | DecimalJsLike | number | string
    assignedAt?: Date | string | null
    confirmedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status: string
    matchFee?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelMatchRefereeUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    refereeId: Decimal | DecimalJsLike | number | string
    assignedAt?: Date | string | null
    confirmedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status: string
    matchFee?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelMatchRefereeUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelMatchRefereeUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelMatchRefereeCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    matchId: Decimal | DecimalJsLike | number | string
    refereeId: Decimal | DecimalJsLike | number | string
    assignedAt?: Date | string | null
    confirmedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status: string
    matchFee?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelMatchRefereeUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelMatchRefereeUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    matchId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refereeId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    matchFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelPlayerParentCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    parentId: Decimal | DecimalJsLike | number | string
    assignedAt?: Date | string | null
    removedAt?: Date | string | null
    relationship?: string | null
    isPrimaryContact: number
    canPickup: number
    receivesNotifications: number
    occupation?: string | null
    employer?: string | null
    workPhone?: string | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelPlayerParentUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    parentId: Decimal | DecimalJsLike | number | string
    assignedAt?: Date | string | null
    removedAt?: Date | string | null
    relationship?: string | null
    isPrimaryContact: number
    canPickup: number
    receivesNotifications: number
    occupation?: string | null
    employer?: string | null
    workPhone?: string | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelPlayerParentUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parentId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: IntFieldUpdateOperationsInput | number
    canPickup?: IntFieldUpdateOperationsInput | number
    receivesNotifications?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    workPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelPlayerParentUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parentId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: IntFieldUpdateOperationsInput | number
    canPickup?: IntFieldUpdateOperationsInput | number
    receivesNotifications?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    workPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelPlayerParentCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    parentId: Decimal | DecimalJsLike | number | string
    assignedAt?: Date | string | null
    removedAt?: Date | string | null
    relationship?: string | null
    isPrimaryContact: number
    canPickup: number
    receivesNotifications: number
    occupation?: string | null
    employer?: string | null
    workPhone?: string | null
    status: string
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelPlayerParentUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parentId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: IntFieldUpdateOperationsInput | number
    canPickup?: IntFieldUpdateOperationsInput | number
    receivesNotifications?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    workPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelPlayerParentUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parentId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: IntFieldUpdateOperationsInput | number
    canPickup?: IntFieldUpdateOperationsInput | number
    receivesNotifications?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    employer?: NullableStringFieldUpdateOperationsInput | string | null
    workPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorClubCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorClubUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorClubUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorClubUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorClubCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorClubUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorClubUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    clubId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorLeagueCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    leagueId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorLeagueUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    leagueId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorLeagueUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorLeagueUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorLeagueCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    leagueId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorLeagueUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorLeagueUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    leagueId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorTeamCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorTeamUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorTeamUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorTeamUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorTeamCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sponsorId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    status: string
    sponsorshipAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelSponsorTeamUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelSponsorTeamUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sponsorId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sponsorshipAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamCoachCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    coachId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    coachTypeId?: bigint | number | null
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    responsibilities?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamCoachUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    coachId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    coachTypeId?: bigint | number | null
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    responsibilities?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamCoachUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coachId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    coachTypeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamCoachUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coachId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    coachTypeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamCoachCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    coachId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    coachTypeId?: bigint | number | null
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    responsibilities?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamCoachUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coachId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    coachTypeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamCoachUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coachId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    coachTypeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamPlayerCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    jerseyNumber?: string | null
    positionId?: bigint | number | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamPlayerUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    jerseyNumber?: string | null
    positionId?: bigint | number | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamPlayerUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamPlayerUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamPlayerCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    jerseyNumber?: string | null
    positionId?: bigint | number | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamPlayerUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamPlayerUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    playerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    jerseyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamTeamManagerCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    managerId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    managerTypeId?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    responsibilities?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamTeamManagerUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    managerId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    managerTypeId?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    responsibilities?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamTeamManagerUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    managerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamTeamManagerUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    managerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamTeamManagerCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    managerId: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    status: string
    managerTypeId?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    contractStart?: Date | string | null
    contractEnd?: Date | string | null
    responsibilities?: string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelTeamTeamManagerUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    managerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelTeamTeamManagerUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    managerId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    managerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsibilities?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportCoachTypeCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportCoachTypeUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportCoachTypeUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportCoachTypeUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportCoachTypeCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportCoachTypeUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportCoachTypeUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportEventTypeCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    category?: number | null
    evaluationMetric?: number | null
    code?: string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    isVisible: number
    note?: string | null
    ord?: number | null
    score: number
    slot: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportEventTypeUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    category?: number | null
    evaluationMetric?: number | null
    code?: string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    isVisible: number
    note?: string | null
    ord?: number | null
    score: number
    slot: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportEventTypeUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationMetric?: NullableIntFieldUpdateOperationsInput | number | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportEventTypeUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationMetric?: NullableIntFieldUpdateOperationsInput | number | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportEventTypeCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr?: string | null
    category?: number | null
    evaluationMetric?: number | null
    code?: string | null
    sportId?: Decimal | DecimalJsLike | number | string | null
    isVisible: number
    note?: string | null
    ord?: number | null
    score: number
    slot: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportEventTypeUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationMetric?: NullableIntFieldUpdateOperationsInput | number | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportEventTypeUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    evaluationMetric?: NullableIntFieldUpdateOperationsInput | number | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isVisible?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportGamePeriodCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    ord: number
    duration?: number | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportGamePeriodUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    ord: number
    duration?: number | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportGamePeriodUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    ord?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportGamePeriodUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    ord?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportGamePeriodCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    ord: number
    duration?: number | null
    note?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportGamePeriodUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    ord?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportGamePeriodUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    ord?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportManagerTypeCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId?: Decimal | DecimalJsLike | number | string | null
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportManagerTypeUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId?: Decimal | DecimalJsLike | number | string | null
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportManagerTypeUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportManagerTypeUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportManagerTypeCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId?: Decimal | DecimalJsLike | number | string | null
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportManagerTypeUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportManagerTypeUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportPlayerPositionCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    note?: string | null
    sportId: Decimal | DecimalJsLike | number | string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportPlayerPositionUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    note?: string | null
    sportId: Decimal | DecimalJsLike | number | string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportPlayerPositionUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportPlayerPositionUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportPlayerPositionCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    note?: string | null
    sportId: Decimal | DecimalJsLike | number | string
    ord?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportPlayerPositionUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportPlayerPositionUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ord?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportRefereeTypeCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportRefereeTypeUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportRefereeTypeUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportRefereeTypeUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportRefereeTypeCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
    name: string
    abbr: string
    color: string
    note?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SportRefereeTypeUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SportRefereeTypeUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sportId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    abbr?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubFeatureCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubFeatureUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubFeatureUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubFeatureUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubFeatureCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    description?: string | null
    category?: string | null
    icon?: string | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubFeatureUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubFeatureUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForTeamCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    status: string
    startedAt: Date | string
    expiresAt?: Date | string | null
    autoRenew: number
    paymentMethod?: string | null
    lastPaymentAt?: Date | string | null
    nextPaymentAt?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubForTeamUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    status: string
    startedAt: Date | string
    expiresAt?: Date | string | null
    autoRenew: number
    paymentMethod?: string | null
    lastPaymentAt?: Date | string | null
    nextPaymentAt?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubForTeamUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForTeamUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForTeamCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    status: string
    startedAt: Date | string
    expiresAt?: Date | string | null
    autoRenew: number
    paymentMethod?: string | null
    lastPaymentAt?: Date | string | null
    nextPaymentAt?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubForTeamUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForTeamUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    teamId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForUserCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    userId: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    status: string
    startedAt: Date | string
    expiresAt?: Date | string | null
    autoRenew: number
    paymentMethod?: string | null
    lastPaymentAt?: Date | string | null
    nextPaymentAt?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubForUserUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    userId: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    status: string
    startedAt: Date | string
    expiresAt?: Date | string | null
    autoRenew: number
    paymentMethod?: string | null
    lastPaymentAt?: Date | string | null
    nextPaymentAt?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubForUserUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForUserUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForUserCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    userId: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    status: string
    startedAt: Date | string
    expiresAt?: Date | string | null
    autoRenew: number
    paymentMethod?: string | null
    lastPaymentAt?: Date | string | null
    nextPaymentAt?: Date | string | null
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubForUserUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubForUserUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoRenew?: IntFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextPaymentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    planType: string
    price: Decimal | DecimalJsLike | number | string
    isPopular: number
    description?: string | null
    features?: string | null
    maxTeams?: number | null
    maxPlayers?: number | null
    maxCoaches?: number | null
    maxReferees?: number | null
    storageLimitGb?: number | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubPlanUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    planType: string
    price: Decimal | DecimalJsLike | number | string
    isPopular: number
    description?: string | null
    features?: string | null
    maxTeams?: number | null
    maxPlayers?: number | null
    maxCoaches?: number | null
    maxReferees?: number | null
    storageLimitGb?: number | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubPlanUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPopular?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    maxCoaches?: NullableIntFieldUpdateOperationsInput | number | null
    maxReferees?: NullableIntFieldUpdateOperationsInput | number | null
    storageLimitGb?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPopular?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    maxCoaches?: NullableIntFieldUpdateOperationsInput | number | null
    maxReferees?: NullableIntFieldUpdateOperationsInput | number | null
    storageLimitGb?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    name: string
    planType: string
    price: Decimal | DecimalJsLike | number | string
    isPopular: number
    description?: string | null
    features?: string | null
    maxTeams?: number | null
    maxPlayers?: number | null
    maxCoaches?: number | null
    maxReferees?: number | null
    storageLimitGb?: number | null
    isActive: number
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubPlanUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPopular?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    maxCoaches?: NullableIntFieldUpdateOperationsInput | number | null
    maxReferees?: NullableIntFieldUpdateOperationsInput | number | null
    storageLimitGb?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    name?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPopular?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    maxTeams?: NullableIntFieldUpdateOperationsInput | number | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    maxCoaches?: NullableIntFieldUpdateOperationsInput | number | null
    maxReferees?: NullableIntFieldUpdateOperationsInput | number | null
    storageLimitGb?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: IntFieldUpdateOperationsInput | number
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanFeatureCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    featureId: Decimal | DecimalJsLike | number | string
    isIncluded: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubPlanFeatureUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    featureId: Decimal | DecimalJsLike | number | string
    isIncluded: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubPlanFeatureUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    featureId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isIncluded?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanFeatureUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    featureId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isIncluded?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanFeatureCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    planId: Decimal | DecimalJsLike | number | string
    featureId: Decimal | DecimalJsLike | number | string
    isIncluded: number
    notes?: string | null
    ord: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubPlanFeatureUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    featureId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isIncluded?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubPlanFeatureUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    featureId?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isIncluded?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ord?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SysUserCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    firstName: string
    lastName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    status: string
    personId?: Decimal | DecimalJsLike | number | string | null
    rememberToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SysUserUncheckedCreateInput = {
    id: Decimal | DecimalJsLike | number | string
    firstName: string
    lastName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    status: string
    personId?: Decimal | DecimalJsLike | number | string | null
    rememberToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SysUserUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    personId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SysUserUncheckedUpdateInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    personId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SysUserCreateManyInput = {
    id: Decimal | DecimalJsLike | number | string
    firstName: string
    lastName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    status: string
    personId?: Decimal | DecimalJsLike | number | string | null
    rememberToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SysUserUpdateManyMutationInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    personId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SysUserUncheckedUpdateManyInput = {
    id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    personId?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BaseCompetitionOrderByRelevanceInput = {
    fields: BaseCompetitionOrderByRelevanceFieldEnum | BaseCompetitionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BaseCompetitionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    sportId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseCompetitionAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
  }

  export type BaseCompetitionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    sportId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseCompetitionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    sportId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseCompetitionSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BaseCountryOrderByRelevanceInput = {
    fields: BaseCountryOrderByRelevanceFieldEnum | BaseCountryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BaseCountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    code?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseCountryAvgOrderByAggregateInput = {
    id?: SortOrder
    ord?: SortOrder
  }

  export type BaseCountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    code?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseCountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    code?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseCountrySumOrderByAggregateInput = {
    id?: SortOrder
    ord?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BaseFieldOrderByRelevanceInput = {
    fields: BaseFieldOrderByRelevanceFieldEnum | BaseFieldOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BaseFieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    sportIds?: SortOrder
    countryId?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseFieldAvgOrderByAggregateInput = {
    id?: SortOrder
    sportIds?: SortOrder
    countryId?: SortOrder
    ord?: SortOrder
  }

  export type BaseFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    countryId?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseFieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    countryId?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseFieldSumOrderByAggregateInput = {
    id?: SortOrder
    sportIds?: SortOrder
    countryId?: SortOrder
    ord?: SortOrder
  }

  export type BaseGroupLevelOrderByRelevanceInput = {
    fields: BaseGroupLevelOrderByRelevanceFieldEnum | BaseGroupLevelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BaseGroupLevelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    skillLevel?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseGroupLevelAvgOrderByAggregateInput = {
    id?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    ord?: SortOrder
  }

  export type BaseGroupLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    skillLevel?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseGroupLevelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    skillLevel?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseGroupLevelSumOrderByAggregateInput = {
    id?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    ord?: SortOrder
  }

  export type BaseSportOrderByRelevanceInput = {
    fields: BaseSportOrderByRelevanceFieldEnum | BaseSportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BaseSportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseSportAvgOrderByAggregateInput = {
    id?: SortOrder
    ord?: SortOrder
  }

  export type BaseSportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseSportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BaseSportSumOrderByAggregateInput = {
    id?: SortOrder
    ord?: SortOrder
  }

  export type GameEventOrderByRelevanceInput = {
    fields: GameEventOrderByRelevanceFieldEnum | GameEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GameEventCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrder
    eventDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameEventAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrder
  }

  export type GameEventMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrder
    eventDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameEventMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrder
    eventDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameEventSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    competitionId?: SortOrder
  }

  export type GameMatcheOrderByRelevanceInput = {
    fields: GameMatcheOrderByRelevanceFieldEnum | GameMatcheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GameMatcheCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrder
    awayTeamScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMatcheAvgOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrder
    awayTeamScore?: SortOrder
  }

  export type GameMatcheMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrder
    awayTeamScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMatcheMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrder
    awayTeamScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMatcheSumOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    homeTeamScore?: SortOrder
    awayTeamScore?: SortOrder
  }

  export type MatchEventOrderByRelevanceInput = {
    fields: MatchEventOrderByRelevanceFieldEnum | MatchEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MatchEventCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    eventType?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    description?: SortOrder
    eventData?: SortOrder
    fieldX?: SortOrder
    fieldY?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchEventAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    fieldX?: SortOrder
    fieldY?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    ord?: SortOrder
  }

  export type MatchEventMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    eventType?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    description?: SortOrder
    eventData?: SortOrder
    fieldX?: SortOrder
    fieldY?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchEventMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    eventType?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    description?: SortOrder
    eventData?: SortOrder
    fieldX?: SortOrder
    fieldY?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchEventSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minute?: SortOrder
    second?: SortOrder
    fieldX?: SortOrder
    fieldY?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    ord?: SortOrder
  }

  export type MatchLineupOrderByRelevanceInput = {
    fields: MatchLineupOrderByRelevanceFieldEnum | MatchLineupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MatchLineupMatchIdTeamIdCompoundUniqueInput = {
    matchId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
  }

  export type MatchLineupCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    formation?: SortOrder
    lineupData?: SortOrder
    announcedAt?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchLineupAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    ord?: SortOrder
  }

  export type MatchLineupMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    formation?: SortOrder
    lineupData?: SortOrder
    announcedAt?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchLineupMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    formation?: SortOrder
    lineupData?: SortOrder
    announcedAt?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchLineupSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    teamId?: SortOrder
    isConfirmed?: SortOrder
    createdBy?: SortOrder
    ord?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type MatchMediaOrderByRelevanceInput = {
    fields: MatchMediaOrderByRelevanceFieldEnum | MatchMediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MatchMediaCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    fileSize?: SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrder
    ord?: SortOrder
  }

  export type MatchMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMediaMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    mediaType?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMediaSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    fileSize?: SortOrder
    isPublic?: SortOrder
    uploadedBy?: SortOrder
    ord?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type MatchRosterOrderByRelevanceInput = {
    fields: MatchRosterOrderByRelevanceFieldEnum | MatchRosterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MatchRosterMatchIdPlayerIdCompoundUniqueInput = {
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
  }

  export type MatchRosterCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    position?: SortOrder
    jerseyNumber?: SortOrder
    substitutionInMinute?: SortOrder
    substitutionOutMinute?: SortOrder
    substitutionReason?: SortOrder
    minutesPlayed?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchRosterAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    substitutionInMinute?: SortOrder
    substitutionOutMinute?: SortOrder
    minutesPlayed?: SortOrder
    ord?: SortOrder
  }

  export type MatchRosterMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    position?: SortOrder
    jerseyNumber?: SortOrder
    substitutionInMinute?: SortOrder
    substitutionOutMinute?: SortOrder
    substitutionReason?: SortOrder
    minutesPlayed?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchRosterMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    position?: SortOrder
    jerseyNumber?: SortOrder
    substitutionInMinute?: SortOrder
    substitutionOutMinute?: SortOrder
    substitutionReason?: SortOrder
    minutesPlayed?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchRosterSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    isStarting?: SortOrder
    isSubstitute?: SortOrder
    substitutionInMinute?: SortOrder
    substitutionOutMinute?: SortOrder
    minutesPlayed?: SortOrder
    ord?: SortOrder
  }

  export type MatchStatisticOrderByRelevanceInput = {
    fields: MatchStatisticOrderByRelevanceFieldEnum | MatchStatisticOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MatchStatisticMatchIdPlayerIdCompoundUniqueInput = {
    matchId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
  }

  export type MatchStatisticCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchStatisticAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrder
    ord?: SortOrder
  }

  export type MatchStatisticMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchStatisticMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchStatisticSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    playerId?: SortOrder
    teamId?: SortOrder
    minutesPlayed?: SortOrder
    goals?: SortOrder
    assists?: SortOrder
    shots?: SortOrder
    shots_on_target?: SortOrder
    passes?: SortOrder
    passesCompleted?: SortOrder
    passAccuracy?: SortOrder
    tackles?: SortOrder
    interceptions?: SortOrder
    clearances?: SortOrder
    blocks?: SortOrder
    yellowCards?: SortOrder
    redCards?: SortOrder
    foulsCommitted?: SortOrder
    foulsWon?: SortOrder
    saves?: SortOrder
    goalsConceded?: SortOrder
    cleanSheets?: SortOrder
    rating?: SortOrder
    ord?: SortOrder
  }

  export type MemberClubAdminOrderByRelevanceInput = {
    fields: MemberClubAdminOrderByRelevanceFieldEnum | MemberClubAdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberClubAdminCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberClubAdminAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    ord?: SortOrder
  }

  export type MemberClubAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberClubAdminMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberClubAdminSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    clubId?: SortOrder
    ord?: SortOrder
  }

  export type MemberCoacheOrderByRelevanceInput = {
    fields: MemberCoacheOrderByRelevanceFieldEnum | MemberCoacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberCoacheCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    certification?: SortOrder
    specialization?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCoacheAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    ord?: SortOrder
  }

  export type MemberCoacheMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    certification?: SortOrder
    specialization?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCoacheMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    certification?: SortOrder
    specialization?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCoacheSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    ord?: SortOrder
  }

  export type MemberParentOrderByRelevanceInput = {
    fields: MemberParentOrderByRelevanceFieldEnum | MemberParentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberParentCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberParentAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    ord?: SortOrder
  }

  export type MemberParentMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberParentMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberParentSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    ord?: SortOrder
  }

  export type MemberPersonOrderByRelevanceInput = {
    fields: MemberPersonOrderByRelevanceFieldEnum | MemberPersonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberPersonCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    countryId?: SortOrder
    photoPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberPersonAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type MemberPersonMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    countryId?: SortOrder
    photoPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberPersonMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    countryId?: SortOrder
    photoPath?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberPersonSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type MemberPlayerOrderByRelevanceInput = {
    fields: MemberPlayerOrderByRelevanceFieldEnum | MemberPlayerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    preferredFoot?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberPlayerAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    ord?: SortOrder
  }

  export type MemberPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    preferredFoot?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    preferredFoot?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberPlayerSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    ord?: SortOrder
  }

  export type MemberRefereeOrderByRelevanceInput = {
    fields: MemberRefereeOrderByRelevanceFieldEnum | MemberRefereeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberRefereeCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    licenseLevel?: SortOrder
    certification?: SortOrder
    refereeType?: SortOrder
    specialization?: SortOrder
    languages?: SortOrder
    matchFee?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberRefereeAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    matchFee?: SortOrder
    ord?: SortOrder
  }

  export type MemberRefereeMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    licenseLevel?: SortOrder
    certification?: SortOrder
    refereeType?: SortOrder
    specialization?: SortOrder
    languages?: SortOrder
    matchFee?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberRefereeMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    licenseNumber?: SortOrder
    licenseLevel?: SortOrder
    certification?: SortOrder
    refereeType?: SortOrder
    specialization?: SortOrder
    languages?: SortOrder
    matchFee?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberRefereeSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    matchFee?: SortOrder
    ord?: SortOrder
  }

  export type MemberSponsorOrderByRelevanceInput = {
    fields: MemberSponsorOrderByRelevanceFieldEnum | MemberSponsorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberSponsorCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    sponsorLevel?: SortOrder
    sponsorshipAmount?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    benefits?: SortOrder
    logoPath?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberSponsorAvgOrderByAggregateInput = {
    id?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type MemberSponsorMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    sponsorLevel?: SortOrder
    sponsorshipAmount?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    benefits?: SortOrder
    logoPath?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberSponsorMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    sponsorLevel?: SortOrder
    sponsorshipAmount?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    benefits?: SortOrder
    logoPath?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberSponsorSumOrderByAggregateInput = {
    id?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type MemberTeamManagerOrderByRelevanceInput = {
    fields: MemberTeamManagerOrderByRelevanceFieldEnum | MemberTeamManagerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MemberTeamManagerCountOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    appointedDate?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTeamManagerAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    ord?: SortOrder
  }

  export type MemberTeamManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    appointedDate?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTeamManagerMinOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    appointedDate?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    bio?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberTeamManagerSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
    ord?: SortOrder
  }

  export type OrgClubOrderByRelevanceInput = {
    fields: OrgClubOrderByRelevanceFieldEnum | OrgClubOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrgClubCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    description?: SortOrder
    foundedDate?: SortOrder
    address?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgClubAvgOrderByAggregateInput = {
    id?: SortOrder
    ord?: SortOrder
  }

  export type OrgClubMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    description?: SortOrder
    foundedDate?: SortOrder
    address?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgClubMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    description?: SortOrder
    foundedDate?: SortOrder
    address?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgClubSumOrderByAggregateInput = {
    id?: SortOrder
    ord?: SortOrder
  }

  export type OrgLeagueOrderByRelevanceInput = {
    fields: OrgLeagueOrderByRelevanceFieldEnum | OrgLeagueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrgLeagueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    description?: SortOrder
    gameModeId?: SortOrder
    groupLevelId?: SortOrder
    season?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    registrationDeadline?: SortOrder
    maxTeams?: SortOrder
    entryFee?: SortOrder
    subscribeEmail?: SortOrder
    rules?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgLeagueAvgOrderByAggregateInput = {
    id?: SortOrder
    gameModeId?: SortOrder
    groupLevelId?: SortOrder
    maxTeams?: SortOrder
    entryFee?: SortOrder
    ord?: SortOrder
  }

  export type OrgLeagueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    description?: SortOrder
    gameModeId?: SortOrder
    groupLevelId?: SortOrder
    season?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    registrationDeadline?: SortOrder
    maxTeams?: SortOrder
    entryFee?: SortOrder
    subscribeEmail?: SortOrder
    rules?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgLeagueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    description?: SortOrder
    gameModeId?: SortOrder
    groupLevelId?: SortOrder
    season?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    registrationDeadline?: SortOrder
    maxTeams?: SortOrder
    entryFee?: SortOrder
    subscribeEmail?: SortOrder
    rules?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgLeagueSumOrderByAggregateInput = {
    id?: SortOrder
    gameModeId?: SortOrder
    groupLevelId?: SortOrder
    maxTeams?: SortOrder
    entryFee?: SortOrder
    ord?: SortOrder
  }

  export type OrgTeamOrderByRelevanceInput = {
    fields: OrgTeamOrderByRelevanceFieldEnum | OrgTeamOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrgTeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    clubId?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    ageGroup?: SortOrder
    gender?: SortOrder
    skillLevel?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgTeamAvgOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    gender?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    ord?: SortOrder
  }

  export type OrgTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    clubId?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    ageGroup?: SortOrder
    gender?: SortOrder
    skillLevel?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgTeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    clubId?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    ageGroup?: SortOrder
    gender?: SortOrder
    skillLevel?: SortOrder
    color1?: SortOrder
    color2?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrgTeamSumOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    sportId?: SortOrder
    leagueId?: SortOrder
    gender?: SortOrder
    maxPlayers?: SortOrder
    status?: SortOrder
    ord?: SortOrder
  }

  export type PlanGameOrderByRelevanceInput = {
    fields: PlanGameOrderByRelevanceFieldEnum | PlanGameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlanGameCountOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    gameName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    duration?: SortOrder
    uniform?: SortOrder
    locationId?: SortOrder
    isScrimmage?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanGameAvgOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    isScrimmage?: SortOrder
    createdBy?: SortOrder
  }

  export type PlanGameMaxOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    gameName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    duration?: SortOrder
    uniform?: SortOrder
    locationId?: SortOrder
    isScrimmage?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanGameMinOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    gameName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    duration?: SortOrder
    uniform?: SortOrder
    locationId?: SortOrder
    isScrimmage?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanGameSumOrderByAggregateInput = {
    id?: SortOrder
    leagueId?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    duration?: SortOrder
    locationId?: SortOrder
    isScrimmage?: SortOrder
    createdBy?: SortOrder
  }

  export type PlanMeetingOrderByRelevanceInput = {
    fields: PlanMeetingOrderByRelevanceFieldEnum | PlanMeetingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlanMeetingCountOrderByAggregateInput = {
    id?: SortOrder
    meetingCategory?: SortOrder
    teamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    title?: SortOrder
    content?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMeetingAvgOrderByAggregateInput = {
    id?: SortOrder
    meetingCategory?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
  }

  export type PlanMeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingCategory?: SortOrder
    teamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    title?: SortOrder
    content?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMeetingMinOrderByAggregateInput = {
    id?: SortOrder
    meetingCategory?: SortOrder
    teamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    title?: SortOrder
    content?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMeetingSumOrderByAggregateInput = {
    id?: SortOrder
    meetingCategory?: SortOrder
    teamId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
  }

  export type PlanTrainingOrderByRelevanceInput = {
    fields: PlanTrainingOrderByRelevanceFieldEnum | PlanTrainingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlanTrainingCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    trainingContent?: SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrder
    recurringType?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanTrainingAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrder
    recurringType?: SortOrder
    createdBy?: SortOrder
  }

  export type PlanTrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    trainingContent?: SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrder
    recurringType?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanTrainingMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    startDatetime?: SortOrder
    endDatetime?: SortOrder
    trainingContent?: SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrder
    recurringType?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanTrainingSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    isAllMembers?: SortOrder
    locationId?: SortOrder
    recurringType?: SortOrder
    createdBy?: SortOrder
  }

  export type RelClubClubAdminOrderByRelevanceInput = {
    fields: RelClubClubAdminOrderByRelevanceFieldEnum | RelClubClubAdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelClubClubAdminClubIdAdminIdCompoundUniqueInput = {
    clubId: Decimal | DecimalJsLike | number | string
    adminId: Decimal | DecimalJsLike | number | string
  }

  export type RelClubClubAdminCountOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelClubClubAdminAvgOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    salary?: SortOrder
    ord?: SortOrder
  }

  export type RelClubClubAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelClubClubAdminMinOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelClubClubAdminSumOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    adminId?: SortOrder
    salary?: SortOrder
    ord?: SortOrder
  }

  export type RelCompetitionGroupLevelOrderByRelevanceInput = {
    fields: RelCompetitionGroupLevelOrderByRelevanceFieldEnum | RelCompetitionGroupLevelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelCompetitionGroupLevelCompetitionIdGroupLevelIdCompoundUniqueInput = {
    competitionId: Decimal | DecimalJsLike | number | string
    groupLevelId: Decimal | DecimalJsLike | number | string
  }

  export type RelCompetitionGroupLevelCountOrderByAggregateInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelCompetitionGroupLevelAvgOrderByAggregateInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    ord?: SortOrder
  }

  export type RelCompetitionGroupLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelCompetitionGroupLevelMinOrderByAggregateInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelCompetitionGroupLevelSumOrderByAggregateInput = {
    id?: SortOrder
    competitionId?: SortOrder
    groupLevelId?: SortOrder
    isPrimary?: SortOrder
    ord?: SortOrder
  }

  export type RelFieldSportOrderByRelevanceInput = {
    fields: RelFieldSportOrderByRelevanceFieldEnum | RelFieldSportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelFieldSportFieldIdSportIdCompoundUniqueInput = {
    fieldId: Decimal | DecimalJsLike | number | string
    sportId: Decimal | DecimalJsLike | number | string
  }

  export type RelFieldSportCountOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelFieldSportAvgOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    ord?: SortOrder
  }

  export type RelFieldSportMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelFieldSportMinOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelFieldSportSumOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    sportId?: SortOrder
    isPrimary?: SortOrder
    ord?: SortOrder
  }

  export type RelMatchRefereeOrderByRelevanceInput = {
    fields: RelMatchRefereeOrderByRelevanceFieldEnum | RelMatchRefereeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelMatchRefereeMatchIdRefereeIdCompoundUniqueInput = {
    matchId: Decimal | DecimalJsLike | number | string
    refereeId: Decimal | DecimalJsLike | number | string
  }

  export type RelMatchRefereeCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    assignedAt?: SortOrder
    confirmedAt?: SortOrder
    cancelledAt?: SortOrder
    status?: SortOrder
    matchFee?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelMatchRefereeAvgOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    matchFee?: SortOrder
    ord?: SortOrder
  }

  export type RelMatchRefereeMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    assignedAt?: SortOrder
    confirmedAt?: SortOrder
    cancelledAt?: SortOrder
    status?: SortOrder
    matchFee?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelMatchRefereeMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    assignedAt?: SortOrder
    confirmedAt?: SortOrder
    cancelledAt?: SortOrder
    status?: SortOrder
    matchFee?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelMatchRefereeSumOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    refereeId?: SortOrder
    matchFee?: SortOrder
    ord?: SortOrder
  }

  export type RelPlayerParentOrderByRelevanceInput = {
    fields: RelPlayerParentOrderByRelevanceFieldEnum | RelPlayerParentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelPlayerParentPlayerIdParentIdCompoundUniqueInput = {
    playerId: Decimal | DecimalJsLike | number | string
    parentId: Decimal | DecimalJsLike | number | string
  }

  export type RelPlayerParentCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrder
    relationship?: SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    occupation?: SortOrder
    employer?: SortOrder
    workPhone?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelPlayerParentAvgOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    ord?: SortOrder
  }

  export type RelPlayerParentMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrder
    relationship?: SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    occupation?: SortOrder
    employer?: SortOrder
    workPhone?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelPlayerParentMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    assignedAt?: SortOrder
    removedAt?: SortOrder
    relationship?: SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    occupation?: SortOrder
    employer?: SortOrder
    workPhone?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelPlayerParentSumOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    parentId?: SortOrder
    isPrimaryContact?: SortOrder
    canPickup?: SortOrder
    receivesNotifications?: SortOrder
    ord?: SortOrder
  }

  export type RelSponsorClubOrderByRelevanceInput = {
    fields: RelSponsorClubOrderByRelevanceFieldEnum | RelSponsorClubOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelSponsorClubSponsorIdClubIdCompoundUniqueInput = {
    sponsorId: Decimal | DecimalJsLike | number | string
    clubId: Decimal | DecimalJsLike | number | string
  }

  export type RelSponsorClubCountOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorClubAvgOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type RelSponsorClubMaxOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorClubMinOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorClubSumOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    clubId?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type RelSponsorLeagueOrderByRelevanceInput = {
    fields: RelSponsorLeagueOrderByRelevanceFieldEnum | RelSponsorLeagueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelSponsorLeagueSponsorIdLeagueIdCompoundUniqueInput = {
    sponsorId: Decimal | DecimalJsLike | number | string
    leagueId: Decimal | DecimalJsLike | number | string
  }

  export type RelSponsorLeagueCountOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorLeagueAvgOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type RelSponsorLeagueMaxOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorLeagueMinOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorLeagueSumOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    leagueId?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type RelSponsorTeamOrderByRelevanceInput = {
    fields: RelSponsorTeamOrderByRelevanceFieldEnum | RelSponsorTeamOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelSponsorTeamSponsorIdTeamIdCompoundUniqueInput = {
    sponsorId: Decimal | DecimalJsLike | number | string
    teamId: Decimal | DecimalJsLike | number | string
  }

  export type RelSponsorTeamCountOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorTeamAvgOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type RelSponsorTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorTeamMinOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    sponsorshipAmount?: SortOrder
    benefits?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelSponsorTeamSumOrderByAggregateInput = {
    id?: SortOrder
    sponsorId?: SortOrder
    teamId?: SortOrder
    sponsorshipAmount?: SortOrder
    ord?: SortOrder
  }

  export type RelTeamCoachOrderByRelevanceInput = {
    fields: RelTeamCoachOrderByRelevanceFieldEnum | RelTeamCoachOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelTeamCoachTeamIdCoachIdCompoundUniqueInput = {
    teamId: Decimal | DecimalJsLike | number | string
    coachId: Decimal | DecimalJsLike | number | string
  }

  export type RelTeamCoachCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    coachTypeId?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    responsibilities?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamCoachAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    coachTypeId?: SortOrder
    salary?: SortOrder
    ord?: SortOrder
  }

  export type RelTeamCoachMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    coachTypeId?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    responsibilities?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamCoachMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    coachTypeId?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    responsibilities?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamCoachSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    coachId?: SortOrder
    coachTypeId?: SortOrder
    salary?: SortOrder
    ord?: SortOrder
  }

  export type RelTeamPlayerOrderByRelevanceInput = {
    fields: RelTeamPlayerOrderByRelevanceFieldEnum | RelTeamPlayerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelTeamPlayerTeamIdPlayerIdCompoundUniqueInput = {
    teamId: Decimal | DecimalJsLike | number | string
    playerId: Decimal | DecimalJsLike | number | string
  }

  export type RelTeamPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    jerseyNumber?: SortOrder
    positionId?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamPlayerAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    positionId?: SortOrder
    ord?: SortOrder
  }

  export type RelTeamPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    jerseyNumber?: SortOrder
    positionId?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    jerseyNumber?: SortOrder
    positionId?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamPlayerSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    positionId?: SortOrder
    ord?: SortOrder
  }

  export type RelTeamTeamManagerOrderByRelevanceInput = {
    fields: RelTeamTeamManagerOrderByRelevanceFieldEnum | RelTeamTeamManagerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RelTeamTeamManagerTeamIdManagerIdCompoundUniqueInput = {
    teamId: Decimal | DecimalJsLike | number | string
    managerId: Decimal | DecimalJsLike | number | string
  }

  export type RelTeamTeamManagerCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    managerTypeId?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    responsibilities?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamTeamManagerAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    salary?: SortOrder
    ord?: SortOrder
  }

  export type RelTeamTeamManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    managerTypeId?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    responsibilities?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamTeamManagerMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    status?: SortOrder
    managerTypeId?: SortOrder
    salary?: SortOrder
    contractStart?: SortOrder
    contractEnd?: SortOrder
    responsibilities?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelTeamTeamManagerSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    salary?: SortOrder
    ord?: SortOrder
  }

  export type SportCoachTypeOrderByRelevanceInput = {
    fields: SportCoachTypeOrderByRelevanceFieldEnum | SportCoachTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SportCoachTypeSportIdNameCompoundUniqueInput = {
    sportId: Decimal | DecimalJsLike | number | string
    name: string
  }

  export type SportCoachTypeCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportCoachTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SportCoachTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportCoachTypeMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportCoachTypeSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SportEventTypeOrderByRelevanceInput = {
    fields: SportEventTypeOrderByRelevanceFieldEnum | SportEventTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SportEventTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    category?: SortOrder
    evaluationMetric?: SortOrder
    code?: SortOrder
    sportId?: SortOrder
    isVisible?: SortOrder
    note?: SortOrder
    ord?: SortOrder
    score?: SortOrder
    slot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportEventTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    evaluationMetric?: SortOrder
    sportId?: SortOrder
    isVisible?: SortOrder
    ord?: SortOrder
    score?: SortOrder
    slot?: SortOrder
  }

  export type SportEventTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    category?: SortOrder
    evaluationMetric?: SortOrder
    code?: SortOrder
    sportId?: SortOrder
    isVisible?: SortOrder
    note?: SortOrder
    ord?: SortOrder
    score?: SortOrder
    slot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportEventTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    category?: SortOrder
    evaluationMetric?: SortOrder
    code?: SortOrder
    sportId?: SortOrder
    isVisible?: SortOrder
    note?: SortOrder
    ord?: SortOrder
    score?: SortOrder
    slot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportEventTypeSumOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    evaluationMetric?: SortOrder
    sportId?: SortOrder
    isVisible?: SortOrder
    ord?: SortOrder
    score?: SortOrder
    slot?: SortOrder
  }

  export type SportGamePeriodOrderByRelevanceInput = {
    fields: SportGamePeriodOrderByRelevanceFieldEnum | SportGamePeriodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SportGamePeriodCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    ord?: SortOrder
    duration?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportGamePeriodAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
    duration?: SortOrder
  }

  export type SportGamePeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    ord?: SortOrder
    duration?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportGamePeriodMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    ord?: SortOrder
    duration?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportGamePeriodSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
    duration?: SortOrder
  }

  export type SportManagerTypeOrderByRelevanceInput = {
    fields: SportManagerTypeOrderByRelevanceFieldEnum | SportManagerTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SportManagerTypeSportIdNameCompoundUniqueInput = {
    sportId: Decimal | DecimalJsLike | number | string
    name: string
  }

  export type SportManagerTypeCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportManagerTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SportManagerTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportManagerTypeMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportManagerTypeSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SportPlayerPositionOrderByRelevanceInput = {
    fields: SportPlayerPositionOrderByRelevanceFieldEnum | SportPlayerPositionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SportPlayerPositionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportPlayerPositionAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
  }

  export type SportPlayerPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportPlayerPositionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    note?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportPlayerPositionSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    ord?: SortOrder
  }

  export type SportRefereeTypeOrderByRelevanceInput = {
    fields: SportRefereeTypeOrderByRelevanceFieldEnum | SportRefereeTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SportRefereeTypeSportIdNameCompoundUniqueInput = {
    sportId: Decimal | DecimalJsLike | number | string
    name: string
  }

  export type SportRefereeTypeCountOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportRefereeTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SportRefereeTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportRefereeTypeMinOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    name?: SortOrder
    abbr?: SortOrder
    color?: SortOrder
    note?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SportRefereeTypeSumOrderByAggregateInput = {
    id?: SortOrder
    sportId?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SubFeatureOrderByRelevanceInput = {
    fields: SubFeatureOrderByRelevanceFieldEnum | SubFeatureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SubFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SubForTeamOrderByRelevanceInput = {
    fields: SubForTeamOrderByRelevanceFieldEnum | SubForTeamOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubForTeamCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentAt?: SortOrder
    nextPaymentAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubForTeamAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    autoRenew?: SortOrder
    ord?: SortOrder
  }

  export type SubForTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentAt?: SortOrder
    nextPaymentAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubForTeamMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentAt?: SortOrder
    nextPaymentAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubForTeamSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    planId?: SortOrder
    autoRenew?: SortOrder
    ord?: SortOrder
  }

  export type SubForUserOrderByRelevanceInput = {
    fields: SubForUserOrderByRelevanceFieldEnum | SubForUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubForUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentAt?: SortOrder
    nextPaymentAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubForUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    autoRenew?: SortOrder
    ord?: SortOrder
  }

  export type SubForUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentAt?: SortOrder
    nextPaymentAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubForUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    autoRenew?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentAt?: SortOrder
    nextPaymentAt?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubForUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    autoRenew?: SortOrder
    ord?: SortOrder
  }

  export type SubPlanOrderByRelevanceInput = {
    fields: SubPlanOrderByRelevanceFieldEnum | SubPlanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    planType?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    description?: SortOrder
    features?: SortOrder
    maxTeams?: SortOrder
    maxPlayers?: SortOrder
    maxCoaches?: SortOrder
    maxReferees?: SortOrder
    storageLimitGb?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    maxTeams?: SortOrder
    maxPlayers?: SortOrder
    maxCoaches?: SortOrder
    maxReferees?: SortOrder
    storageLimitGb?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SubPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    planType?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    description?: SortOrder
    features?: SortOrder
    maxTeams?: SortOrder
    maxPlayers?: SortOrder
    maxCoaches?: SortOrder
    maxReferees?: SortOrder
    storageLimitGb?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    planType?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    description?: SortOrder
    features?: SortOrder
    maxTeams?: SortOrder
    maxPlayers?: SortOrder
    maxCoaches?: SortOrder
    maxReferees?: SortOrder
    storageLimitGb?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubPlanSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    isPopular?: SortOrder
    maxTeams?: SortOrder
    maxPlayers?: SortOrder
    maxCoaches?: SortOrder
    maxReferees?: SortOrder
    storageLimitGb?: SortOrder
    isActive?: SortOrder
    ord?: SortOrder
  }

  export type SubPlanFeatureOrderByRelevanceInput = {
    fields: SubPlanFeatureOrderByRelevanceFieldEnum | SubPlanFeatureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubPlanFeaturePlanIdFeatureIdCompoundUniqueInput = {
    planId: Decimal | DecimalJsLike | number | string
    featureId: Decimal | DecimalJsLike | number | string
  }

  export type SubPlanFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubPlanFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    ord?: SortOrder
  }

  export type SubPlanFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubPlanFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    notes?: SortOrder
    ord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubPlanFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    featureId?: SortOrder
    isIncluded?: SortOrder
    ord?: SortOrder
  }

  export type SysUserOrderByRelevanceInput = {
    fields: SysUserOrderByRelevanceFieldEnum | SysUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SysUserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    status?: SortOrder
    personId?: SortOrder
    rememberToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SysUserAvgOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
  }

  export type SysUserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    status?: SortOrder
    personId?: SortOrder
    rememberToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SysUserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    status?: SortOrder
    personId?: SortOrder
    rememberToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SysUserSumOrderByAggregateInput = {
    id?: SortOrder
    personId?: SortOrder
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BaseFieldCreatesportIdsInput = {
    set: number[]
  }

  export type BaseFieldUpdatesportIdsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}